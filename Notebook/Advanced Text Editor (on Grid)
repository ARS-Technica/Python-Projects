# -*- coding: utf-8 -*-
"""
Simple Text Editor

Expanded version of the Codemy Tutorial:
https://www.youtube.com/watch?v=UlQRXJWUNBA 

Rebuilding Simple Text Editor from the skeleton of a working 
Line Numbering function to build the application to use the grid geometry manager
to create two columns: one for the line numbers and one for the text widget. 

Note:
You can't mix grid and pack on the same parent widget. You'll need to decide on
one and use it consistently for all child widgets.  To fix the error, you need
to choose to either use grid or pack for all the widgets inside the parent widget.

Changelog: Wrestling all widgets onto a grid system.
"""


# Imports
# Global Variables


# File Menu Functions


# Line Number Canvas
# Drop Down Menus 
# Context Menus
# Toolbar Buttons
# Create Window


# Import os and sys libraries to Open and Save files
import os, sys
# Import tkinter library
from tkinter import *
from tkinter import filedialog
from tkinter import font
from tkinter import messagebox
from tkinter import colorchooser
# Import TTK library to toggle Status Bar visibility
import tkinter.ttk as ttk   
import win32print
import win32api


# ***************** Setting Global Variables ***************** #

# Set variable for Open File name
global open_status_name
open_status_name = False

# Set variable for Paste text function
# Prevents error from occuring if Paste function doesn't find variable
global selected
selected = False

# Set variable for Status Bar status
# statusbar_is_on = IntVar()
# checkbutton = Checkbutton(root, text ="Test", variable=statusbar_is_on)
# checkbutton.select()











# ***************** Functions for the File Menu ***************** #

# Create New File Function
def new_file():
    # Delete previous text
    my_text.delete("1.0", END)
    root.title("New File")
    status_bar.config(text="New File       ")

    # Set variable for Open File name
    global open_status_name
    open_status_name = False

# Open File Function
def open_file():
    # Delete previous text
    my_text.delete("1.0", END)

    # Request filename
    # text_file = filedialog.askopenfilename(initialdir="C:/", title="Open File", filetypes=[("Text Files", "*.txt"), ("Python Files", "*.py"), ("All Files", "*.*")])    
    # Use os.path.dirname(__file__) to find the current directory of the .py file
    # Use  os.getcwd() for the current working directory 
    text_file = filedialog.askopenfilename(initialdir=os.path.dirname(__file__), title="Open File", filetypes=[("Text Files", "*.txt"), ("Python Files", "*.py"), ("HTML Files", "*.html"), ("All Files", "*.*")])

    # Check if there is a file name
    if text_file:
        # Make filename global so we can access it later
        global open_status_name
        open_status_name = text_file

    # Update Status Bar
    name = text_file
    status_bar.config(text=f"{name}       ")
    name = name.replace(os.path.dirname(__file__), "")
    root.title(f"{name} - Text Editor")

    # Open the File
    text_file = open(text_file, 'r')
    stuff = text_file.read()
    # Add file to textbox
    my_text.insert(END, stuff)
    # Close the opened file
    text_file.close()

# Save As File Function
def save_as_file():
    # Use os.path.dirname(__file__) to find the current directory of the .py file
    text_file = filedialog.asksaveasfilename(defaultextension="*.*", initialdir=os.path.dirname(__file__), title="Save File", filetypes=[("Text Files", "*.txt"), ("Python Files", "*.py"), ("HTML Files", "*.html"), ("All Files", "*.*")])
    if text_file:
        # Update Status Bar
        name = text_file
        status_bar.config(text=f"{name}       ")
        name = name.replace(os.path.dirname(__file__), "")
        root.title(f"{name} - Text Editor")

        # Save the file
        text_file = open(text_file, "w")
        text_file.write(my_text.get(1.0, END))
        # Close the file
        text_file.close()

# Save File Function
def save_file():
    global open_status_name
    if open_status_name:
        # Save the file
        text_file = open(open_status_name, "w")
        text_file.write(my_text.get(1.0, END))
        # Close the file
        text_file.close()
        # Confirm that the file has been saved
        messagebox.showinfo("confirmation", "File Saved!")        
        status_bar.config(text=f"Saved: {open_status_name}       ")
    else:
        save_as_file()

# Print File Function
def print_file():
    # Detect default printer
    #print_name = win32print.GetDefaultPrinter()
    #status_bar.config(text=printer_name)

    # Request filename
    file_to_print = filedialog.askopenfilename(initialdir=os.path.dirname(__file__), title="Open File", filetypes=[("Text Files", "*.txt"), ("Python Files", "*.py"), ("HTML Files", "*.html"), ("All Files", "*.*")])    

    # If the command isn't canceled
    if file_to_print:
        win32api.ShellExecute(0, "print", file_to_print, None, ".", 0)

# Close App Function
def exit_file():
    message = messagebox.askyesno(
        "Do you want to exit?",
        "Do you want to save the file? " )

    if message:
        save_as_file()
        # root.quit()
        root.destroy()
    else:
        # root.quit()
        root.destroy()











# ***************** Create the Line Number Canvas ***************** #

# Tkinter adding line number to text widget inspired by:
# https://stackoverflow.com/questions/16369470/tkinter-adding-line-number-to-text-widget

# Function to redraw the line numbers on the canvas whenever the text in the text widget is changed
def create_text_line_numbers(canvas, text_widget):
    """
    # First, delete all existing text in the canvas
    # Next, find the starting index of the text widget, and iterate over all lines of text
    # For each line, calculate the vertical position and line number, and draw it on the canvas
    """
    def redraw(*args):
        # Redraw line numbers
        canvas.delete("all")

        i = text_widget.index("@0,0")
        while True:
            dline = text_widget.dlineinfo(i)
            if dline is None:
                break
            y = dline[1]
            linenum = str(i).split(".")[0]
            canvas.create_text(2, y, anchor="nw", text=linenum)
            i = text_widget.index("%s+1line" % i)

    return redraw


# Function to create the text widget 
def create_custom_text(root, scrollbar, linenumbers_canvas):
    """
    Creates the text widget, sets up a scrollbar, and binds the <<Change>> event
    to the create_text_line_numbers function.
    """
    text_widget = Text(root)

    # Function to generate an event <<Change>> whenever something is added or deleted in the text_widget 
    def proxy(*args):
        # Let the actual widget perform the requested action
        cmd = (text_widget._orig,) + args
        result = text_widget.tk.call(cmd)

        # Generate an event if something was added or deleted, or the cursor position changed
        if (
            args[0] in ("insert", "replace", "delete")
            or args[0:3] == ("mark", "set", "insert")
            or args[0:2] == ("xview", "moveto")
            or args[0:2] == ("xview", "scroll")
            or args[0:2] == ("yview", "moveto")
            or args[0:2] == ("yview", "scroll")):
            text_widget.event_generate("<<Change>>", when="tail")

        # Return what the actual widget returned
        return result

    # Rename the original method of the text_widget and create a new one that will forward calls to it
    text_widget._orig = text_widget._w + "_orig"
    text_widget.tk.call("rename", text_widget._w, text_widget._orig)
    text_widget.tk.createcommand(text_widget._w, proxy)
    text_widget.configure(yscrollcommand=scrollbar.set)

    # Create two columns: one for the line numbers and one for the text widget
    # Line number canvas column (Left)
    linenumbers_canvas.grid(row=0, column=0, sticky="nsew")
    linenumbers_canvas.grid_propagate(False)
    linenumbers_canvas.configure(width=30)

    # Text widget column (Right)
    text_widget.grid(row=0, column=1, sticky="nsew")

    root.grid_rowconfigure(0, weight=1, minsize=linenumbers_canvas.winfo_reqheight())
    # Configure the second column (Text) to stretch and shrink
    root.grid_columnconfigure(1, weight=1)

    """
    The linenumbers_canvas is now passed as an argument to create_custom_text,
    and is placed in the first column using grid. The second column is configured
    to stretch and shrink using columnconfigure.
    """

    # Bind the <<Change>> event to the create_text_line_numbers function to redraw the line numbers whenever the TEXT changes
    text_widget.bind("<<Change>>", create_text_line_numbers(linenumbers_canvas, text_widget))
    # Bind the <<Modified>> event to the create_text_line_numbers function to redraw the line numbers whenever the CONTENTS of the text widget are changed
    text_widget.bind("<<Modified>>", create_text_line_numbers(linenumbers_canvas, text_widget))
    # Bind the <Configure> event to the create_text_line_numbers function to redraw the line numbers whenever the SIZE of the text widget changes
    # Omit the following line and linenumbers_canvas won't add number until selected.
    text_widget.bind("<Configure>", create_text_line_numbers(linenumbers_canvas, text_widget))

    return text_widget


# Shows or hides the line numbers canvas.  Called from Options menu
# Function modified to set the row and column for the canvas
def toggle_linenumbers():
    """
    In this modified function, the linenumbers_canvas is placed in row 0 and
    column 0 using the grid() method. The sticky parameter is set to "nsew" to make
    the canvas fill the entire cell.

    The root.grid_rowconfigure(0, minsize=linenumbers_canvas.winfo_reqheight()) call
    is used to make the row height equal to the canvas height, which ensures that
    the canvas and text widget have the same height.
    """
    if linenumbers_button_var.get():
        linenumbers_canvas.grid(row=0, column=0, sticky="nsew")
        root.grid_rowconfigure(0, minsize=linenumbers_canvas.winfo_reqheight())
    else:
        linenumbers_canvas.grid_forget()
        root.grid_rowconfigure(0, minsize=0)


# ***************** Create the Drop Down Menus ***************** #

# Create menu bar
def create_menu():
    # Create the menu bar
    menubar = Menu(root)
    root.config(menu=menubar)

    # Add File Menu heading to the menubar
    file_menu = Menu(menubar, tearoff=False)
    menubar.add_cascade(label="File", menu=file_menu)

    file_menu.add_command(label="New", command=new_file)
    file_menu.add_command(label="Open", command=open_file)
    file_menu.add_command(label="Save", command=save_file)
    file_menu.add_command(label="Save As", command=save_as_file)
    file_menu.add_separator()
    file_menu.add_command(label="Print", command=print_file)
    file_menu.add_separator()
    # file_menu.add_command(label="Exit", command=root.quit)
    file_menu.add_command(label="Exit", command=exit_file)

    # Add Edit Menu heading to the menubar
    edit_menu = Menu(menubar, tearoff=False)
    menubar.add_cascade(label="Edit", menu=edit_menu)
    """
    edit_menu.add_command(label="Cut", command=lambda: cut_text(False), accelerator="(Ctrl+X)")
    edit_menu.add_command(label="Copy", command=lambda: copy_text(False), accelerator="(Ctrl+C)")
    edit_menu.add_command(label="Paste", command=lambda: paste_text(False), accelerator="(Ctrl+V)")
    edit_menu.add_command(label="Delete", command=lambda: delete_text(False), accelerator="(Del)")
    edit_menu.add_separator()
    edit_menu.add_command(label="Select All", command=lambda: select_all(False), accelerator="(Ctrl+Shft+A)")
    edit_menu.add_command(label="Clear All", command=lambda: clear_all(False))
    edit_menu.add_separator()
    edit_menu.add_command(label="Undo", command=my_text.edit_undo, accelerator="(Ctrl+Z)")
    edit_menu.add_command(label="Redo", command=my_text.edit_redo, accelerator="(Ctrl+Y)")
    """
    # Add Search Menu heading to the menubar
    search_menu = Menu(menubar, tearoff=False)
    menubar.add_cascade(label="Search", menu=search_menu)
    """
    search_menu.add_command(label="Find", command=lambda: find(False), accelerator="(Ctrl+F)")
    search_menu.add_command(label="Fuzzy Find", command=fuzzy_find)
    search_menu.add_command(label="Find Next", command=lambda: find_next(False), accelerator="(F3)")
    search_menu.add_command(label="Replace", command=lambda: replace(False), accelerator="(Ctrl+H)")
    search_menu.add_separator()
    search_menu.add_command(label="Go To Line", command=go_to_line)
    """
    # Add Format Menu heading to the menubar
    format_menu = Menu(menubar, tearoff=False)
    menubar.add_cascade(label="Format", menu=format_menu)
    """
    format_menu.add_command(label="Left Align", command=left_align)
    format_menu.add_command(label="Right Align", command=right_align)
    format_menu.add_command(label="Center Align", command=center_align)
    format_menu.add_command(label="Justify Align", command=justify_align)
    format_menu.add_separator()
    format_menu.add_command(label="Selected Text", command=text_color)
    format_menu.add_command(label="All Text", command=all_text_color)
    format_menu.add_command(label="Background", command=bg_color)
    format_menu.add_separator()
    format_menu.add_command(label="Bold", command=bold_it)
    format_menu.add_command(label="Italics", command=italics_it)
    format_menu.add_command(label="Underline", command=underline_it)
    format_menu.add_command(label="Strike", command=strike_it)
    """
    # Add Tools Menu heading to the menubar
    tools_menu = Menu(menubar, tearoff=False)
    menubar.add_cascade(label="Tools", menu=tools_menu)
    """
    tools_menu.add_command(label="Change Case", command=case_tools)
    tools_menu.add_command(label="Characters", command=character_tools)
    tools_menu.add_command(label="Expressions", command=expression_tools)
    tools_menu.add_command(label="Lines", command=line_tools)
    tools_menu.add_command(label="Transform", command=transform_tools)
    tools_menu.add_command(label="White Space", command=space_tools)
    tools_menu.add_separator()
    tools_menu.add_command(label="Statistical Analysis", command=statistic_tools)
    """
    # Add Options Menu heading to the menubar
    options_menu = Menu(menubar, tearoff=False)
    menubar.add_cascade(label="Options", menu=options_menu)
    """
    # Toggle line highlighting on and off
    highlighting = BooleanVar()
    options_menu.add_checkbutton(label="Line Highlighting", onvalue=True, offvalue=False, variable=highlighting, command=toggle_line_highlighting)
    """

    # Toggle line numbering on and off
    global linenumbers_button_var
    linenumbers_button_var = BooleanVar(value=True)  # Line numbering is on by default

    options_menu.add_checkbutton(
        label="Show Line Numbers",
        variable=linenumbers_button_var,
        onvalue=True,
        offvalue=False,
        command=toggle_linenumbers,)    

    """
    # Toggle line numbering on and off 
    show_line_numbers_var = BooleanVar()
    show_line_numbers_var.set(True)  # Line numbering is on by default
    options_menu.add_checkbutton(label="Line Numbers", variable=show_line_numbers_var, command=toggle_line_numbers)

    # Toggle Night Mode on and off
    night = BooleanVar()
    options_menu.add_checkbutton(label="Night Mode", onvalue=True, offvalue=False, variable=night, command=night_mode)

    # Toggle the visibility of the Status Bar on and off
    status = BooleanVar()
    options_menu.add_checkbutton(label="Status Bar", onvalue=True, offvalue=False, variable=status, command=status_bar)

    # Toggle Word Wrap on and off
    wrap = BooleanVar()
    options_menu.add_checkbutton(label="Word Wrap", onvalue=True, offvalue=False, variable=wrap, command=word_wrap)
    """


# Create the application
def create_window():
    global root, scrollbar, linenumbers_canvas, text_widget

    # Create the main window
    root = Tk()
    root.title("Text Editor")
    # root.iconbitmap('c:/path/to/icon.ico')
    root.geometry("1200x690")
    root.resizable(True,True)

    # Create a vertical scrollbar for the linenumbers_canvas
    scrollbar = Scrollbar(root)   
    # linenumbers_canvas.grid(row=0, column=0, sticky="nsew")
    scrollbar.grid(row=0, column=2, sticky="ns")

    # Create canvas to hold line numbers
    linenumbers_canvas = Canvas(root)



 

    
    

    # Create Widget Frame
    # my_frame = Frame(root)
    # my_frame.pack(fill=BOTH, expand=True, padx=5, pady=5)
    my_frame = Frame(root)
    my_frame.grid(row=1, column=0, sticky="nsew")    


    # Create Text Widget Frame
    text_frame = Frame(root)
    text_frame.grid(row=1, column=0, sticky="nsew")

    """   
    # Create Text Widget
    text = Text(my_frame, wrap=NONE)
    text.pack(side=LEFT, fill=BOTH, expand=True)
    """



    

    # Create text_widget passing the root, scrollbar, and linenumbers_canvas as arguments.
    text_widget = create_custom_text(root, scrollbar, linenumbers_canvas)   
    text_widget.insert("end", "Type some text here...")




    # Create Vertical Scrollbar for the Text Box
    # text_scroll = Scrollbar(my_frame)
    # text_scroll.pack(side=RIGHT, fill=Y)
    """
    text_scroll = Scrollbar(my_frame, orient=VERTICAL, command=my_text.yview)
    text_scroll.pack(side=RIGHT, fill=Y)
    my_text.configure(yscrollcommand=text_scroll.set)
    """
    # Create Horizontal Scrollbar for the Text Box
    # horizontal_scroll = Scrollbar(my_frame, orient="horizontal")
    # horizontal_scroll.pack(side=BOTTOM, fill=X)
    """
    horizontal_scroll = Scrollbar(my_frame, orient=HORIZONTAL, command=my_text.xview)
    horizontal_scroll.pack(side=BOTTOM, fill=X)
    my_text.configure(xscrollcommand=horizontal_scroll.set)
    """
    # Configure Scrollbars
    #text_scroll.config(command=my_text.yview)
    #horizontal_scroll.config(command=my_text.xview)






    text_widget.insert("end", "one\ntwo\nthree\n")
    text_widget.insert("end", "four\n", ("bigfont",))
    text_widget.insert("end", "five\n")
    text_widget.tag_configure("bigfont", font=("Helvetica", "24", "bold")) 

    
    # Create the menubar    
    create_menu()

    # Starts the main event loop of the tkinter application
    root.mainloop()


if __name__ == "__main__":
    create_window()



"""
Possible improvements:
    Change behavior of Bold function to highlight all text if Bold button
    is pushed a second time while highlight text partially tagged.
    
    Improve print function
    
    Change out the Clear All function for Delete
       
    Find a way to preserve formatting for text during saves
    
    Add Clear All Formatting function
    
    Organize code into Classes?
    
    Number the lines, then make the visibility of the lines optional
       
    Change Status bar to word count
    
    Use Status Bar visibility to include search
    
    Make color scheme customizable:
        main_color = "SystemButtonFace"
        second_color = "SystemButtonFace"
        text_color = "black"
"""
