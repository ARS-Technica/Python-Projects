# -*- coding: utf-8 -*-
"""
Simple Text Editor

Expanded version of the Codemy Tutorial:
https://www.youtube.com/watch?v=UlQRXJWUNBA 

Rebuilding Simple Text Editor from the skeleton of a working 
Line Numbering function to build the application to use the grid geometry manager
to create two columns: one for the line numbers and one for the text widget. 

Changelog: Moving Search function to Status Bar:
    
When a user uses the keyboard shortcut Control+F or selects "Find" from the Search
Menu, the search widget will appear beneath the text widget, replacing the Status
Bar.  If the Status Bar is visible when the Search Bar is activated, it will 
reappear when the Search Bar is closed. The new functions were created and debugged
in the file "text_editor skeleton for status AND search bar combined."

        - Transfer all Search Functions from text_editor skeleton


"""

# Imports
# Global Variables

# Create Widgets
    # Text Widget Functions 

# Import os and sys libraries to Open and Save files
import os, sys
# Import tkinter library
from tkinter import *
from tkinter import filedialog
from tkinter import font
from tkinter import messagebox
from tkinter import colorchooser
# Import TTK library to toggle Status Bar visibility
import tkinter.ttk as ttk   
import win32print
import win32api


# ***************** Create Interface Widgets ***************** #

# Create Text Widget
def create_custom_text(window, linenumbers_canvas):
    """
    Takes two arguments: a window object and a canvas for line numbers. It creates
    and returns a text widget with some customized properties, such as font,
    selection colors, undo capability, and scrolling bars. It also creates a
    proxy function that is used to intercept any text widget method calls and
    generate a "<<Change>>" event, which is used to redraw the line numbers. It
    then binds the widget to several events, such as "Change", "Modified", and
    "Configure", and returns the widget.
    
    Creates the text widget, sets up a scrollbar, and binds the <<Change>> event
    to the create_text_line_numbers function (below).
    """
    # Global text is required to make word_wrap() function work
    global text

    # Creates a frame to hold the text editor widget
    text_editor_frame = Frame(window)
    # Creates a Text Widget and adds it to the frame
    text = Text(text_editor_frame, font=("Helvetica", 16), selectbackground="yellow",
                selectforeground="black", undo=True, padx=5, pady=5, wrap="none")

    # Function to generate an event <<Change>> whenever something is added or deleted in the text widget 
    def proxy(*args):
        """
        Intercepts any method calls made on the Text widget and generates
        a "<<Change>>" event. This event is used to redraw the line numbers
        whenever there is a change in the text widget.
        """
        cmd = (text._orig,) + args
        result = text.tk.call(cmd)

        # Generate an event if something was added or deleted, or the cursor position changed
        if (
            args[0] in ("insert", "replace", "delete")
            or args[0:3] == ("mark", "set", "insert")
            or args[0:2] == ("xview", "moveto")
            or args[0:2] == ("xview", "scroll")
            or args[0:2] == ("yview", "moveto")
            or args[0:2] == ("yview", "scroll")
        ):
            text.event_generate("<<Change>>", when="tail")

        # Return what the actual widget returned
        return result

    """
    text._orig is the original widget name of the Text widget, which was saved earlier in the _orig attribute.
    text.tk.call is a method of the Text widget's parent, which allows us to execute a Tcl/Tk command on the Text widget.
    
    So, the text.tk.call("rename", text._w, text._orig) line is
    effectively calling the rename command of Tcl/Tk with two arguments: the
    internal name of the temporary widget (text._w) and the original name of
    the Text widget (text._orig). This renames the temporary widget to its
    original name, effectively replacing the existing widget with the modified one.
    """

    # Rename the original method of the text widget and create a new one that will forward calls to it
    text._orig = text._w + "_orig"
    text.tk.call("rename", text._w, text._orig)
    text.tk.createcommand(text._w, proxy)
    """
    The text.tk.call("rename", text._w, text._orig) line renames the
    temporary widget to its original name, effectively replacing the existing
    widget with the modified one.
    """  

    # Creates vertical and horizontal scrollbars for the Text widget
    # Configures the widget to use these scrollbars. 
    vertical_scrollbar = Scrollbar(text_editor_frame, orient="vertical", command=text.yview)
    text.configure(yscrollcommand=vertical_scrollbar.set)
    horizontal_scrollbar = Scrollbar(text_editor_frame, orient="horizontal", command=text.xview)
    text.configure(xscrollcommand=horizontal_scrollbar.set)

    text.grid(row=0, column=0, sticky="nsew")

    # The frame and scrollbars are laid out using the grid manager.    
    vertical_scrollbar.grid(row=0, column=1, sticky="ns")
    horizontal_scrollbar.grid(row=1, column=0, sticky="ew")
    text_editor_frame.grid_rowconfigure(0, weight=1)
    text_editor_frame.grid_columnconfigure(0, weight=1)

    text_editor_frame.grid(row=1, column=1, sticky="nsew", padx=2, pady=2)  # columnspan=2) ?

    # Events are used to update the line numbers whenever there is a change in the text widget or when it is resized.

    # Bind the <<Change>> event to the create_text_line_numbers function to redraw the line numbers whenever the TEXT changes
    text.bind("<<Change>>", create_text_line_numbers(linenumbers_canvas, text))
    # Bind the <<Modified>> event to the create_text_line_numbers function to redraw the line numbers whenever the CONTENTS of the text widget are changed
    text.bind("<<Modified>>", create_text_line_numbers(linenumbers_canvas, text))
    # Bind the <Configure> event to the create_text_line_numbers function to redraw the line numbers whenever the SIZE of the text widget changes
    text.bind("<Configure>", create_text_line_numbers(linenumbers_canvas, text))

    return text

def create_search_bar(window):  
    global search_bar
    global search_bar_checkbutton_var    

    search_bar_checkbutton_var = IntVar()
    
    # ***************** Search Bar Widget ***************** #
    
    # Can't use grid and pack geometry managers on widgets that share the same parent.

    search_bar = Frame(window, bd=5, height=25, highlightthickness=0)
    #search_bar.pack(side="bottom", sticky="sw", padyx=5, pady=5)
    search_bar.grid(row=3, column=1, sticky="ew", pady=5)
    search_bar.grid_remove()  # Hide search bar initially

    # Search Widget
    global search_entry

    search_label = Label(search_bar, text="Search:")
    #search_label.pack(side="left", padx=2, pady=2)
    search_label.grid(row=0, column=0, padx=2, pady=2, sticky="w")

    # Creating an Entry widget for user to input search term    
    search_entry = Entry(search_bar)
    #search_entry.pack(side="left", padx=5, pady=5)
    search_entry.grid(row=0, column=1, padx=5, pady=5, sticky="w")

    # Creating a Button widgets to initiate the search and highlighting
    # Search down the text widget from the top
    search_next_button = Button(search_bar, text="Find Next", command=find_next)
    #search_button.pack(side=LEFT, padx=5, pady=5)    
    search_next_button.grid(row=0, column=2, padx=5, pady=5, sticky="w")

    # Search up the text widget from the bottom
    search_prev_button = Button(search_bar, text="Find Prev", command=find_previous)
    #search_button.pack(side=LEFT, padx=5, pady=5)
    search_prev_button.grid(row=0, column=3, padx=5, pady=5, sticky="w")

    clear_search_button = Button(search_bar, text="Clear Search", command=clear_find_results) 
    #clear_search_button.pack(side="left", padx=2, pady=2)
    clear_search_button.grid(row=0, column=4, padx=2, pady=2, sticky="w")

    # Add invisible button to create space between button groups
    space_button = Button(search_bar, text="",
                          padx=5, pady=5, relief="flat", width=5, state='disabled')
    #space_button.pack(side="left", padx=2, pady=2)
    space_button.grid(row=0, column=5, padx=2, pady=2, sticky="w")

    search_all_button = Button(search_bar, text="Find All", command=find_all) 
    #search_all_button.pack(side="left", padx=2, pady=2)
    search_all_button.grid(row=0, column=6, padx=2, pady=2, sticky="w")


    # Initializing the search_positions list and current_result_index variable
    search_positions = []
    current_result_index = -1


    # Place cursor in Search Entry text box when the Search becomes visible
    search_entry.focus_set()    # Set focus to search entry widget

def create_status_bar(window):
    # Declare global variable to track the visibility of the Status Bar
    # Should the Status be restored when the Search Bar is toggled off?
    is_status_bar_visible = True    # On by default

    global status_bar_checkbutton_var
    # Create variables for check buttons
    status_bar_checkbutton_var = IntVar()
    
    global status_bar   
    # Create status bar
    status_bar = Label(window, text="Status Bar")    
   
"""
# Create the Status Bar
def create_status_bar():
    
    #Creates or destroys a status bar, depending on the state of the statusbar_is_on variable.   
    #Creates a status bar label that can be updated with the update_status_bar function.
    
    global status_bar, status_bar_label

    if statusbar_is_on.get() == 1:
        # ON
        status_bar = ttk.Frame(window)
        status_bar.grid(row=4, column=1, sticky="WE", pady=5)

        status_bar_label = ttk.Label(status_bar, text="STATUS BAR TOGGLED")
        status_bar_label.grid(row=1, column=1, sticky="WE", padx=5)
    else:
        # OFF
        status_bar.destroy()
"""

# ***************** Search Menu Functions ***************** #

# Declare search_positions as an empty list before using it
# Used to avoid "NameError: name 'search_positions' is not defined" error
search_positions = []
"""
A global list variable search_positions is declared as an empty list. 
It will be used to store the positions of search results in the text widget.
"""

def find_all():
    """  
    The find_all function is responsible for finding and highlighting all 
    occurrences of a search term within the text widget.
    It retrieves the search term from an entry widget named search_entry.
    If the search term is not empty, it initiates a search loop using the
    text_widget.search method. It starts searching from the beginning of the
    text widget (start_pos = "1.0") and continues until no further occurrences
    are found (pos = None).
    
    When an occurrence is found, it adds a tag named "found" to the corresponding
    positions using text_widget.tag_add.  The end position is calculated based
    on the length of the search term and added to the start position.
    
    If no search term is entered, it displays an error message using messagebox.showerror.
    """
    search_text = search_entry.get()

    if search_text:
        start_pos = "1.0"
        while True:
            pos = text_widget.search(search_text, start_pos, stopindex="end")
            if not pos:
                break
            end_pos = f"{pos}+{len(search_text)}c"
            text_widget.tag_add("found", pos, end_pos)
            start_pos = end_pos
        text_widget.tag_configure("found", background="yellow")
    else:
        # If text hasn't been entered into the Entry widget, display an error message
        messagebox.showerror("Search", "Please enter text before searching")

# Defining a function to search for the next occurrence of the search term
def find_next():
    """
    The search function finds all the positions of the search term in the text
    and compiles them into a list called search_positions. It also highlights
    the first instance of the search term and sets the current_result_index
    variable to -1.
    """
        
    # Use the global keyword to access the search_positions variable from outside this function
    global search_positions

    # Retrieve the search term from the search_entry widget
    search_text = search_entry.get()

    # If the search text is not empty, begin the search
    # Find the search term in the Text widget and store the positions in a list
    if search_text:
        # Start searching from the beginning of the text widget
        start_pos = "1.0"
        
        """
        Added an if statement to check if search_positions is empty. If it's empty,
        that means it's the first time the function is being called, so it will
        perform the initial search and highlight the first instance of the search term.
        If search_positions is not empty, it will increment the current_result_index
        variable to move to the next search result, and if it reaches the end of
        the list, it will wrap around to the beginning. 
        """        
        if not search_positions:
            # Create an empty list to hold the positions of search results
            search_positions = []
            # Keep searching until there are no more matches
            while True:
                # Search for the next occurrence of the search text starting from start_pos
                pos = text_widget.search(search_text, start_pos, stopindex="end")
                # If no match is found, break out of the loop
                if not pos:
                    break
                # Calculate the end position of the match by adding the length of the search text to the start position
                end_pos = f"{pos}+{len(search_text)}c"
                # Apply the "found" tag to the matched text to highlight it
                text_widget.tag_add("found", pos, end_pos)
                # Update start_pos to the end position of the match to search for the next occurrence
                start_pos = end_pos
                # Add the position of the match to the search_positions list
                search_positions.append(pos)
            # Configuring the "found" tag with a yellow background
            text_widget.tag_configure("found", background="yellow")
            # Declaring global variables
            global current_result_index
            # Set the current_result_index to -1 to start with the first search result              
            # Setting the current_result_index variable to 0 highlights SECOND instance
            current_result_index = -1

        # Highlighting the next occurrence of the search term
        if current_result_index < len(search_positions) - 1:
            current_result_index += 1
        else:
            current_result_index = -1
        
        # Call the next_result function to show the first search result
        next_result() # This line ensure that the first instance is highlighted 
    else:
        # If text hasn't been entered into the Entry widget, display an error message
        messagebox.showerror("Search", "Please enter text before searching")

def find_previous():
    """
    The find_previous() function is similar to find_next() but searches backwards.
    The previous_result function scrolls the text widget to the position of the
    previous instance of the search term.
    """
    
    # Use the global keyword to access the current_result_index variable from outside this function    
    global current_result_index
    global search_positions
    #global text_widget
    
    #text_widget.tag_remove("found", "1.0", "end")

    search_text = search_entry.get()

    if search_text:
        end_pos = "end-1c"
        if not search_positions:
            search_positions = []
            while True:
                pos = text_widget.search(search_text, end_pos, stopindex="1.0", backwards=True)
                if not pos:
                    break
                end_pos = pos
                text_widget.tag_add("found", pos, f"{pos}+{len(search_text)}c")
                search_positions.insert(0, pos)
            text_widget.tag_configure("found", background="yellow")
            current_result_index = len(search_positions)
        if current_result_index > 0:
            current_result_index -= 1
        else:
            current_result_index = len(search_positions) - 1
        next_result()
    # If text hasn't been entered into the Entry widget, display an error message
    else:
        messagebox.showerror("Search", "Please enter text before searching")

# Defining a function to highlight the current occurrence of the search term
def next_result():
    """
    The next_result function highlights the next instance of the search term
    and updates the current_result_index variable to keep track of which
    result is currently being shown. If there are no more search results,
    it displays a message to the user.
    """
    
    # Declaring global variables
    # Use the global keyword to access the search_positions and current_result_index variables from outside this function
    global current_result_index
    global search_positions

    # Highlighting the current occurrence of the search term
    # If there are search results
    if search_positions:
        # Remove any existing "found" tags on the text widget
        text_widget.tag_remove("found", "1.0", "end")
        # Get the position of the current search result from the search_positions list
        result_pos = search_positions[current_result_index]
        # Calculate the end position of the match by adding the length of the search text to the start position
        end_pos = f"{result_pos}+{len(search_entry.get())}c"
        # Apply the "found" tag to the matched text to highlight it
        text.tag_add("found", result_pos, end_pos)

        text_widget.mark_set("insert", result_pos)
        # Configure the text widget to scroll to the matched text
        text_widget.see(result_pos)

# Clear Find results to start over
def clear_find_results(event=None):
    # "event=None" is the secret sauce that makes keybinding work
    global current_result_index
    global search_positions

    # Check Current tags
    if "found" in text_widget.tag_names():
        # Remove results highlighting
        text_widget.tag_remove("found", "1.0", "end")
        # Reset global variables to default for new search
        search_positions = []
        current_result_index = -1

    # Clear search results with clear_find_results upon entering new text in widget
    search_entry.bind("<KeyRelease>", clear_find_results)
   
def fuzzy_find():
    pass

def replace():
    pass

def go_to_line():
    pass


# ***************** Options Menu Functions ***************** #
     
# Toggle line number visibility on and off
def toggle_linenumbers():
    """
    Toggles the visibility of the canvas for line numbers, depending on the
    state of the linenumbers_button_var variable.
    """
    if linenumbers_button_var.get():
        linenumbers_canvas.grid(row=1, column=0, sticky="NS")
        window.grid_rowconfigure(0, weight=0, minsize=0)
        window.grid_rowconfigure(1, weight=1, minsize=0)
    else:
        linenumbers_canvas.grid_forget()         

# Toggle Word Wrap on and off
def word_wrap():
    if wrap.get() == True:
        text.config(wrap="word")
        if statusbar_is_on.get() == 1:        
            status_bar_label.config(text="Word Wrap On       ")
    else:
        text.config(wrap="none")
        if statusbar_is_on.get() == 0:        
            status_bar_label.config(text="Word Wrap Off       ")    


# ***************** Status Bar Functions ***************** #

def toggle_status_bar():
    global is_status_bar_visible

    # If Search Bar is visible, set a variable 
    if search_bar.winfo_ismapped():
        is_status_bar_visible = True      # Make Status Bar visible when Search Bar is off    
    # If Search Bar is NOT visible
    else:
        if status_bar_checkbutton_var.get() == 1:
            status_bar.grid(row=2, column=0, columnspan=2, sticky=W)
            is_status_bar_visible = True
        else:
            status_bar.grid_remove()
            is_status_bar_visible = False

# The event=None declaration ensures that the function can still be called without any arguments in the keybindings.
def toggle_search_bar(event=None):
    global is_status_bar_visible

    # If the Search Bar is already visible, remove it
    if search_bar.winfo_ismapped():
        search_bar.grid_remove()
        search_bar_checkbutton_var.set(0)
        if is_status_bar_visible:
            status_bar.grid(row=2, column=0, columnspan=2, sticky=W)
            status_bar_checkbutton_var.set(1)
    else:
        search_bar.grid(row=2, column=0, columnspan=2, sticky='w')
        search_bar_checkbutton_var.set(1)

        if is_status_bar_visible:
            status_bar.grid_remove()
            status_bar_checkbutton_var.set(0)
 

# ***************** Create Menus ***************** #

# Drop Down Menu
def create_menu(window):
    # Create menu bar
    menu_bar = Menu(window)
    window.config(menu=menu_bar)

    file_menu = Menu(menu_bar, tearoff=False)
    menu_bar.add_cascade(label="File", menu=file_menu)
    
    
    # Create "Messages" heading in the menu bar
    messages_menu = Menu(menu_bar, tearoff=False)
    menu_bar.add_cascade(label="Messages", menu=messages_menu)

    # Create three items in the messages menu
    messages_menu.add_command(label="Item 1", command=lambda: status_bar.config(text="Item 1"))
    messages_menu.add_command(label="Item 2", command=lambda: status_bar.config(text="Item 2"))
    messages_menu.add_command(label="Item 3", command=lambda: status_bar.config(text="Item 3"))
    
    
    # Create "Options" heading in the menu bar
    options_menu = Menu(menu_bar, tearoff=False)
    menu_bar.add_cascade(label="Options", menu=options_menu)

    global linenumbers_button_var
    linenumbers_button_var = BooleanVar(value=True)

    options_menu.add_checkbutton(
        label="Show Line Numbers",
        variable=linenumbers_button_var,
        onvalue=True,
        offvalue=False,
        command=toggle_linenumbers)   
    
    # Toggle Word Wrap on and off
    global wrap
    wrap = BooleanVar(value=False)  # Word Wrap is deactivated by default
    
    options_menu.add_checkbutton(
        label="Word Wrap",
        variable=wrap,
        onvalue=True,
        offvalue=False,        
        command=word_wrap)

    # Create check button for status bar in the options menu
    status_bar_checkbutton_var.set(1)  # Set default value to 1 (on)
    status_bar_checkbutton = options_menu.add_checkbutton(label="Status bar", variable=status_bar_checkbutton_var, command=toggle_status_bar)

    # Create "Search" heading in the menu bar
    search_menu = Menu(menu_bar, tearoff=False)
    menu_bar.add_cascade(label="Search", menu=search_menu)

    # Create check button for search bar in the search menu
    search_bar_checkbutton_var.set(0)
    search_bar_checkbutton = search_menu.add_checkbutton(label="Search bar", variable=search_bar_checkbutton_var, command=toggle_search_bar)


def create_toolbar(window):
    toolbar_frame = Frame(window, bd=5, highlightthickness=0)

    bold_button = Button(toolbar_frame, text="Bold")
    bold_button.grid(row=0, column=0, padx=2, pady=0)

    italic_button = Button(toolbar_frame, text="Italic")
    italic_button.grid(row=0, column=1, padx=2, pady=0)

    underline_button = Button(toolbar_frame, text="Underline")
    underline_button.grid(row=0, column=2, padx=2, pady=0)

    toolbar_frame.grid(row=0, column=0, columnspan=2, sticky="nw")
    toolbar_frame.config(padx=0, pady=0)  


# ***************** Launch Application ***************** #
    
def create_bindings(window):
       
    
    # ***************** Search Bindings ***************** #
    # Note: search_entry.bind("<Return>" will not result in persistant highlighting     

    # Clear search results with clear_find_results upon entering new text in widget
    search_entry.bind("<KeyRelease>", clear_find_results)
    # Keyboard shortcuts to Search without pressing a button
    search_entry.bind("<KeyRelease-Return>", lambda event: find_all())
    # Keyboard shortcut to clear Search Results
    search_entry.bind("<Escape>", clear_find_results)
    # Keyboard shortcut to close Search Bar 
    search_entry.bind("<KeyRelease-Escape>", toggle_search_bar)
    
    window.bind('<Control-F>', lambda event: toggle_search_bar())
    window.bind('<Control-f>', lambda event: toggle_search_bar()) 
    window.bind('<F3>', find_next)
    
def create_window():
    global linenumbers_canvas, text_widget, window

    # Create main window
    window = Tk()
    window.title("Text Editor")
    window.geometry("1200x690")
    window.resizable(True,True)

    window.grid_columnconfigure(1, weight=1)
    window.grid_rowconfigure(0, weight=0, minsize=0)
    window.grid_rowconfigure(1, weight=1, minsize=0)

    # Create line numbers canvas
    linenumbers_canvas = Canvas(window, width=40)   
    linenumbers_canvas.grid(row=1, column=0, sticky="NS")
    window.grid_rowconfigure(1, minsize=linenumbers_canvas.winfo_reqheight())    

    linenumbers_canvas.grid_propagate(False)
    linenumbers_canvas.configure(width=30)
    
    # Create text widget
    # text_widget = Text(window)
    text_widget = create_custom_text(window, linenumbers_canvas)   
    text_widget.insert("end", "Type some text here...")

    # Test text for the purposes of debugging
    text.insert("end", "one\ntwo\nthree\n")
    text.insert("end", "four\n", ("bigfont",))
    text.insert("end", "five\nsecond two\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n")
    text.insert("end", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nthree two")
    text.insert("end", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfour two")
    text.insert("end", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfive two")
    text.tag_configure("bigfont", font=("Helvetica", "24", "bold")) 



    # Create the search bar
    create_search_bar(window)

    # Create the status bar
    create_status_bar(window)

    # Create the drop-down menu
    create_menu(window)
    
    create_toolbar(window) 

    # Call toggle_linenumbers() with the linenumbers_canvas as an argument
    toggle_linenumbers()

    # Create the status bar by default
    toggle_status_bar()

    create_bindings(window)

    # Start the main event loop
    window.mainloop()

if __name__ == "__main__":
    create_window()

