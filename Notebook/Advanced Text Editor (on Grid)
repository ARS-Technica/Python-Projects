# -*- coding: utf-8 -*-
"""
Simple Text Editor

Expanded version of the Codemy Tutorial:
https://www.youtube.com/watch?v=UlQRXJWUNBA 

Rebuilding Simple Text Editor from the skeleton of a working 
Line Numbering function to build the application to use the grid geometry manager
to create two columns: one for the line numbers and one for the text widget. 

Note:
You can't mix grid and pack on the same parent widget. You'll need to decide on
one and use it consistently for all child widgets.  To fix the error, you need
to choose to either use grid or pack for all the widgets inside the parent widget.

Changelog: Wrestling all widgets onto a grid system.
When this application is maximized, toggling line numbering off and back on again, the space between the toolbar and the text widget changes. 

To fix the issue with the space between the toolbar and the text widget changing, I'm making the following changes:

1. Replace the grid geometry manager with the pack geometry manager for the linenumbers_canvas widget.
2. Add the fill and side options to the pack method for linenumbers_canvas.
3. Add a sticky option with the value "nsew" to the text widget.
"""


import os, sys 
from tkinter import *
from tkinter import filedialog
from tkinter import font
from tkinter import messagebox
from tkinter import colorchooser 
import tkinter.ttk as ttk   
import win32print
import win32api

def create_text_line_numbers(canvas, text_widget):
    def redraw(*args):
        canvas.delete("all")

        i = text_widget.index("@0,0")
        while True:
            dline = text_widget.dlineinfo(i)
            if dline is None:
                break
            y = dline[1]
            linenum = str(i).split(".")[0]
            canvas.create_text(2, y, anchor="nw", text=linenum)
            i = text_widget.index("%s+1line" % i)

    return redraw

def create_custom_text(root, scrollbar, linenumbers_canvas):
    text_editor_frame = Frame(root)
    text = Text(root)
    
    def proxy(*args):
        cmd = (text._orig,) + args
        result = text.tk.call(cmd)

        if (
            args[0] in ("insert", "replace", "delete")
            or args[0:3] == ("mark", "set", "insert")
            or args[0:2] == ("xview", "moveto")
            or args[0:2] == ("xview", "scroll")
            or args[0:2] == ("yview", "moveto")
            or args[0:2] == ("yview", "scroll")
        ):
            text.event_generate("<<Change>>", when="tail")

        return result
 
    text._orig = text._w + "_orig"
    text.tk.call("rename", text._w, text._orig)
    text.tk.createcommand(text._w, proxy)
    vertical_scrollbar = Scrollbar(text_editor_frame, orient="vertical", command=text.yview)
    vertical_scrollbar.grid(row=2, column=2, sticky="ns")    
    horizontal_scrollbar = Scrollbar(root, orient="horizontal", command=text.xview)
    horizontal_scrollbar.grid(row=3, column=1, sticky="ew")
    
    text.configure(width=97, height=25, font=("Helvetica", 16),
               yscrollcommand=vertical_scrollbar.set, xscrollcommand=horizontal_scrollbar.set,
               selectbackground="yellow", selectforeground="black", undo=True,
               padx=5, pady=5, wrap="none")    

    root.grid_rowconfigure(1, weight=1)
    root.grid_columnconfigure(1, weight=1)
 
    text.grid(row=1, column=1, sticky="nsew")
    
    text_editor_frame.grid_rowconfigure(1, weight=1)
    text_editor_frame.grid_columnconfigure(1, weight=1)
    text_editor_frame.grid(row=1, column=1, sticky="nsew")    

    text.bind("<<Change>>", create_text_line_numbers(linenumbers_canvas, text))
    text.bind("<<Modified>>", create_text_line_numbers(linenumbers_canvas, text))
    text.bind("<Configure>", create_text_line_numbers(linenumbers_canvas, text))

    return text
           
def toggle_linenumbers():
    if linenumbers_button_var.get():
        linenumbers_canvas.grid(row=1, column=0, sticky="NS")
        root.grid_rowconfigure(0, weight=0, minsize=0)
        root.grid_rowconfigure(1, weight=1, minsize=0)
    else:
        linenumbers_canvas.grid_forget()
        root.grid_rowconfigure(0, weight=1)
        root.grid_rowconfigure(1, weight=0, minsize=0)            
            
def toggle_status_bar():
    global status_bar
    if statusbar_is_on.get() == 1:
        # ON
        status_bar = ttk.Frame(root)
        status_bar.grid(row=4, column=1, sticky="WE", pady=0)

        test_label = ttk.Label(status_bar, text="STATUS BAR")
        test_label.grid(row=1, column=1, sticky="WE")
    else:
        # OFF
        status_bar.destroy()
 
def create_menu():
    # Create the menu bar
    menubar = Menu(root)
    root.config(menu=menubar)

    # Add File Menu heading to the menubar
    file_menu = Menu(menubar, tearoff=False)
    menubar.add_cascade(label="File", menu=file_menu)

    # Add Edit Menu heading to the menubar
    edit_menu = Menu(menubar, tearoff=False)
    menubar.add_cascade(label="Edit", menu=edit_menu)

    # Add Search Menu heading to the menubar
    search_menu = Menu(menubar, tearoff=False)
    menubar.add_cascade(label="Search", menu=search_menu)

    # Add Format Menu heading to the menubar
    format_menu = Menu(menubar, tearoff=False)
    menubar.add_cascade(label="Format", menu=format_menu)

    # Add Tools Menu heading to the menubar
    tools_menu = Menu(menubar, tearoff=False)
    menubar.add_cascade(label="Tools", menu=tools_menu)

    # Add Options Menu heading to the menubar
    options_menu = Menu(menubar, tearoff=False)
    menubar.add_cascade(label="Options", menu=options_menu)

    # Toggle line numbering on and off
    global linenumbers_button_var
    linenumbers_button_var = BooleanVar(value=True)  # Line numbering is on by default

    options_menu.add_checkbutton(
        label="Show Line Numbers",
        variable=linenumbers_button_var,
        onvalue=True,
        offvalue=False,
        command=toggle_linenumbers,)    

    global statusbar_is_on
    statusbar_is_on = BooleanVar(value=True)  # Line numbering is on by default

    options_menu.add_checkbutton(
        label="Status Bar",
        onvalue=1,
        offvalue=0,
        variable=statusbar_is_on, 
        command=toggle_status_bar)

def create_toolbar():
    toolbar_frame = Frame(root, bd=5, highlightthicknes=0)

    bold_button = Button(toolbar_frame, text="Bold")
    bold_button.grid(row=0, column=0, padx=2, pady=0)

    italic_button = Button(toolbar_frame, text="Italic")
    italic_button.grid(row=0, column=1, padx=2, pady=0)

    underline_button = Button(toolbar_frame, text="Underline")
    underline_button.grid(row=0, column=2, padx=2, pady=0)

    toolbar_frame.grid(row=0, column=0, columnspan=2, sticky="nw")
    toolbar_frame.config(padx=0, pady=0)  

def create_window():
    global root, scrollbar, linenumbers_canvas, text_widget, status_bar #my_frame, text_frame
    
    # Create the main window
    root = Tk()
    root.rowconfigure(1, weight=1)
    root.title("Text Editor")
    root.geometry("1200x690")
    root.resizable(True,True)

    # Create a vertical scrollbar for the linenumbers_canvas
    scrollbar = Scrollbar(root)   
    # linenumbers_canvas.grid(row=0, column=0, sticky="nsew")
    scrollbar.grid(row=1, column=2, rowspan=2, sticky="ns")

    # Create canvas to hold line numbers
    linenumbers_canvas = Canvas(root)
    
    linenumbers_canvas.grid(row=1, column=0, sticky="NS")
    root.grid_rowconfigure(1, minsize=linenumbers_canvas.winfo_reqheight())    
    
    linenumbers_canvas.grid_propagate(False)
    linenumbers_canvas.configure(width=30)
    
    # Create text_widget passing the root, scrollbar, and linenumbers_canvas as arguments.
    text_widget = create_custom_text(root, scrollbar, linenumbers_canvas)   
    text_widget.insert("end", "Type some text here...")

    # Test text for the purposes of debugging
    text_widget.insert("end", "one\ntwo\nthree\n")
    text_widget.insert("end", "four\n", ("bigfont",))
    text_widget.insert("end", "five\n")
    text_widget.tag_configure("bigfont", font=("Helvetica", "24", "bold")) 

    # Create the menubar    
    create_menu()
    create_toolbar()   

    statusbar_is_on.set(1)
    toggle_status_bar()

    # Starts the main event loop of the tkinter application
    root.mainloop()

if __name__ == "__main__":
    create_window()
