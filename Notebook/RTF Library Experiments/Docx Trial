"""
A simple Textpad clone that works with .docx files.
"""

import os
import tkinter as tk
from tkinter import filedialog, scrolledtext, messagebox, simpledialog
from docx import Document
from pyth.plugins.plaintext.writer import PlaintextWriter
from pyth.plugins.rtf15.reader import Rtf15Reader
from pyth.plugins.plaintext.writer import RtfWriter
from pyth.errors import WrongFileType
from reportlab.pdfgen import canvas

def create_empty_document(doc_type=".docx"):
    current_directory = os.getcwd()
    document_path = os.path.join(current_directory, "empty_document" + doc_type)

    if doc_type == ".docx":
        # Create an empty Word document
        document = Document()
        document.add_paragraph("This is the initial content.")
        document.save(document_path)
    elif doc_type == ".rtf":
        # Create an empty RTF document
        with open(document_path, "w", encoding="utf-8") as rtf_file:
            rtf_file.write("{\\rtf1\\ansi\\pard This is the initial content.\\par}")
    elif doc_type == ".txt":
        # Create an empty text document
        with open(document_path, "w", encoding="utf-8") as txt_file:
            txt_file.write("This is the initial content.")
    
    return document_path

def open_and_display_document(file_path, text_widget):
    _, file_extension = os.path.splitext(file_path)

    if file_extension.lower() == ".docx":
        open_and_display_docx(file_path, text_widget)
    elif file_extension.lower() == ".rtf":
        open_and_display_rtf(file_path, text_widget)
    elif file_extension.lower() == ".txt":
        open_and_display_txt(file_path, text_widget)

def open_and_display_docx(docx_path, text_widget):
    # Open the selected .docx document
    document = Document(docx_path)

    # Extract text content from the document
    document_text = ""
    for paragraph in document.paragraphs:
        document_text += paragraph.text + "\n"

    # Display the text content in the text widget
    text_widget.delete("1.0", tk.END)
    text_widget.insert(tk.END, document_text)

def open_and_display_rtf(rtf_path, text_widget):
    try:
        # Open the selected .rtf document
        with open(rtf_path, "rb") as rtf_file:
            doc = Rtf15Reader.read(rtf_file)

        # Extract text content from the RTF document
        document_text = PlaintextWriter.write(doc).getvalue()

        # Display the RTF content in the text widget
        text_widget.delete("1.0", tk.END)
        text_widget.insert(tk.END, document_text)
    except WrongFileType:
        # Handle the case where the file is not recognized as an RTF file
        text_widget.delete("1.0", tk.END)
        text_widget.insert(tk.END, "Error: Not a valid RTF file.")

def open_and_display_txt(txt_path, text_widget):
    # Open the selected .txt document
    with open(txt_path, "r", encoding="utf-8") as txt_file:
        txt_content = txt_file.read()

    # Display the text content in the text widget
    text_widget.delete("1.0", tk.END)
    text_widget.insert(tk.END, txt_content)

def open_file_menu(text_widget):
    file_path = ask_open_filename()
    if file_path:
        open_and_display_document(file_path, text_widget)

def save_as_rtf_menu(text_widget):
    file_path = ask_save_filename(".rtf")
    if file_path:
        with open(file_path, "w", encoding="utf-8") as rtf_file:
            rtf_file.write(text_widget.get("1.0", tk.END))

def convert_txt_to_rtf_menu(text_widget):
    txt_content = text_widget.get("1.0", tk.END)
    rtf_content = RtfWriter.write(PlaintextWriter.read(txt_content)).getvalue()

    file_path = ask_save_filename(".rtf")
    if file_path:
        with open(file_path, "w", encoding="utf-8") as rtf_file:
            rtf_file.write(rtf_content)

def export_as_pdf_menu(text_widget):
    pdf_file_path = ask_save_filename(".pdf")
    if pdf_file_path:
        export_to_pdf(text_widget, pdf_file_path)

def export_to_pdf(text_widget, pdf_file_path):
    try:
        # Create a PDF document using reportlab
        pdf_canvas = canvas.Canvas(pdf_file_path)
        pdf_canvas.setFont("Helvetica", 12)

        text_content = text_widget.get("1.0", tk.END)
        lines = text_content.split("\n")

        # Write each line to the PDF canvas
        y_position = 750
        for line in lines:
            pdf_canvas.drawString(50, y_position, line)
            y_position -= 12  # Adjust for the line height

        pdf_canvas.save()
        messagebox.showinfo("Info", "Export to PDF successful.")
    except Exception as e:
        messagebox.showerror("Error", f"Error exporting to PDF: {e}")

def ask_open_filename():
    file_path = filedialog.askopenfilename(filetypes=[("Word Documents", "*.docx"), ("RTF Documents", "*.rtf"), ("Text Documents", "*.txt")])
    return file_path

def ask_save_filename(default_extension=".txt"):
    file_path = filedialog.asksaveasfilename(defaultextension=default_extension, filetypes=[("RTF Documents", "*.rtf"), ("PDF Documents", "*.pdf")])
    return file_path

def make_bold(text_widget):
    add_tags_to_selected_text(text_widget, "bold")

def make_italic(text_widget):
    add_tags_to_selected_text(text_widget, "italic")

def make_underline(text_widget):
    add_tags_to_selected_text(text_widget, "underline")

def cut_text(text_widget):
    selected_text = text_widget.get(tk.SEL_FIRST, tk.SEL_LAST)
    text_widget.delete(tk.SEL_FIRST, tk.SEL_LAST)
    tk.Tk().clipboard_clear()
    tk.Tk().clipboard_append(selected_text)

def copy_text(text_widget):
    selected_text = text_widget.get(tk.SEL_FIRST, tk.SEL_LAST)
    tk.Tk().clipboard_clear()
    tk.Tk().clipboard_append(selected_text)

def paste_text(text_widget):
    pasted_text = tk.Tk().clipboard_get()
    text_widget.insert(tk.INSERT, pasted_text)

def delete_text(text_widget):
    text_widget.delete(tk.SEL_FIRST, tk.SEL_LAST)

def add_tags_to_selected_text(text_widget, tag_name):
    try:
        current_tags = text_widget.tag_names(tk.SEL_FIRST)
        if tag_name in current_tags:
            text_widget.tag_remove(tag_name, tk.SEL_FIRST, tk.SEL_LAST)
        else:
            text_widget.tag_add(tag_name, tk.SEL_FIRST, tk.SEL_LAST)
    except tk.TclError:
        messagebox.showinfo("Info", "No text selected.")

def find_text(text_widget):
    query = simpledialog.askstring("Find", "Enter text to find:")
    if query:
        search_text(text_widget, query)

def search_text(text_widget, query):
    content = text_widget.get("1.0", tk.END)
    start_index = content.lower().find(query.lower())

    if start_index != -1:
        end_index = start_index + len(query)
        text_widget.tag_add(tk.SEL, f"1.0+{start_index}c", f"1.0+{end_index}c")
        text_widget.mark_set(tk.INSERT, f"1.0+{start_index}c")
        text_widget.see(tk.INSERT)
    else:
        messagebox.showinfo("Info", f"Text '{query}' not found.")

def main():
    root = tk.Tk()
    root.title("Text Editor")
    root.geometry("800x600")

    text_widget = scrolledtext.ScrolledText(root, wrap="word", font=("Arial", 12))
    text_widget.pack(expand=True, fill="both")

    create_empty_document(".docx")  # Create an initial .docx document

    menu_bar = tk.Menu(root)
    root.config(menu=menu_bar)

    file_menu = tk.Menu(menu_bar, tearoff=0)
    menu_bar.add_cascade(label="File", menu=file_menu)
    file_menu.add_command(label="Open File", command=lambda: open_file_menu(text_widget))
    file_menu.add_command(label="Save as RTF", command=lambda: save_as_rtf_menu(text_widget))
    file_menu.add_command(label="Convert TXT to RTF", command=lambda: convert_txt_to_rtf_menu(text_widget))
    file_menu.add_command(label="Export as PDF", command=lambda: export_as_pdf_menu(text_widget))

    edit_menu = tk.Menu(menu_bar, tearoff=0)
    menu_bar.add_cascade(label="Edit", menu=edit_menu)
    edit_menu.add_command(label="Cut", command=lambda: cut_text(text_widget))
    edit_menu.add_command(label="Copy", command=lambda: copy_text(text_widget))
    edit_menu.add_command(label="Paste", command=lambda: paste_text(text_widget))
    edit_menu.add_command(label="Delete", command=lambda: delete_text(text_widget))

    search_menu = tk.Menu(menu_bar, tearoff=0)
    menu_bar.add_cascade(label="Search", menu=search_menu)
    search_menu.add_command(label="Find", command=lambda: find_text(text_widget))

    toolbar = tk.Frame(root, bd=1, relief=tk.RAISED)

    bold_button = tk.Button(toolbar, text="Bold", command=lambda: make_bold(text_widget))
    bold_button.grid(row=0, column=0, padx=5)

    italic_button = tk.Button(toolbar, text="Italic", command=lambda: make_italic(text_widget))
    italic_button.grid(row=0, column=1, padx=5)

    underline_button = tk.Button(toolbar, text="Underline", command=lambda: make_underline(text_widget))
    underline_button.grid(row=0, column=2, padx=5)

    toolbar.pack(side=tk.TOP, fill=tk.X)

    root.mainloop()

if __name__ == "__main__":
    main()

