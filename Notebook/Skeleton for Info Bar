"""
I have now successfully added an Info Bar  to the existing Status Bar of my Notebook
project.  The Info Bar now displays the current position of the cursor on the text 
widget in the format: Line: 1 | Column: 0.  (See previous updates of this Github repo)

I am now refining the interaction between the Search and Replace user interfaces. 
"""


# Refactoring Search Functions for efficiency (find_all find_next find_previous)
# Next Issue: find_all no long highlights all results on the text widget


import os, sys
from tkinter import *
from tkinter import colorchooser, filedialog, font, messagebox, simpledialog
import tkinter.ttk as ttk
import win32print
import win32api


main_color = "SystemButtonFace"
second_color = "White"
selection_highlight = "#999999"
text_color = "black"
line_highlight = "yellow"


def create_toolbar():
    # Create a placeholder for the toolbar
    toolbar_placeholder = Frame(window, height=30, bg='lightgrey')
    toolbar_placeholder.grid(row=0, column=0, columnspan=2, sticky='we')
    Label(toolbar_placeholder, text="Toolbar Placeholder").pack(side=LEFT, padx=10, pady=5)


def create_linenumbers_canvas():
    global linenumbers_canvas

    # Initialize the canvas for line numbers
    linenumbers_canvas = Canvas(window, width=40, highlightthickness=0)                                                                                   
    linenumbers_canvas.grid(row=1, column=0, sticky="NS")
    
    # Ensure row is properly configured for resizing after canvas is created
    window.grid_rowconfigure(1, minsize=linenumbers_canvas.winfo_reqheight())    
    linenumbers_canvas.grid_propagate(False)
    linenumbers_canvas.configure(width=30)


def create_text_line_numbers(canvas, text, text_color):
    def redraw(*args):
        canvas.delete("all")
        i = text_widget.index("@0,0")
        while True:
            dline = text_widget.dlineinfo(i)
            if dline is None:
                break
            y = dline[1]
            linenum = str(i).split(".")[0]
            canvas.create_text(2, y, anchor="nw", text=linenum, fill=text_color)
            i = text_widget.index("%s+1line" % i)
    redraw()
    text.bind("<<Change>>", redraw)
    text.bind("<<Modified>>", redraw)
    text.bind("<Configure>", redraw)

    return redraw


def toggle_linenumbers():
    """
    Toggles the visibility of the canvas for line numbers, depending on the
    state of the linenumbers_button_var variable.
    """
    if linenumbers_button_var.get():
        linenumbers_canvas.grid(row=1, column=0, sticky="NS")
        window.grid_rowconfigure(0, weight=0, minsize=0)
        window.grid_rowconfigure(1, weight=1, minsize=0)
    else:
        linenumbers_canvas.grid_forget()


def create_text_widget(window, linenumbers_canvas):
    global text_widget

    # Create the text widget with a vertical scrollbar
    text_editor_frame = Frame(window)
    text_widget = Text(text_editor_frame, font=("Helvetica", 16), selectbackground=line_highlight,
                selectforeground="black", undo=True, padx=5, pady=5, wrap="none")

    def proxy(*args):
        cmd = (text_widget._orig,) + args
        result = text_widget.tk.call(cmd)

        if (
            args[0] in ("insert", "replace", "delete")
            or args[0:3] == ("mark", "set", "insert")
            or args[0:2] == ("xview", "moveto")
            or args[0:2] == ("xview", "scroll")
            or args[0:2] == ("yview", "moveto")
            or args[0:2] == ("yview", "scroll")
        ):
            text_widget.event_generate("<<Change>>", when="tail")

        return result

    text_widget._orig = text_widget._w + "_orig"
    text_widget.tk.call("rename", text_widget._w, text_widget._orig)
    text_widget.tk.createcommand(text_widget._w, proxy)
    
    vertical_scrollbar = Scrollbar(text_editor_frame, orient="vertical", command=text_widget.yview)
    text_widget.configure(yscrollcommand=vertical_scrollbar.set)
    
    horizontal_scrollbar = Scrollbar(text_editor_frame, orient="horizontal", command=text_widget.xview)
    text_widget.configure(xscrollcommand=horizontal_scrollbar.set)
    
    text_widget.grid(row=0, column=0, columnspan=2, sticky="nsew")
    vertical_scrollbar.grid(row=0, column=1, sticky="ns")
    horizontal_scrollbar.grid(row=1, column=0, sticky="ew")
    
    text_editor_frame.grid_rowconfigure(0, weight=1)
    text_editor_frame.grid_columnconfigure(0, weight=1)
    text_editor_frame.grid(row=1, column=1, sticky="nsew", padx=2, pady=2)
    
    window.grid_rowconfigure(0, weight=0)
    window.grid_rowconfigure(1, weight=1)
    window.grid_columnconfigure(0, weight=0)
    window.grid_columnconfigure(1, weight=1)
    
    # Bind text widget events for redrawing line numbers
    text_widget.bind("<<Change>>", lambda event: create_text_line_numbers(linenumbers_canvas, text_widget, text_color))
    text_widget.bind("<<Modified>>", lambda event: create_text_line_numbers(linenumbers_canvas, text_widget, text_color))
    text_widget.bind("<Configure>", lambda event: create_text_line_numbers(linenumbers_canvas, text_widget, text_color))

    return text_widget


def create_menu():
    """
    Function to define and return the menu bar.
    """
    global info_bar_var, linenumbers_button_var, search_bar_var, status_bar_var

    # Define the variables associated with the checkbuttons
    info_bar_var = IntVar(value=1)    # Set to 1 to make Info Bar checked by default
    linenumbers_button_var = BooleanVar(value=1)    # Set to 1 to make Line Numbers checked by default
    search_bar_var = IntVar()
    status_bar_var = IntVar(value=1)  # Set to 1 to make Status Bar checked by default

    # Create the menu bar
    menu_bar = Menu(window)
    window.config(menu=menu_bar)

    # Options menu
    options_menu = Menu(menu_bar, tearoff=0)
    menu_bar.add_cascade(label="Options", menu=options_menu)

    # Add checkbuttons to the Options menu
    options_menu.add_checkbutton(label="Show Line Numbers", variable=linenumbers_button_var, command=toggle_linenumbers)    
    options_menu.add_separator()
    options_menu.add_checkbutton(label="Info Bar", variable=info_bar_var, command=toggle_info_bar)    
    options_menu.add_checkbutton(label="Search Bar", variable=search_bar_var, command=toggle_search_bar, accelerator="(Ctl+F)")
    options_menu.add_checkbutton(label="Status Bar", variable=status_bar_var, command=toggle_status_bar)


def find():
    # Placeholder for Search Functions
    update_search_counter()


def update_position_indicator(event=None):
    # Update the info_bar_label with the current cursor position.
    global info_bar_label

    current_line, current_column = text_widget.index("insert").split('.')
    info_bar_label.config(text=f'Line: {current_line} | Column: {current_column}')


def update_search_position(find_position, find_count): # For use with Find_Next / Find_Previous functions
    # Updates the label on the Search Bar with a running count of position in Search Results

    # Update the search_counter_label with the number of search results.
    global search_counter_label

    #find_result = "0" # Placeholder for actual result count
    search_counter_label.config(text=f'Result: {find_position} of {find_count}') 




def update_search_counter(find_count):  # For use with Find_All function
    # Updates the label on the Search Bar with the total number of Search Results.

    # Update the search_counter_label with the total number of search results.
    global search_counter_label

    #find_result = "0" # Placeholder for actual result count
    search_counter_label.config(text=f'Result: {find_count}') 


# Create the Search Counter Bar to display "Count: 0"
def create_search_counter_bar():
    global search_counter_bar, search_counter_label

    # Create a frame for the counter bar.
    search_counter_bar = Frame(window, relief="flat", bd=0, background=main_color)
    
    # Create a label for the search count (Counter Bar).
    search_counter_label = Label(search_counter_bar, text=" ", bg=main_color, fg=text_color) # Blank by default
    
    # Place the counter label inside the counter bar frame.
    search_counter_label.grid(row=0, column=0, sticky="e", padx=(5, 5))


def create_info_bar():
    global info_bar, info_bar_label

    # Create a frame for the info bar.
    info_bar = Frame(window, relief="flat", bd=0, background=main_color)
    
    # Create a label for the cursor position (Info Bar).
    info_bar_label = Label(info_bar, text="Line: 1 | Column: 0", bg=main_color, fg=text_color)
    
    # Place the info label inside the info bar frame.
    info_bar_label.grid(row=0, column=0, sticky="e", padx=(5, 5))
    

def create_search_bar():   
    def on_exit(event):
        event.widget['background'] = main_color #second_color #text_color
        event.widget['foreground'] = text_color #second_color         

    def on_enter(event):
        event.widget['background'] = text_color #second_color
        event.widget['foreground'] = main_color #second_color #text_color
    
    # ***************** Search Bar Widget ***************** #
    # Can't use grid and pack geometry managers on widgets that share the same parent.

    # Create Search Bar Frame to position buttons on
    global search_bar						
    search_bar = Frame(window, relief="flat", bd=0, padx=0, pady=0)
    search_bar.grid(row=3, column=1, sticky="ew", pady=0)
    search_bar.grid_remove()  # Hide search bar initially

    # Start with a pair of frames to provide horizontal padding to buttons

    global search_bar_left_frame
    # Contains search_label, search_entry, search_next_button, search_prev_button, clear_search_button
    search_bar_left_frame = Frame(search_bar, bg=main_color)
    search_bar_left_frame.configure(bg=main_color)
    search_bar_left_frame.grid(row=0, column=0, padx=0, pady=0, sticky="w")
																							
    global search_bar_right_frame
    # Contains search_all_button
    search_bar_right_frame = Frame(search_bar, bg=main_color)
    search_bar_right_frame.configure(bg=main_color)
    search_bar_right_frame.grid(row=0, column=1, padx=15, pady=0, sticky="w")

    global search_label								
    search_label = Label(search_bar_left_frame, text="Search:", fg=text_color, bg=main_color)														 
    search_label.grid(row=0, column=0, padx=5, pady=0, sticky="w") # padx5 to align with status_label

    # Creating an Entry widget for user to input search term
    global search_entry    
    search_entry = Entry(search_bar_left_frame)
    search_entry.grid(row=0, column=1, padx=5, pady=0, sticky="w") # pady=0 to align with status_label


    # Creating a Button widgets to initiate the search and highlighting

    # Search down the text widget from the top
    search_next_button = Button(search_bar_left_frame, text="Find Next", font=("Helvetica", 10), 
                            bd=0, padx=5, pady=5, command=find_next, relief="flat", borderwidth=0)
    search_next_button.grid(row=0, column=2, padx=5, pady=0, sticky="w")
    search_next_button.bind("<Enter>", on_enter)
    search_next_button.bind("<Leave>", on_exit)

    # Search up the text widget from the bottom
    search_prev_button = Button(search_bar_left_frame, text="Find Prev", font=("Helvetica", 10), 
                            bd=0, padx=5, pady=5, command=find_previous, relief="flat", borderwidth=0)
    search_prev_button.grid(row=0, column=3, padx=5, pady=0, sticky="w")
    search_prev_button.bind("<Enter>", on_enter)
    search_prev_button.bind("<Leave>", on_exit)

    # Clear search result highlighting from text widget
    clear_search_button = Button(search_bar_left_frame, text="Clear Search", font=("Helvetica", 10),
                                 bd=0, padx=5, pady=0, command=clear_find_results, relief="flat", borderwidth=0)
    clear_search_button.grid(row=0, column=4, padx=2, pady=0, sticky="w")
    clear_search_button.bind("<Enter>", on_enter)
    clear_search_button.bind("<Leave>", on_exit)

    # Search the entire contents of the text widget
    search_all_button = Button(search_bar_left_frame, text="Find All", font=("Helvetica", 10), 
                               bd=0, padx=5, pady=0, command=find_all, relief="flat", borderwidth=0)
    search_all_button.grid(row=0, column=6, padx=2, pady=0, sticky="w")
    search_all_button.bind("<Enter>", on_enter)
    search_all_button.bind("<Leave>", on_exit)


    search_bar_left_frame.grid_columnconfigure(2, weight=1)
    search_bar_right_frame.grid_columnconfigure(0, weight=1)


    # Initializing the search_positions list and current_result_index variable
    search_positions = []
    current_result_index = -1


    # Place cursor in Search Entry text box when the Search becomes visible
    search_entry.focus_set()    # Set focus to search entry widget


status_bar_message = "Status Bar Message"


def create_status_bar():
    global status_bar, status_label

    # Create a frame for the status bar.
    status_bar = Frame(window, relief="flat", bd=0, background=main_color)
    
    # Create a label for the status bar message.
    status_label = Label(status_bar, text=status_bar_message, bg=main_color, fg=text_color)
    
    # Place the status label inside the status bar frame, aligning it to the right.
    status_label.grid(row=0, column=0, sticky="e", padx=(0, 20), pady=0)

    # Position the status bar frame in the grid.
    status_bar.grid(row=3, column=1, sticky="we", padx=(5, 20), pady=0)


def update_bottom_bar():
    # Handle Search Bar visibility first.
    if search_bar_var.get():
        search_counter_bar.grid(row=3, column=1, sticky="e", padx=(5, 20), pady=15)        
        search_bar.grid(row=3, column=1, sticky='we', padx=0, pady=10)
        
        # Hide Info Bar and Status Bar when Search Bar is visible.
        info_bar.grid_forget()
        status_bar.grid_forget()        
    else:
        # Hide Search Bar if search_bar_var is not set.
        search_counter_bar.grid_forget()
        search_bar.grid_forget()

        # Handle Info Bar visibility independently.
        if info_bar_var.get():
            info_bar.grid(row=3, column=1, sticky='e', padx=(5, 20), pady=15)
        else:
            info_bar.grid_forget()

        # Handle Status Bar visibility independently.
        if status_bar_var.get():
            status_bar.grid(row=3, column=1, sticky='we', padx=(5, 20), pady=15)
        else:
            status_bar.grid_forget()

    # If none of the bars are toggled on...
    if not (info_bar_var.get() or search_bar_var.get() or status_bar_var.get()):
        # Create a persistent bottom bar that is always visible with minimal padding
        search_counter_bar.grid_forget()
        info_bar.grid_forget()
        search_bar.grid_forget()
        status_bar.grid_forget()
        
        persistent_bottom_bar = Frame(window, relief="flat", bd=0, padx=0, pady=5) # Just 5px high
        # Text label for the bottom bar purely for debugging purposes
        # persistent_bottom_label = Label(persistent_bottom_bar, text="Bottom Bar", bg=main_color, fg=text_color)
        # persistent_bottom_label.grid(row=0, column=0, sticky="e", padx=(5, 20))
        persistent_bottom_bar.grid(row=3, column=1, padx=0, pady=5)  # Make sure the bar is always visible


def toggle_info_bar():
    """
    Function to update checkbuttons when Info Bar is toggled.
    Called from create_menu Function.
    """
    if info_bar_var.get():
        # Uncheck Search Bar if Info Bar is checked
        search_bar_var.set(0)

    update_bottom_bar()


def toggle_search_bar(event=None):
    """
    This function toggles the Search Bar and its Counter using either with the 
    Control-F keybinding or the checkbutton in the menu.
    It ensures that the state of the checkbutton (search_bar_var) is in sync with the UI.
    """
    
    """
    When I call the toggle_search_bar function, I want to remember if either 
    the Status Bar or the Info Bar were visible.  When I toggle the Search Bar 
    off, I want to restore the Status Bar if it was visible and I want to 
    restore the Info Bar if it was visible.
    """

    # Store the state of the Info Bar and Status Bar before the Search Bar is toggled. 
    # Allows user to restore their previous states when the Search Bar is hidden.
    global was_info_bar_visible, was_status_bar_visible

    # Toggle the Search Bar state (triggered by either keybinding or checkbutton)
    
    # Check the State of search_bar_var
    if search_bar_var.get():  # If the checkbutton is checked (search bar should be visible)
    
        # True (checkbutton is checked, or keybinding is toggled) means the Search Bar should be shown.
        # False, it means the Search Bar should be hidden.
    
        # Remember the current state of Info Bar and Status 
        was_info_bar_visible = info_bar_var.get()
        was_status_bar_visible = status_bar_var.get()

        # Hide Status Bar and Info Bar
        info_bar_var.set(0)
        status_bar_var.set(0)

        # Show the Search Bar
        search_bar.grid(row=3, column=1, sticky='we', padx=0, pady=10)  # pady=10 to compensate for buttons
        search_counter_bar.grid(row=3, column=1, sticky="e", padx=(0, 20), pady=0)  # Show Counter Bar
    else:
        # Hide the Search Bar and Counter Bar
        search_counter_bar.grid_forget()
        search_bar.grid_forget()

        # Restore the previous state of Info Bar and Status Bar
        info_bar_var.set(was_info_bar_visible)
        status_bar_var.set(was_status_bar_visible)

    # Update bars to reflect changes
    update_bottom_bar()


def toggle_status_bar():
    """
    Function to update checkbuttons when Status Bar is toggled.
    Called from create_menu Function.
    """
    if status_bar_var.get():
        # Uncheck Search Bar if Status Bar is checked
        search_bar_var.set(0)

    update_bottom_bar()


# ***************** Search Bar Functions

# Declare search_positions as an empty list before using it
# Used to avoid "NameError: name 'search_positions' is not defined" error
# search_positions = []
"""
A global list variable search_positions is declared as an empty list. 
It will be used to store the positions of search results in the text widget.
"""


# Don't call 'next_result()' if you want find_all to highlight all instances of a search term
def find_all(event=None):
    global search_positions, find_count, current_result_index  # Declare globals to update them

    search_text = search_entry.get()
    search_positions = []  # Reset the search positions
    find_count = 0  # Reset the count of search results
    current_result_index = -1  # Initialize the current result index to -1

    if search_text:
        start_pos = "1.0"
        while True:
            pos = text_widget.search(search_text, start_pos, stopindex="end")
            if not pos:
                break
            end_pos = f"{pos}+{len(search_text)}c"
            text_widget.tag_add("found", pos, end_pos)
            search_positions.append(pos)  # Store the search position
            start_pos = end_pos
            find_count += 1  # Increment the counter for each result found

        text_widget.tag_configure("found", background=line_highlight)

        # Update the search counter in the Search Bar
        update_search_counter(find_count)

        # Optionally, highlight the first result after find_all
        if search_positions:
            current_result_index = 0  # Start with the first result
            # next_result()  # Highlight the first result
            update_search_position(current_result_index + 1, find_count)  # Update the position indicator

    else:
        # If text hasn't been entered into the Entry widget:
        if search_bar.winfo_ismapped():
            messagebox.showerror("Search", "Please enter text before searching")
        else:
            toggle_search_bar()
            search_entry.focus_set()



"""

When I enter a search term, then press "Find Next," in find_next, 
the line "if not search_positions:" returns the error
"NameError: name 'search_positions' is not defined". 

"""


# Does not highlight search results when Find Next is used before Find All

def find_next(event=None):
    global current_result_index, search_positions, find_count  # Declare globals

    # Retrieve the search term from the search_entry widget
    search_text = search_entry.get()

    # Initialize search_positions if it hasn't been initialized before
    if 'search_positions' not in globals():
        search_positions = []

    if search_text:
        if not search_positions:  # If search hasn't been run yet, initialize the positions
            start_pos = "1.0"
            search_positions = []
            while True:
                pos = text_widget.search(search_text, start_pos, stopindex="end")
                if not pos:
                    break
                search_positions.append(pos)  # Store each occurrence
                start_pos = f"{pos}+{len(search_text)}c"
            find_count = len(search_positions)  # Total number of occurrences
            current_result_index = -1  # Reset the index to start from the first match

        # Move to the next result
        if search_positions:
            text_widget.tag_remove("found", "1.0", "end")  # Remove previous highlight

            if current_result_index < len(search_positions) - 1:
                current_result_index += 1
            else:
                current_result_index = 0  # Loop back to the first result if at the end

            # Highlight the current result
            result_pos = search_positions[current_result_index]
            end_pos = f"{result_pos}+{len(search_text)}c"
            text_widget.tag_add("found", result_pos, end_pos)  # Highlight only one result
            text_widget.see(result_pos)  # Scroll to the found text
            update_search_position(current_result_index + 1, find_count)  # Update the position in the results
        else:
            messagebox.showinfo("Search", "No matches found")
    else:
        messagebox.showerror("Search", "Please enter a search term")


# Define find_previous function
def find_previous(event=None):
    global current_result_index, search_positions, find_count

    if search_positions:
        # Move to the previous result
        if current_result_index > 0:
            current_result_index -= 1
        else:
            current_result_index = len(search_positions) - 1  # Loop back to the last result

        next_result()  # Highlight the result
        update_search_position(current_result_index + 1, find_count)  # Update the position indicator
    else:
        find_all()  # If no results are available, run find_all first
 

# Define next_result function first
def next_result(event=None):
    global current_result_index, search_positions

    if search_positions:
        # Clear previous highlights
        text_widget.tag_remove("found", "1.0", "end")

        # Get the position of the current search result
        result_pos = search_positions[current_result_index]
        end_pos = f"{result_pos}+{len(search_entry.get())}c"

        # Highlight the current search result
        text_widget.tag_add("found", result_pos, end_pos)

        # Move cursor to the search result and make sure it is visible
        text_widget.mark_set("insert", result_pos)
        text_widget.see(result_pos)

 
def clear_find_results(event=None):
    # Clear Find results to start over
    # "event=None" is the secret sauce that makes keybinding work!
    global current_result_index
    global search_positions

    # Check Current tags
    if "found" in text_widget.tag_names():
        # Remove results highlighting
        text_widget.tag_remove("found", "1.0", "end")
        # Reset global variables to default for new search
        search_positions = []
        current_result_index = -1

    # Clear search results with clear_find_results upon entering new text in widget
    # search_entry.bind("<KeyRelease>", clear_find_results)

    # Clear search_counter
    search_counter_label.config(text=" ")     
    # Clear text from search_entry (Text field on Search Bar)
    search_entry.delete(0, END)
    # Shift keyboard focus to search_entry (Text field on Search Bar)
    search_entry.focus_set()   


# ***************** /Search Bar Functions


def create_window():
    global window

    # Create the main window
    window = Tk()
    window.title("Simple Notepad with Toggleable Footer Bars")
    window.geometry("1200x690")
    window.resizable(True, True)
    
    # Configure row/column resizing
    window.grid_rowconfigure(1, weight=1)
    window.grid_columnconfigure(1, weight=1)

    # Create the interface components
    create_menu()
    create_toolbar()

    # Call the function to create the line numbers canvas
    create_linenumbers_canvas()
    # Create the text widget (After linenumbers_canvas is defined)
    create_text_widget(window, linenumbers_canvas)

    # Insert sample text for debugging purposes
    text_widget.insert("end", "Type some text here...")
    text_widget.insert("end", "one\ntwo\nthree\n")
    text_widget.insert("end", "four\n")
    text_widget.insert("end", "five\nsecond two\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n")
    
    create_search_bar()
    create_status_bar()
    create_info_bar() # Must be called AFTER create_status_bar to appear on launch
    create_search_counter_bar()

    # Ensure both Status Bar and Info Bar are visible at startup
    update_bottom_bar()

    # Bind events to update the cursor position in the info bar
    text_widget.bind("<KeyRelease>", update_position_indicator)
    text_widget.bind("<ButtonRelease>", update_position_indicator)
    
    # The single most difficult line of code in this project - DO NOT CHANGE:
  
    # Bind Control-F to toggle the Search Bar
    window.bind('<Control-f>', lambda event: search_bar_var.set(not search_bar_var.get()) or toggle_search_bar())
    """ This binding triggers the toggle behavior for the Control-F keybinding. 
    It inverts the state of search_bar_var (set(not search_bar_var.get())) and 
    then calls the toggle_search_bar() function to update the UI. """

    # Run the application
    window.mainloop()


if __name__ == "__main__":
    create_window()     # Run the event loop to keep the window active

