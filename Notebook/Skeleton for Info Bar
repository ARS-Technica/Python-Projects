"""
I have now successfully added an Info Bar  to the existing Status Bar of my Notebook
project.  The Info Bar now displays the current position of the cursor on the text 
widget in the format: Line: 1 | Column: 0.  (See previous updates of this Github repo)

I am now refining the interaction between the Search and Replace user interfaces. 
"""


# Expanded toggle_info_bar to toggle checkbuttons off when Info Bar is turned on/off
# Next Issue: Expand toggle_status_bar


# Next Issue: Break create_search_bar into create_search_bar and create_replace_bar
# Next Issue: Add variable typing
# Next Issue: Create an "Advanced Search" Panel that launches as a new Window
# Next Issue: Regular Expressions Search Option
# Next Issue: Launch Character Map from within Text Editor


import os, sys
from tkinter import *
from tkinter import colorchooser, filedialog, font, messagebox, simpledialog
import tkinter.ttk as ttk
import re  # Add this to import regular expressions for "Whole Words" search option
import win32print
import win32api


main_color = "SystemButtonFace"
second_color = "White"
selection_highlight = "#999999"
text_color = "black"
line_highlight = "yellow"


def create_toolbar():
    # Create a placeholder for the toolbar
    toolbar_placeholder = Frame(window, height=30, bg='lightgrey')
    toolbar_placeholder.grid(row=0, column=0, columnspan=2, sticky='we')
    Label(toolbar_placeholder, text="Toolbar Placeholder").pack(side=LEFT, padx=10, pady=5)


def create_linenumbers_canvas():
    global linenumbers_canvas

    # Initialize the canvas for line numbers
    linenumbers_canvas = Canvas(window, width=40, highlightthickness=0)                                                                                   
    linenumbers_canvas.grid(row=1, column=0, sticky="NS")
    
    # Ensure row is properly configured for resizing after canvas is created
    window.grid_rowconfigure(1, minsize=linenumbers_canvas.winfo_reqheight())    
    linenumbers_canvas.grid_propagate(False)
    linenumbers_canvas.configure(width=30)


def create_text_line_numbers(canvas, text, text_color):
    def redraw(*args):
        canvas.delete("all")
        i = text_widget.index("@0,0")
        while True:
            dline = text_widget.dlineinfo(i)
            if dline is None:
                break
            y = dline[1]
            linenum = str(i).split(".")[0]
            canvas.create_text(2, y, anchor="nw", text=linenum, fill=text_color)
            i = text_widget.index("%s+1line" % i)
    redraw()
    text.bind("<<Change>>", redraw)
    text.bind("<<Modified>>", redraw)
    text.bind("<Configure>", redraw)

    return redraw


def toggle_linenumbers():
    """
    Toggles the visibility of the canvas for line numbers, depending on the
    state of the linenumbers_button_var variable.
    """
    if linenumbers_button_var.get():
        linenumbers_canvas.grid(row=1, column=0, sticky="NS")
        window.grid_rowconfigure(0, weight=0, minsize=0)
        window.grid_rowconfigure(1, weight=1, minsize=0)
    else:
        linenumbers_canvas.grid_forget()


def create_text_widget(window, linenumbers_canvas):
    global text_widget

    # Create the text widget with a vertical scrollbar
    text_editor_frame = Frame(window)
    text_widget = Text(text_editor_frame, font=("Helvetica", 16), selectbackground=line_highlight,
                selectforeground="black", undo=True, padx=5, pady=5, wrap="none")

    def proxy(*args):
        cmd = (text_widget._orig,) + args
        result = text_widget.tk.call(cmd)

        if (
            args[0] in ("insert", "replace", "delete")
            or args[0:3] == ("mark", "set", "insert")
            or args[0:2] == ("xview", "moveto")
            or args[0:2] == ("xview", "scroll")
            or args[0:2] == ("yview", "moveto")
            or args[0:2] == ("yview", "scroll")
        ):
            text_widget.event_generate("<<Change>>", when="tail")

        return result

    text_widget._orig = text_widget._w + "_orig"
    text_widget.tk.call("rename", text_widget._w, text_widget._orig)
    text_widget.tk.createcommand(text_widget._w, proxy)
    
    vertical_scrollbar = Scrollbar(text_editor_frame, orient="vertical", command=text_widget.yview)
    text_widget.configure(yscrollcommand=vertical_scrollbar.set)
    
    horizontal_scrollbar = Scrollbar(text_editor_frame, orient="horizontal", command=text_widget.xview)
    text_widget.configure(xscrollcommand=horizontal_scrollbar.set)
    
    text_widget.grid(row=0, column=0, columnspan=2, sticky="nsew")
    vertical_scrollbar.grid(row=0, column=1, sticky="ns")
    horizontal_scrollbar.grid(row=1, column=0, sticky="ew")
    
    text_editor_frame.grid_rowconfigure(0, weight=1)
    text_editor_frame.grid_columnconfigure(0, weight=1)
    text_editor_frame.grid(row=1, column=1, sticky="nsew", padx=2, pady=2)
    
    window.grid_rowconfigure(0, weight=0)
    window.grid_rowconfigure(1, weight=1)
    window.grid_columnconfigure(0, weight=0)
    window.grid_columnconfigure(1, weight=1)
    
    # Bind text widget events for redrawing line numbers
    text_widget.bind("<<Change>>", lambda event: create_text_line_numbers(linenumbers_canvas, text_widget, text_color))
    text_widget.bind("<<Modified>>", lambda event: create_text_line_numbers(linenumbers_canvas, text_widget, text_color))
    text_widget.bind("<Configure>", lambda event: create_text_line_numbers(linenumbers_canvas, text_widget, text_color))

    return text_widget


def create_menu():
    global info_bar_var, linenumbers_button_var, search_bar_var, status_bar_var, replace_bar_var

    # Define the variables associated with the checkbuttons
    info_bar_var = IntVar(value=1)    # Set to 1 to make Info Bar checked by default
    linenumbers_button_var = BooleanVar(value=1)    # Set to 1 to make Line Numbers checked by default
    search_bar_var = IntVar()
    status_bar_var = IntVar(value=1)  # Set to 1 to make Status Bar checked by default
    replace_bar_var = IntVar(value=0) # Set to 0 to make Replace Bar hidden by default

    # Create the menu bar
    menu_bar = Menu(window)
    window.config(menu=menu_bar)

    # Options menu
    options_menu = Menu(menu_bar, tearoff=0)
    menu_bar.add_cascade(label="Options", menu=options_menu)

    # Add checkbuttons to the Options menu
    options_menu.add_checkbutton(label="Show Line Numbers", variable=linenumbers_button_var, command=toggle_linenumbers)
    options_menu.add_separator()
    options_menu.add_checkbutton(label="Info Bar", variable=info_bar_var, command=toggle_info_bar)
    options_menu.add_checkbutton(label="Search Bar", variable=search_bar_var, command=toggle_search_bar, accelerator="(Ctl+F)")
    options_menu.add_checkbutton(label="Status Bar", variable=status_bar_var, command=toggle_status_bar)

    # Search menu
    search_menu = Menu(menu_bar, tearoff=0)
    menu_bar.add_cascade(label="Search", menu=search_menu)
    
    # Add checkbuttons to the Search menu
    search_menu.add_checkbutton(label="Find Text", variable=search_bar_var, command=toggle_search_bar, accelerator="(Ctl+F)")
    search_menu.add_separator()
    search_menu.add_command(label="Find Next", command=lambda: find_direction(direction="next"), accelerator="(F3)")
    search_menu.add_command(label="Find Prev", command=lambda: find_direction(direction="previous"), accelerator="(Shift+F3)")
    search_menu.add_separator()
    search_menu.add_command(label="Clear Search Results", command=clear_find_results, accelerator="(Escape)")
    search_menu.add_separator()
    search_menu.add_checkbutton(label="Replace Text", variable=replace_bar_var, command=toggle_replace_bar, accelerator="(Ctrl+H)")


def update_cursor_position_indicator(event=None):
    # Update the info_bar_label with the current cursor position.
    global info_bar_label

    current_line, current_column = text_widget.index("insert").split('.')
    info_bar_label.config(text=f'Line: {current_line} | Column: {current_column}')


def update_search_counter(find_count, total_count):
    """
	Updates the search counter label on the Search Bar with a total count of 
    search results and the current index of the highlighted
    instance within those results to show remaining and total instances.
	"""
    if find_count == 0:
        window.bell()
        search_counter_label.config(text="No instances found.")  # No search results													
    else:															  
		# Display current position and total count (used for find_next, find_previous										
        search_counter_label.config(text=f'Remaining Instances: {find_count} of {total_count}')

																	  
def create_search_counter_bar():
    global search_counter_bar, search_counter_bottom_row, search_counter_label

    # Create a frame for the counter bar.
    search_counter_bar = Frame(window, relief="flat", bd=0, background=main_color)
    search_counter_bar.grid(row=3, column=1, sticky="e", padx=5, pady=0)  # Ensure it aligns properly in the main window

    # First row (Top): Contains the search_counter_label for search results
    search_counter_label = Label(search_counter_bar, text=" ", bg=main_color, fg=text_color)  # Blank by default
    search_counter_label.grid(row=0, column=0, sticky="e", padx=5, pady=0)

    # Second row (Bottom): Contains padding to keep search_counter_label in line with the Search Bar
    search_counter_bottom_row = Label(search_counter_bar, text=" ", bg=main_color, fg=text_color)  # Blank for now
    search_counter_bottom_row.grid(row=1, column=0, sticky="e", padx=5, pady=0)
    search_counter_bottom_row.grid_remove()


def create_info_bar():
    global info_bar, info_bar_label

    # Create a frame for the info bar.
    info_bar = Frame(window, relief="flat", bd=0, background=main_color)
    
    # Create a label for the cursor position (Info Bar).
    info_bar_label = Label(info_bar, text="Line: 1 | Column: 0", bg=main_color, fg=text_color)
    
    # Place the info label inside the info bar frame.
    info_bar_label.grid(row=0, column=0, sticky="e", padx=(5, 5), pady=(2, 3)) # pady=(2, 3) necessary for search_label and status_label to align with checkbox

    # Position the status bar frame in the grid.
    info_bar.grid(row=3, column=1, sticky="we", padx=(5, 20), pady=(2,3)) # pady=(2, 3) necessary for search_label and status_label to align with checkbox


def create_search_bar():
    def on_exit(event):
        event.widget['background'] = main_color  # Reset background on exit
        event.widget['foreground'] = text_color

    def on_enter(event):
        event.widget['background'] = text_color  # Highlight on hover
        event.widget['foreground'] = main_color

    # Create Search Bar Frame
    global search_bar						
    search_bar = Frame(window, relief="flat", bd=0, padx=0, pady=0)
    search_bar.grid(row=3, column=1, sticky="ew", pady=(5, 0))
    search_bar.grid_remove()  # Hide search bar initially

    # Search Bar and Status Bar height values ---------------------------------

    # First Row (Contains Search Bar)
    global search_bar_left_frame
    search_bar_left_frame = Frame(search_bar, bg=main_color)
    # Search Bar and Replace Bar combined are good height:
    # search_bar_left_frame.grid(row=0, column=0, padx=0, pady=(5, 0), sticky="w")
    # Search Bar and Status Bar are same height, smoothly toggling back and forth:
    search_bar_left_frame.grid(row=0, column=0, padx=0, pady=15, sticky="w") # padx=0 to keep search_label aligned with status_label
    # left and right frame must be 15px high to align with Status Bar

    # Second Row (Contains Replace Bar)
    global search_bar_right_frame
    search_bar_right_frame = Frame(search_bar, bg=main_color)
    # Search Bar and Replace Bar combined are good height:
    # search_bar_right_frame.grid(row=0, column=1, padx=5, pady=(5, 0), sticky="w")
    # Search Bar and Status Bar are same height, smoothly toggling back and forth:
    search_bar_right_frame.grid(row=0, column=1, padx=5, pady=15, sticky="w")

    # ------------------------------------------------------------------------

    global search_label								
    search_label = Label(search_bar_left_frame, text="Search:", fg=text_color, bg=main_color)														 
    search_label.grid(row=0, column=0, padx=6, pady=0, sticky="w") # padx must be 6 to align search_entry with replace_entry

    # Search Entry Widget
    global search_entry    
    search_entry = Entry(search_bar_left_frame)
    search_entry.grid(row=0, column=1, padx=5, pady=0, sticky="w")

    # Find Next Button
    search_next_button = Button(search_bar_left_frame, text="Find Next", font=("Helvetica", 10), 
                                bd=0, padx=5, pady=0, command=lambda: find_direction(direction="next"), relief="flat", borderwidth=0)
    search_next_button.grid(row=0, column=2, padx=5, pady=0, sticky="w")
    search_next_button.bind("<Enter>", on_enter)
    search_next_button.bind("<Leave>", on_exit)

    # Find Prev Button
    search_prev_button = Button(search_bar_left_frame, text="Find Prev", font=("Helvetica", 10), 
                                bd=0, padx=5, pady=0, command=lambda: find_direction(direction="previous"), relief="flat", borderwidth=0)
    search_prev_button.grid(row=0, column=3, padx=5, pady=0, sticky="w")
    search_prev_button.bind("<Enter>", on_enter)
    search_prev_button.bind("<Leave>", on_exit)

    # Clear Search Button
    clear_search_button = Button(search_bar_left_frame, text="Clear Search", font=("Helvetica", 10),
                                 bd=0, padx=5, pady=0, command=clear_find_results, relief="flat", borderwidth=0)
    clear_search_button.grid(row=0, column=4, padx=(35, 0), pady=0, sticky="w") # Split the Search Bar buttons with more padding: padx=(20, 0)
    clear_search_button.bind("<Enter>", on_enter)
    clear_search_button.bind("<Leave>", on_exit)

    # Find All Button
    search_all_button = Button(search_bar_left_frame, text="Find All", font=("Helvetica", 10), 
                               bd=0, padx=5, pady=0, command=find_all, relief="flat", borderwidth=0)
    search_all_button.grid(row=0, column=6, padx=2, pady=0, sticky="w")
    search_all_button.bind("<Enter>", on_enter)
    search_all_button.bind("<Leave>", on_exit)
    
    # Create the Case Sensitive checkbox
    global case_sensitive_var
    case_sensitive_var = BooleanVar(value=False)  # Case-insensitive by default
    
    case_sensitive_checkbox = Checkbutton(search_bar_left_frame, text="Case Sensitive", font=("Helvetica", 10), 
                                          variable=case_sensitive_var, bg=main_color, fg=text_color, selectcolor=second_color)
    case_sensitive_checkbox.grid(row=0, column=7, padx=(10, 5), pady=0, sticky="w")    

    # Create the Case Sensitive checkbox
    global whole_word_var
    whole_word_var = BooleanVar(value=False)  # Whole-word search is disabled by default

    whole_word_checkbox = Checkbutton(search_bar_left_frame, text="Whole Word", font=("Helvetica", 10), 
                                      variable=whole_word_var, bg=main_color, fg=text_color, selectcolor=second_color)
    whole_word_checkbox.grid(row=0, column=8, padx=(10, 5), pady=0, sticky="w")


    # Second Row (Replace related)
    global replace_bar
    replace_bar = Frame(search_bar, bg=main_color)
    replace_bar.grid(row=1, column=0, columnspan=2, sticky="ew", padx=5, pady=(0, 5))
    replace_bar.grid_remove() # Initially hide the Replace Bar
    
    global replace_label
    replace_label = Label(replace_bar, text="Replace:", fg=text_color, bg=main_color)
    replace_label.grid(row=1, column=0, padx=0, pady=5, sticky="w") # padx must be 0 to align with search_label
    replace_label.grid_remove() # Initially hide the Replace Bar

    # Replace Entry Widget
    global replace_entry
    replace_entry = Entry(replace_bar)
    replace_entry.grid(row=0, column=1, padx=5, pady=5, sticky="w")

    # Replace Next Button
    replace_next_button = Button(replace_bar, text="Replace Next", font=("Helvetica", 10), 
                                 bd=0, padx=5, pady=5, command=replace_next, relief="flat", borderwidth=0)
    replace_next_button.grid(row=0, column=2, padx=5, pady=0, sticky="w")
    replace_next_button.bind("<Enter>", on_enter)
    replace_next_button.bind("<Leave>", on_exit)

    # Replace in Selection Button
    replace_selection_button = Button(replace_bar, text="[ Replace in Selection ]", font=("Helvetica", 10), 
                                      bd=0, padx=5, pady=10, command=replace_in_selection, relief="flat", borderwidth=0)
    replace_selection_button.grid(row=0, column=3, padx=5, pady=0, sticky="w")
    replace_selection_button.bind("<Enter>", on_enter)
    replace_selection_button.bind("<Leave>", on_exit)

    # Replace All Button
    replace_all_button = Button(replace_bar, text="Replace All", font=("Helvetica", 10), 
                                bd=0, padx=5, pady=5, command=replace_all, relief="flat", borderwidth=0)
    replace_all_button.grid(row=0, column=4, padx=5, pady=0, sticky="w")
    replace_all_button.bind("<Enter>", on_enter)
    replace_all_button.bind("<Leave>", on_exit)

    
    # Configuring the search bar frames
    search_bar_left_frame.grid_columnconfigure(2, weight=1)
    search_bar_right_frame.grid_columnconfigure(0, weight=1)
    
    # Global variables to store search positions and result count
    global search_positions, find_count, current_result_index

    # Initialize the search_positions list and current_result_index variable
    search_positions = []   # Used to store the positions of search results in the text widget.
    find_count = 0  # Total instances of a term enters into search_entry
    current_result_index = -1 # Used to iterate over search result positions stored in search_positions   

    # Set focus on search entry when the Search Bar becomes visible
    search_entry.focus_set()


status_bar_message = "Status Bar Message"


def create_status_bar():
    global status_bar, status_label

    # Create a frame for the status bar.
    status_bar = Frame(window, relief="flat", bd=0, background=main_color)
    
    # Create a label for the status bar message.
    status_label = Label(status_bar, text=status_bar_message, bg=main_color, fg=text_color)
    
    # Place the status label inside the status bar frame, aligning it to the right.
    status_label.grid(row=0, column=0, sticky="e", padx=(0, 20), pady=(2, 3)) # pady=(2, 3) necessary for search_label and status_label to align with checkbox

    # Position the status bar frame in the grid.
    status_bar.grid(row=3, column=1, sticky="we", padx=(5, 20), pady=(2,3)) # pady=(2, 3) necessary for search_label and status_label to align with checkbox


def update_bottom_bar():
    # Handle Search Bar visibility first.
    if search_bar_var.get():
        search_counter_bar.grid(row=3, column=1, sticky="e", padx=(5, 20), pady=5) # pady must be 5 for search_label and status_label to align
        search_bar.grid(row=3, column=1, sticky='we', padx=0, pady=0)
        
        # Hide Info Bar and Status Bar when Search Bar is visible.
        info_bar.grid_forget()
        status_bar.grid_forget()        
    else:
        # Hide Search Bar if search_bar_var is not set.
        search_counter_bar.grid_forget()
        search_bar.grid_forget()

        # Handle Info Bar visibility independently.
        if info_bar_var.get():
            info_bar.grid(row=3, column=1, sticky='e', padx=(5, 20), pady=15)
        else:
            info_bar.grid_forget()

        # Handle Status Bar visibility independently.
        if status_bar_var.get():
            status_bar.grid(row=3, column=1, sticky='we', padx=(5, 20), pady=15)
        else:
            status_bar.grid_forget()

    # If none of the bars are toggled on...
    if not (info_bar_var.get() or search_bar_var.get() or status_bar_var.get()):
        # Create a persistent bottom bar that is always visible with minimal padding
        search_counter_bar.grid_forget()
        info_bar.grid_forget()
        search_bar.grid_forget()
        status_bar.grid_forget()
        
        persistent_bottom_bar = Frame(window, relief="flat", bd=0, padx=0, pady=5) # Just 5px high
        # Text label for the bottom bar purely for debugging purposes
        # persistent_bottom_label = Label(persistent_bottom_bar, text="Bottom Bar", bg=main_color, fg=text_color)
        # persistent_bottom_label.grid(row=0, column=0, sticky="e", padx=(5, 20))
        persistent_bottom_bar.grid(row=3, column=1, padx=0, pady=5)  # Make sure the bar is always visible


def toggle_info_bar():
    """
    Function to update checkbuttons when Info Bar is toggled.
    Called from create_menu Function.
    """
    global was_search_bar_visible, was_replace_bar_visible

    if info_bar_var.get():
        # Uncheck Search Bar and Replace Bar when Info Bar is shown
        was_search_bar_visible = search_bar_var.get()
        was_replace_bar_visible = replace_bar_var.get()
        
        search_bar_var.set(0)
        replace_bar_var.set(0)
        update_bottom_bar()

    else:
        # Restore previous state of Search and Replace Bars if they were previously visible
        search_bar_var.set(was_search_bar_visible)
        replace_bar_var.set(was_replace_bar_visible)
        update_bottom_bar()

    # Ensure the "Replace Text" option reflects the actual state of the Replace Bar
    if not replace_bar_var.get():
        replace_bar_var.set(0)


def toggle_replace_bar(event=None):
    """Show or hide the Replace row based on the toggle in the Options menu."""
    global was_search_bar_visible

    if replace_bar_var.get():  # If the Replace Bar is being toggled on
        # Store the state of the Search Bar before showing the Replace Bar
        was_search_bar_visible = search_bar_var.get()

		# Check if the search_bar is already visible
        if not search_bar_var.get():
			# If the Search Bar is not visible, toggle it on
            search_bar_var.set(1)  # Ensure search_bar is toggled on
            toggle_search_bar()  # Show search_bar															   

        # Make the Replace Bar visible
        replace_bar.grid(row=1, column=0, columnspan=2, sticky="ew", padx=5, pady=0)
        replace_label.grid(row=0, column=0, padx=0, pady=5, sticky="w") # padx must be 0 to align with search_label
        search_counter_bottom_row.grid(row=1, column=0, sticky="e", padx=5, pady=0)

        # Toggle the height of the Search Bar from the create_search_bar Function
        # Narrows the space between the first and second row of the Search Bar (Search and Replace Bar)
        search_bar_left_frame.grid(row=0, column=0, padx=0, pady=(5, 0), sticky="w") # padx=0 to keep search_label aligned with status_label
        search_bar_right_frame.grid(row=0, column=1, padx=5, pady=(5, 0), sticky="w")

        # Update the counter label if there are search results																																		  
        if find_count:
            search_counter_label.config(text=f'Remaining Instances: {find_count} of {find_count}')
        else:
            search_counter_label.config(text=f' ')

    else:  # If the Replace Bar is being toggled off
        replace_bar.grid_remove()  # Hide the Replace Bar
        search_counter_bottom_row.grid_remove()

        # Toggle the height of the Search Bar from the create_search_bar Function
        search_bar_left_frame.grid(row=0, column=0, padx=0, pady=15, sticky="w") # padx=0 to keep search_label aligned with status_label
        search_bar_right_frame.grid(row=0, column=1, padx=5, pady=15, sticky="w")

        # If the search_bar was not visible before, hide it when toggling off replace_bar
        if not was_search_bar_visible:
            search_bar_var.set(0)  # Set the search_bar_var to off
            toggle_search_bar()  # Hide search_bar

        # Update the counter label when Replace Bar is toggled off						
        if find_count:
            search_counter_label.config(text=f'Results: {find_count}')
        else:
            search_counter_label.config(text=f' ')


def toggle_search_bar(event=None):
    """
    This function toggles the Search Bar and its Counter using either with the 
    Control-F keybinding or the checkbutton in the menu.
    It ensures that the state of the checkbutton (search_bar_var) is in sync with the UI.
    """
    
    """
    When I call the toggle_search_bar function, I want to remember if either 
    the Status Bar or the Info Bar were visible.  When I toggle the Search Bar 
    off, I want to restore the Status Bar if it was visible and I want to 
    restore the Info Bar if it was visible.
    """																			   
																		 
    # Store the state of the Info Bar and Status Bar before the Search Bar is toggled. 
    # Allows user to restore their previous states when the Search Bar is hidden.
    global was_info_bar_visible, was_status_bar_visible

    # Toggle the Search Bar state (triggered by either keybinding or checkbutton)

    # Check the State of search_bar_var
    if search_bar_var.get():  # If the checkbutton is checked (search bar should be visible)
	
        # True (checkbutton is checked, or keybinding is toggled) means the Search Bar should be shown.
        # False, it means the Search Bar should be hidden.	
	
        # Store the state of Info Bar and Status Bar before showing the Search Bar										   
        was_info_bar_visible = info_bar_var.get()
        was_status_bar_visible = status_bar_var.get()

        # Hide Status Bar and Info Bar
        info_bar_var.set(0)
        status_bar_var.set(0)

        # Show the Search Bar
        search_bar.grid(row=3, column=1, sticky='we', padx=0, pady=10)  # pady=10 to compensate for buttons
        search_counter_bar.grid(row=3, column=1, sticky="e", padx=(0, 20), pady=0)  # Show Counter Bar

    else:  # If the Search Bar is being toggled off
        # Hide the Search Bar and Counter Bar
        search_counter_bar.grid_forget()
        search_bar.grid_forget()

        # Restore the previous state of Info Bar and Status Bar
        info_bar_var.set(was_info_bar_visible)
        status_bar_var.set(was_status_bar_visible)

        # If the Replace Bar is visible, uncheck the Replace Text option and hide the Replace Bar
        if replace_bar_var.get():
            replace_bar_var.set(0)  # Uncheck the Replace Text toggle
            replace_bar.grid_remove()  # Hide the Replace Bar

    # Update the bottom bar to reflect changes
    update_bottom_bar()


def toggle_status_bar():
    """
    Function to update checkbuttons when Status Bar is toggled.
    Called from create_menu Function.
    """
    if status_bar_var.get():
        # Uncheck Search Bar if Status Bar is checked
        search_bar_var.set(0)

    update_bottom_bar()


# ***************** Search Bar Functions


def find_all(event=None):
    # "event=None" is the secret sauce that makes keybinding work!
    
    """  
    The find_all function is responsible for finding and highlighting all 
    occurrences of a search term within the text widget.
    
    It retrieves the search term from an entry widget named search_entry.
    If the search term is not empty, it initiates a search loop using the
    text_widget.search method. It starts searching from the beginning of the
    text widget (start_pos = "1.0") and continues until no further occurrences
    are found (pos = None).
    
    When an occurrence is found, it adds a tag named "found" to the corresponding
    positions using text_widget.tag_add.  The end position is calculated based
    on the length of the search term and added to the start position.
    
    If no search term is entered, it displays an error message using messagebox.showerror.
    """

    """Search the entire text and update search_positions with all occurrences."""		 
																	  
    global search_positions, find_count, total_count, current_result_index

    search_text = search_entry.get()

    # Clear previous search results and highlighting
    search_positions.clear()
    text_widget.tag_remove("found", "1.0", "end")
    
    # Initialize the counter for the number of search results found
    find_count = 0
    
    if search_text:
        start_pos = "1.0"
        
        # Set case sensitivity option for .search method based on the checkbox on the Search Bar
        case_sensitive_search_option = 0 if case_sensitive_var.get() else 1

        # Define the search pattern based on whole-word matching for "Whole Words" search option
        if whole_word_var.get():
            search_pattern = fr"\b{re.escape(search_text)}\b"
        else:
            search_pattern = re.escape(search_text)
            
        # Keep searching until there are no more matches
        while True:
			# Search for the next occurrence of the search text starting from start_pos
            pos = text_widget.search(search_pattern, start_pos, stopindex="end", nocase=case_sensitive_search_option, regexp=True)
			# If no match is found, break out of the loop											 
            if not pos:
                break
            # Calculate the end position of the match by adding the length of the search text to the start position																												   
            end_pos = f"{pos}+{len(search_text)}c"
            # Apply the "found" tag to the matched text to highlight it																	   
            text_widget.tag_add("found", pos, end_pos)
            # Update start_pos to the end position of the match to search for the next occurrence																								 
            start_pos = end_pos
            # Add the position of the match to the list of search results search_positions																						  
            search_positions.append(pos)
            # Increment the counter for each result found														 
            find_count += 1
        # Configuring the "found" tag with a yellow background 
        text_widget.tag_configure("found", background=line_highlight)
        
        # Set total_count only if it's the first search or search is being reset
        total_count = find_count # After while but before else

        # Update the search counter label with the index and total count of search term
        update_search_counter(find_count, total_count)
																								
        # Set the current_result_index to -1 to start with the first search result              
        # Setting the current_result_index variable to 0 highlights SECOND instance																				   
        current_result_index = -1
    else:
        # If text hasn't been entered into the Entry widget:
        if search_bar.winfo_ismapped():
            window.bell()
            search_counter_label.config(text="Please enter text before searching.") # Instead of messagebox
            # messagebox.showerror("Search", "Please enter text before searching.")
            search_entry.focus_set()
        else:
            # Open Search Bar
            toggle_search_bar()
            # Shift keyboard focus to search_entry (Text field on Search Bar)
            search_entry.focus_set()


# def find_next_instance(direction):   # direction = "next" or "previous"
def find_direction(event=None, direction="next"):
    """
    The find_all function finds all the positions of the search term in the text
    and compiles them into a list called search_positions. This function moves
    the highlight of the search term to either the next or previous index of 
    search_positions.

    The 'direction' parameter determines if we are searching forwards ('next') 
    or backwards ('previous').
    """
    # Use the global keyword to access the search_positions variable from outside this function
    global search_positions
    global find_count
    # Maintain the search positions and highlight the next and previous results during navigation
    global current_result_index

    # Retrieve the search term from the search_entry widget
    search_text = search_entry.get()

    # If search_positions is empty, run find_all to initialize search results
    if not search_positions:
        """
        Added an if statement to check if search_positions is empty. If it's empty,
        that means it's the first time the function is being called, so it will
        call find_all to perform the initial search.
        """
        find_all()

    if search_positions:
        """
        If search_positions is not empty, ncrement the current_result_index
        variable to move to the next or previous search result. If it reaches 
        the end of the list, it will wrap around to the beginning. 
        """
        # Move to the next or previous result based on the direction parameter
        if direction == "next":
            if current_result_index < find_count - 1:  # Move to next result
            # Use find_count.  Do NOT recalculate len(search_positions)
                current_result_index += 1
            else:
                current_result_index = 0  # Wrap around to the first result

        elif direction == "previous":
            if current_result_index > 0:  # Move to previous result
                current_result_index -= 1
            else:
                current_result_index = find_count - 1  # Wrap around to the last result

        # Highlight the current result
        highlight_current_result()

        # Update the search position label with the current position and total count
        update_search_counter(current_result_index + 1, find_count)


def highlight_current_result():
    """Highlight the current search result based on the current_result_index."""
    global search_positions, current_result_index

    # Clear any previous highlights
    text_widget.tag_remove("found", "1.0", "end")

    if search_positions and 0 <= current_result_index < len(search_positions):
        # Highlight the current result
        result_pos = search_positions[current_result_index]
        end_pos = f"{result_pos}+{len(search_entry.get())}c"
        text_widget.tag_add("found", result_pos, end_pos)

        # Ensure the highlighted result is visible
        text_widget.mark_set("insert", result_pos)
        text_widget.see(result_pos)


def clear_find_results(event=None):
    """Clear previous search results.  Reset the search bar and counter."""
    global search_positions, current_result_index, find_count

    # Remove the highlights and reset global variables for new search
    text_widget.tag_remove("found", "1.0", "end")
    search_positions = []
    find_count = 0
    current_result_index = -1

    # Clear the search counter on the Search Bar
    search_counter_label.config(text=" ")
    # Clear text from search_entry (Text field on Search Bar)
    search_entry.delete(0, END)
    replace_entry.delete(0, END) # Also clear the replace entry field if visible
    # Shift keyboard focus to search_entry (Text field on Search Bar)
    search_entry.focus_set()


def search_entry_deleted(event=None):
    """If the text is cleared from the search entry, clear corresponding highlighted from text widget"""
    if search_entry.get() == "":  # Check if the entry field is empty
        clear_find_results()


# ***************** /Search Bar Functions


def replace_text(event=None):
    """Replace the search term with new text user enters into a prompt."""
    global search_positions

    # Retrieve the search term from the search_entry widget
    search_text = search_entry.get()

    if not search_text:
        # Display an error message in a pop-up
        messagebox.showerror("Replace", "Please enter text to search for.")

    # Prompt the user for replacement text
    replacement_text = simpledialog.askstring("Replace", "Replace with:")

    if not replacement_text:
        # Display an error message in a pop-up
        messagebox.showerror("Replace", "Please enter replacement text.")

    # Clear previous search results before replacement
    text_widget.tag_remove("found", "1.0", "end")

    # Get all occurrences of the search text (reusing the find_all function)
    find_all()

    # If search_positions is empty, no match was found
    if not search_positions:
        window.bell()
        search_counter_label.config(text="No matches found.") # Instead of messagebox
        #messagebox.showinfo("Replace", "No matches found.")
        return

    # Replace all occurrences in reverse order (to prevent index shifting)
    for pos in reversed(search_positions):
        end_pos = f"{pos}+{len(search_text)}c"
        text_widget.delete(pos, end_pos)  # Delete the found text
        text_widget.insert(pos, replacement_text)  # Insert the replacement text

    # Clear the search_positions list and update the Text widget
    search_positions.clear()
    find_count = 0
    update_search_counter(find_count)


def replace_next():
    """Replace the next occurrence of the search term."""
    global current_result_index, search_positions, find_count, total_count
							   
    # Get the search and replacement text from the entry fields
    search_text = search_entry.get().strip()
    replacement_text = replace_entry.get().strip()

    # Ensure both search and replacement text are provided
    if not search_text or not replacement_text:
        window.bell()
        search_counter_label.config(text="Please provide both search and replacement text.")  # Instead of messagebox
        # messagebox.showerror("Replace", "Please provide both search and replacement text.")

    # Run find_all() if no search has been performed yet
    if not search_positions:
        find_all()

    # Make sure there are search results
    if not search_positions:
        window.bell()
        search_counter_label.config(text="No matches found.")												 
        return

    # Initialize current_result_index if this is the first replacement (not set yet)
    if current_result_index == -1:
        current_result_index = 0

    # Replace the current highlighted result
    if 0 <= current_result_index < len(search_positions):
        result_pos = search_positions[current_result_index]
        end_pos = f"{result_pos}+{len(search_text)}c"

        # Replace the text at the current result position
        text_widget.delete(result_pos, end_pos)
        text_widget.insert(result_pos, replacement_text)

        # Remove the replaced position from search_positions
        del search_positions[current_result_index]
        find_count -= 1

        # Update the search counter label
        update_search_counter(find_count, total_count)

        # If there are more results, move to the next result
        if search_positions:
            current_result_index = current_result_index % len(search_positions)
            highlight_current_result()

        # If no more results are left
        if find_count == 0:
            window.bell()
            search_counter_label.config(text=f'Remaining Instances: 0 of {total_count}')
    else:
        search_counter_label.config(text=f'Remaining Instances: {find_count} of {total_count}')


def replace_in_selection():
    """Replace occurrences of search text in the selected text."""
    search_text = search_entry.get()
    replacement_text = replace_entry.get()

    if not search_text or not replacement_text:
        window.bell()
        messagebox.showerror("Replace", "Please provide both search and replacement text.")
        return  # Exit if text fields are incomplete
    
    try:
        # Get selected text and check if the search term is in it
        selected_text = text_widget.selection_get()
        
        # Count occurrences of search_text in selected_text
        search_instances = selected_text.count(search_text)
        
        if search_instances > 0:  # Use count (above) rather than while loop here
            # Calculate starting and ending index in Tkinter's format
            start = text_widget.index("sel.first")
            end = text_widget.index("sel.last")
            
            # Replace all instances in selected_text
            replaced_text = selected_text.replace(search_text, replacement_text)
            text_widget.delete(start, end)
            text_widget.insert(start, replaced_text)

            window.bell()            
            # Update search counter label with total instances replaced
            search_counter_label.config(text=f'{search_instances} occurrences replaced!')
        else:
            window.bell()
            # No instances found in selected text
            search_counter_label.config(text="Search term not found in selected text.")
            
    except TclError:
        messagebox.showerror("Replace", "No text selected.")


def replace_all():
    """Replace all occurrences of the search term in the entire text."""
    search_text = search_entry.get()
    replacement_text = replace_entry.get()
      
    if not search_text or not replacement_text:
        messagebox.showerror("Replace", "Please provide both search and replacement text.")
        return

    # Call find_all to get all occurrences of the search text
    find_all()

    for pos in reversed(search_positions):
        end_pos = f"{pos}+{len(search_text)}c"
        text_widget.delete(pos, end_pos)
        text_widget.insert(pos, replacement_text)

    # Clear search positions after replacing
    search_positions.clear()
    update_search_counter(0, 0)
    window.bell()
    search_counter_label.config(text=f'All {find_count} occurrences replaced!') # Instead of messagebox
    # messagebox.showinfo("Replace", "All occurrences replaced.")


# ***************** User Accessability ***************** #

# Transplanted from Larger Text Editor Project:
def create_bindings(window):    
    # ***************** Search Bindings ***************** #

    # The single most difficult line of code in this project - DO NOT CHANGE:
  
    # Bind Control-F to toggle the Search Bar
    window.bind('<Control-f>', lambda event: search_bar_var.set(not search_bar_var.get()) or toggle_search_bar())
    """ This binding triggers the toggle behavior for the Control-F keybinding. 
    It inverts the state of search_bar_var (set(not search_bar_var.get())) and 
    then calls the toggle_search_bar() function to update the UI. """
    
    # Bind Control-F to toggle the Search Bar
    window.bind('<Control-h>', lambda event: replace_bar_var.set(not replace_bar_var.get()) or toggle_replace_bar())
    """ This binding triggers the toggle behavior for the Control-H keybinding. 
    It inverts the state of replace_bar_var and then calls toggle_replace_bar to update the UI. """


    '''
    # Basic Bitch Keybindings have no power here:

    # Keyboard shortcut to open Search Bar 
    window.bind("<Control-f>",  lambda event: toggle_search_bar()) 
    # Keyboard shortcut to open Replace Bar 
    # window.bind("<Control-h>", lambda event: toggle_replace_bar())
   '''
   
    # Keyboard shortcuts to Search without pressing a button
    search_entry.bind("<KeyRelease-Return>", lambda event: find_all())
    # Note: search_entry.bind("<Return>" does not allow for persistant highlighting   

    # Keyboard shortcut to find the next occurrence (F3)
    window.bind("<F3>", lambda event: find_direction(direction="next"))
   
    # Keyboard shortcut to find the previous occurrence (Shift+F3)
    window.bind("<Shift-F3>", lambda event: find_direction(direction="previous"))

    # Select one of the following uses of the Escape key, but not both:
    
    # Keyboard shortcut to close Search Bar 
    # search_entry.bind("<KeyRelease-Escape>", lambda event: toggle_search_bar() if search_bar_var.get() else None)
    # Keyboard shortcut to clear Search Results
    search_entry.bind("<Escape>", lambda event: clear_find_results())
    
    # When search_entry looses and regains focus, the text field and the text widget highlighting clears
    search_entry.bind("<FocusIn>", lambda event: clear_find_results())
    
    # When search_entry is emptied, the text field and the text widget highlighting clears
    search_entry.bind("<KeyRelease>", search_entry_deleted)

    # With <FocusOut> and <FocusIn> we can achieve the desired behavior without 
    # the "<KeyRelease>" that interferes with <F3> and <Shift-F3> keybinding


def create_window():
    global window

    # Create the main window
    window = Tk()
    window.title("Simple Notepad with Toggleable Footer Bars")
    window.geometry("1200x690")
    window.resizable(True, True)
    
    # Configure row/column resizing
    window.grid_rowconfigure(1, weight=1)
    window.grid_columnconfigure(1, weight=1)

    # Create the interface components
    create_menu()
    create_toolbar()

    # Call the function to create the line numbers canvas
    create_linenumbers_canvas()
    # Create the text widget (After linenumbers_canvas is defined)
    create_text_widget(window, linenumbers_canvas)

    # Insert sample text for debugging purposes
    text_widget.insert("end", "Type some text here...")
    text_widget.insert("end", "one\ntwo\nthree\n")
    text_widget.insert("end", "four\n")
    text_widget.insert("end", "five\nsecond two\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n")
 
    create_search_bar()
    create_status_bar()
    create_info_bar() # Must be called AFTER create_status_bar to appear on launch
    create_search_counter_bar()  

    # Ensure both Status Bar and Info Bar are visible at startup
    update_bottom_bar()

    # Bind events to update the cursor position in the info bar
    text_widget.bind("<KeyRelease>", update_cursor_position_indicator)
    text_widget.bind("<ButtonRelease>", update_cursor_position_indicator)

    create_bindings(window)  # Call this only after all widgets are created
    
    # Run the application
    window.mainloop()


if __name__ == "__main__":
    create_window()     # Run the event loop to keep the window active

