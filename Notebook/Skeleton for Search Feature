

import os, sys 
from tkinter import *
from tkinter import filedialog
from tkinter import font
from tkinter import messagebox
from tkinter import colorchooser 
import tkinter.ttk as ttk   
import win32print
import win32api



# ***************** Text Widget Functions ***************** #

def create_custom_text(window, linenumbers_canvas): 
    global text
    text_editor_frame = Frame(window) 
    text = Text(text_editor_frame, font=("Helvetica", 16), selectbackground="yellow",
                selectforeground="black", undo=True, padx=5, pady=5, wrap="none")

    def proxy(*args):
        cmd = (text._orig,) + args
        result = text.tk.call(cmd)

        if (
            args[0] in ("insert", "replace", "delete")
            or args[0:3] == ("mark", "set", "insert")
            or args[0:2] == ("xview", "moveto")
            or args[0:2] == ("xview", "scroll")
            or args[0:2] == ("yview", "moveto")
            or args[0:2] == ("yview", "scroll")
        ):
            text.event_generate("<<Change>>", when="tail")

        return result

    text._orig = text._w + "_orig"
    text.tk.call("rename", text._w, text._orig)
    text.tk.createcommand(text._w, proxy)

    vertical_scrollbar = Scrollbar(text_editor_frame, orient="vertical", command=text.yview)
    text.configure(yscrollcommand=vertical_scrollbar.set)
    horizontal_scrollbar = Scrollbar(text_editor_frame, orient="horizontal", command=text.xview)
    text.configure(xscrollcommand=horizontal_scrollbar.set)

    text.grid(row=0, column=0, sticky="nsew")

    vertical_scrollbar.grid(row=0, column=1, sticky="ns")
    horizontal_scrollbar.grid(row=1, column=0, sticky="ew")
    text_editor_frame.grid_rowconfigure(0, weight=1)
    text_editor_frame.grid_columnconfigure(0, weight=1)

    text_editor_frame.grid(row=1, column=1, sticky="nsew", padx=2, pady=2)

    text.bind("<<Change>>", create_text_line_numbers(linenumbers_canvas, text))
    text.bind("<<Modified>>", create_text_line_numbers(linenumbers_canvas, text))
    text.bind("<Configure>", create_text_line_numbers(linenumbers_canvas, text))

    return text

def create_text_line_numbers(canvas, text_widget):   
    def redraw(*args):
        canvas.delete("all")

        i = text_widget.index("@0,0")
        while True:
            dline = text_widget.dlineinfo(i)
            if dline is None:
                break
            y = dline[1]
            linenum = str(i).split(".")[0]
            canvas.create_text(2, y, anchor="nw", text=linenum)
            i = text_widget.index("%s+1line" % i)

    return redraw

def toggle_linenumbers():
    if linenumbers_button_var.get():
        linenumbers_canvas.grid(row=1, column=0, sticky="NS")
        window.grid_rowconfigure(0, weight=0, minsize=0)
        window.grid_rowconfigure(1, weight=1, minsize=0, pad=5)
    else:
        linenumbers_canvas.grid_forget() 


# ***************** Search Functions ***************** #

# Declare search_positions as an empty list before using it
# Used to avoid "NameError: name 'search_positions' is not defined" error
search_positions = []
"""
A global list variable search_positions is declared as an empty list. 
It will be used to store the positions of search results in the text widget.
"""

def find_all():
    """  
    The find_all function is responsible for finding and highlighting all 
    occurrences of a search term within the text widget.
    It retrieves the search term from an entry widget named search_entry.
    If the search term is not empty, it initiates a search loop using the
    text_widget.search method. It starts searching from the beginning of the
    text widget (start_pos = "1.0") and continues until no further occurrences
    are found (pos = None).
    
    When an occurrence is found, it adds a tag named "found" to the corresponding
    positions using text_widget.tag_add.  The end position is calculated based
    on the length of the search term and added to the start position.
    
    If no search term is entered, it displays an error message using messagebox.showerror.
    """
    search_text = search_entry.get()

    if search_text:
        start_pos = "1.0"
        while True:
            pos = text_widget.search(search_text, start_pos, stopindex="end")
            if not pos:
                break
            end_pos = f"{pos}+{len(search_text)}c"
            text_widget.tag_add("found", pos, end_pos)
            start_pos = end_pos
        text_widget.tag_configure("found", background="yellow")
    else:
        # If text hasn't been entered into the Entry widget, display an error message
        messagebox.showerror("Search", "Please enter text before searching")

    # Keyboard shortcuts to Search or Close for pop-up dialog
    # search_dialog.bind("<Return>", lambda event: search_command())
    # search_dialog.bind("<Escape>", lambda event: search_dialog.destroy())

# Defining a function to search for the next occurrence of the search term
def find_next():
    """
    The search function finds all the positions of the search term in the text
    and compiles them into a list called search_positions. It also highlights
    the first instance of the search term and sets the current_result_index
    variable to -1.
    """
        
    # Declaring global variables
    global current_result_index
    global search_positions

    # Retrieving the search term from the Entry widget
    search_text = search_entry.get()

    # Searching for the search term in the Text widget and storing the positions in a list
    if search_text:
        start_pos = "1.0"
        if not search_positions:
            search_positions = []
            while True:
                pos = text_widget.search(search_text, start_pos, stopindex="end")
                if not pos:
                    break
                end_pos = f"{pos}+{len(search_text)}c"
                text_widget.tag_add("found", pos, end_pos)
                start_pos = end_pos
                search_positions.append(pos)
            # Configuring the "found" tag with a yellow background
            text_widget.tag_configure("found", background="yellow")
            # Setting the current_result_index variable to 0 highlights SECOND instance
            current_result_index = -1
        # Highlighting the next occurrence of the search term
        if current_result_index < len(search_positions) - 1:
            current_result_index += 1
        else:
            current_result_index = -1
        next_result() # This line ensure that the first instance is highlighted 
    else:
        # If text hasn't been entered into the Entry widget, display an error message
        messagebox.showerror("Search", "Please enter text before searching")

def find_previous():
    """
    The find_previous() function is similar to find_next() but searches backwards
    from the end of the text block.
    """
    global current_result_index
    global search_positions
    #global text_widget
    
    #text_widget.tag_remove("found", "1.0", "end")

    search_text = search_entry.get()

    if search_text:
        end_pos = "end-1c"
        if not search_positions:
            search_positions = []
            while True:
                pos = text_widget.search(search_text, end_pos, stopindex="1.0", backwards=True)
                if not pos:
                    break
                end_pos = pos
                text_widget.tag_add("found", pos, f"{pos}+{len(search_text)}c")
                search_positions.insert(0, pos)
            text_widget.tag_configure("found", background="yellow")
            current_result_index = len(search_positions)
        if current_result_index > 0:
            current_result_index -= 1
        else:
            current_result_index = len(search_positions) - 1
        next_result()
    # If text hasn't been entered into the Entry widget, display an error message
    else:
        messagebox.showerror("Search", "Please enter text before searching")

# Defining a function to highlight the current occurrence of the search term
def next_result():
    # Declaring global variables
    global current_result_index
    global search_positions

    # Highlighting the current occurrence of the search term
    if search_positions:
        text_widget.tag_remove("found", "1.0", "end")
        pos = search_positions[current_result_index]
        text_widget.tag_add("found", pos, f"{pos}+{len(search_entry.get())}c")
        text_widget.mark_set("insert", pos)
        text_widget.see(pos)

# Clear Find results to start over
def clear_find_results(event=None):
    # "event=None" is the secret sauce that makes keybinding work
    global current_result_index
    global search_positions

    if "found" in text_widget.tag_names():
        # Remove results highlighting
        text_widget.tag_remove("found", "1.0", "end")
        # Reset global variables to default for new search
        search_positions = []
        current_result_index = -1

    # Clear search results with clear_find_results upon entering new text in widget
    search_entry.bind("<KeyRelease>", clear_find_results)

"""
# This code causes the Status Bar to replace the Search Bar when activated
def toggle_status_bar():
    global is_search_bar_visible
    global is_status_bar_visible

    if search_bar.winfo_ismapped():
        search_bar.grid_remove()
        search_bar_checkbutton_var.set(0)
        
        if status_bar_checkbutton_var.get() == 1:
            status_bar.grid(row=2, column=0, columnspan=2, sticky=W)
            is_status_bar_visible = True
            
    else:
        if status_bar_checkbutton_var.get() == 1:
            status_bar.grid(row=2, column=0, columnspan=2, sticky=W)
            is_status_bar_visible = True
        else:
            status_bar.grid_remove()
            is_status_bar_visible = False
"""

def toggle_status_bar():
    global is_search_bar_visible
    global is_status_bar_visible

    if search_bar.winfo_ismapped():
        is_status_bar_visible = True
        # status_bar_checkbutton_var = 1
            
    else:
        if status_bar_checkbutton_var.get() == 1:
            status_bar.grid(row=2, column=0, columnspan=2, sticky=W)
            is_status_bar_visible = True
        else:
            status_bar.grid_remove()
            is_status_bar_visible = False


def toggle_search_bar(event=None):
    global is_search_bar_visible
    global is_status_bar_visible

    if search_bar.winfo_ismapped():
        search_bar.grid_remove()
        search_bar_checkbutton_var.set(0)

        if is_status_bar_visible:
            status_bar.grid(row=2, column=0, columnspan=2, sticky=W)
            status_bar_checkbutton_var.set(1)
    else:
        search_bar.grid(row=2, column=0, columnspan=2, sticky='w')
        search_bar_checkbutton_var.set(1)

        if is_status_bar_visible:
            status_bar.grid_remove()
            status_bar_checkbutton_var.set(0)
 

# ***************** Search Functions ***************** #

def create_menu(window):
    # Create menu bar
    menu_bar = Menu(window)
    window.config(menu=menu_bar)

    file_menu = Menu(menu_bar, tearoff=False)
    menu_bar.add_cascade(label="File", menu=file_menu)

    # Create "Messages" heading in the menu bar
    messages_menu = Menu(menu_bar, tearoff=False)
    menu_bar.add_cascade(label="Messages", menu=messages_menu)

    # Create three items in the messages menu
    messages_menu.add_command(label="Item 1", command=lambda: select_message("Item 1"))
    messages_menu.add_command(label="Item 2", command=lambda: select_message("Item 2"))
    messages_menu.add_command(label="Item 3", command=lambda: select_message("Item 3"))
    
    # Create "Options" heading in the menu bar
    options_menu = Menu(menu_bar, tearoff=False)
    menu_bar.add_cascade(label="Options", menu=options_menu)

    # Create check button for status bar in the options menu
    status_bar_checkbutton_var.set(1)  # Set default value to 1 (on)
    status_bar_checkbutton = options_menu.add_checkbutton(label="Status bar", variable=status_bar_checkbutton_var, command=toggle_status_bar)

    # Create "Search" heading in the menu bar
    search_menu = Menu(menu_bar, tearoff=False)
    menu_bar.add_cascade(label="Search", menu=search_menu)

    # Create check button for search bar in the search menu
    search_bar_checkbutton_var.set(0)
    search_bar_checkbutton = search_menu.add_checkbutton(label="Search bar", variable=search_bar_checkbutton_var, command=toggle_search_bar)

def create_search_bar(window):  
    global search_bar
    global search_bar_checkbutton_var    

    # Declare global variable to track the visibility of the Search Bar
    is_search_bar_visible = False

    search_bar_checkbutton_var = IntVar()
    
    # ***************** Search Bar Widget ***************** #
    
    # Can't use grid and pack geometry managers on widgets that share the same parent.

    search_bar = Frame(window, bd=5, height=25, highlightthickness=0)
    #search_bar.pack(side="bottom", sticky="sw", padyx=5, pady=5)
    search_bar.grid(row=3, column=1, sticky="ew", pady=5)
    search_bar.grid_remove()  # Hide search bar initially

    # Search Widget
    global search_entry

    search_label = Label(search_bar, text="Search:")
    #search_label.pack(side="left", padx=2, pady=2)
    search_label.grid(row=0, column=0, padx=2, pady=2, sticky="w")

    # Creating an Entry widget for user to input search term    
    search_entry = Entry(search_bar)
    #search_entry.pack(side="left", padx=5, pady=5)
    search_entry.grid(row=0, column=1, padx=5, pady=5, sticky="w")

    # Creating a Button widgets to initiate the search and highlighting
    # Search down the text widget from the top
    search_next_button = Button(search_bar, text="Find Next", command=find_next)
    #search_button.pack(side=LEFT, padx=5, pady=5)    
    search_next_button.grid(row=0, column=2, padx=5, pady=5, sticky="w")

    # Search up the text widget from the bottom
    search_prev_button = Button(search_bar, text="Find Prev", command=find_previous)
    #search_button.pack(side=LEFT, padx=5, pady=5)
    search_prev_button.grid(row=0, column=3, padx=5, pady=5, sticky="w")

    clear_search_button = Button(search_bar, text="Clear Search", command=clear_find_results) 
    #clear_search_button.pack(side="left", padx=2, pady=2)
    clear_search_button.grid(row=0, column=4, padx=2, pady=2, sticky="w")

    # Add invisible button to create space between button groups
    space_button = Button(search_bar, text="",
                          padx=5, pady=5, relief="flat", width=5, state='disabled')
    #space_button.pack(side="left", padx=2, pady=2)
    space_button.grid(row=0, column=5, padx=2, pady=2, sticky="w")

    search_all_button = Button(search_bar, text="Find All", command=find_all) 
    #search_all_button.pack(side="left", padx=2, pady=2)
    search_all_button.grid(row=0, column=6, padx=2, pady=2, sticky="w")


    # Initializing the search_positions list and current_result_index variable
    search_positions = []
    current_result_index = -1


    # Place cursor in Search Entry text box when the Search becomes visible
    search_entry.focus_set()    # Set focus to search entry widget

def create_toolbar(window):
    toolbar_frame = Frame(window, bd=5, highlightthickness=0)

    bold_button = Button(toolbar_frame, text="Bold")
    bold_button.grid(row=0, column=0, padx=2, pady=0)

    italic_button = Button(toolbar_frame, text="Italic")
    italic_button.grid(row=0, column=1, padx=2, pady=0)

    underline_button = Button(toolbar_frame, text="Underline")
    underline_button.grid(row=0, column=2, padx=2, pady=0)

    toolbar_frame.grid(row=0, column=0, columnspan=2, sticky="nw")
    toolbar_frame.config(padx=0, pady=0)  

def create_status_bar(window):
    global status_bar
    
    #global is_status_bar_visible 

    # Declare global variable to track the visibility of the Status Bar
    # Should the Status be restored when the Search Bar is toggled off?
    is_status_bar_visible = True    # On by default

    global status_bar_checkbutton_var
    # Create variables for check buttons
    status_bar_checkbutton_var = IntVar()
    
    global status_bar_message
    # Global variable for status bar message
    status_bar_message = "Status Bar"
    
    # Create status bar
    #status_bar = Label(window, text=status_bar_message)   # Causes label to linger when Search Bar is toggled on
    status_bar = Label(window, text="Status Bar")    
    
def create_bindings(window):
       
    
    # ***************** Search Bindings ***************** #
    # Note: search_entry.bind("<Return>" will not result in persistant highlighting     

    # Clear search results with clear_find_results upon entering new text in widget
    search_entry.bind("<KeyRelease>", clear_find_results)
    # Keyboard shortcuts to Search without pressing a button
    search_entry.bind("<KeyRelease-Return>", lambda event: find_all())
    # Keyboard shortcut to clear Search Results
    search_entry.bind("<Escape>", clear_find_results)
    # Keyboard shortcut to close Search Bar 
    search_entry.bind("<KeyRelease-Escape>", toggle_search_bar)
    
    window.bind('<Control-F>', lambda event: toggle_search_bar())
    window.bind('<Control-f>', lambda event: toggle_search_bar()) 
    window.bind('<F3>', find_next)
    
def create_window():
    global text_widget, window

    # Create main window
    window = Tk()
    window.title("Text Editor")
    window.geometry("1200x690")
    window.resizable(True,True)

    window.grid_columnconfigure(1, weight=1)
    window.grid_rowconfigure(0, weight=0, minsize=0)
    window.grid_rowconfigure(1, weight=1, minsize=0)

    linenumbers_canvas = Canvas(window)    
    linenumbers_canvas.grid(row=1, column=0, sticky="NS")
    window.grid_rowconfigure(1, minsize=linenumbers_canvas.winfo_reqheight())    

    linenumbers_canvas.grid_propagate(False)
    linenumbers_canvas.configure(width=30)

    # Create text widget
    # text_widget = Text(window)
    text_widget = create_custom_text(window, linenumbers_canvas)   
    text_widget.insert("end", "Type some text here...")

    # Test text for the purposes of debugging
    text.insert("end", "one\ntwo\nthree\n")
    text.insert("end", "four\n", ("bigfont",))
    text.insert("end", "five\nsecond two\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n")
    text.insert("end", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nthree two")
    text.insert("end", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfour two")
    text.insert("end", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfive two")
    text.tag_configure("bigfont", font=("Helvetica", "24", "bold")) 



    # Create the search bar
    create_search_bar(window)

    # Create the status bar
    create_status_bar(window)

    # Create the drop-down menu
    create_menu(window)
    
    create_toolbar(window) 

    # Create the status bar by default
    toggle_status_bar()

    create_bindings(window)

    # Start the main event loop
    window.mainloop()

if __name__ == "__main__":
    create_window()

