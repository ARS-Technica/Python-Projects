 
import os, sys 
from tkinter import *
from tkinter import filedialog
from tkinter import font
from tkinter import messagebox
from tkinter import colorchooser 
import tkinter.ttk as ttk   
import win32print
import win32api


# ***************** Search Functions ***************** #

def find_all():
    search_text = search_entry.get()

    if search_text:
        start_pos = "1.0"
        while True:
            pos = text_widget.search(search_text, start_pos, stopindex="end")
            if not pos:
                break
            end_pos = f"{pos}+{len(search_text)}c"
            text_widget.tag_add("found", pos, end_pos)
            start_pos = end_pos
        text_widget.tag_configure("found", background="yellow")
    # If text hasn't been entered into the Entry widget, display an error message
    else:
        messagebox.showerror("Search", "Please enter text before searching")

    # Keyboard shortcuts to Search or Close
    # search_dialog.bind("<Return>", lambda event: search_command())
    # search_dialog.bind("<Escape>", lambda event: search_dialog.destroy())

# Defining a function to search for the next occurrence of the search term
def find_next():
    """
    The search function finds all the positions of the search term in the text
    and compiles them into a list called search_positions. It also highlights
    the first instance of the search term and sets the current_result_index
    variable to -1.
    """
        
    # Declaring global variables
    global current_result_index
    global search_positions

    # Retrieving the search term from the Entry widget
    search_text = search_entry.get()

    # Searching for the search term in the Text widget and storing the positions in a list
    if search_text:
        start_pos = "1.0"
        if not search_positions:
            search_positions = []
            while True:
                pos = text_widget.search(search_text, start_pos, stopindex="end")
                if not pos:
                    break
                end_pos = f"{pos}+{len(search_text)}c"
                text_widget.tag_add("found", pos, end_pos)
                start_pos = end_pos
                search_positions.append(pos)
            # Configuring the "found" tag with a yellow background
            text_widget.tag_configure("found", background="yellow")
            # Setting the current_result_index variable to 0 highlights SECOND instance
            current_result_index = -1
        # Highlighting the next occurrence of the search term
        if current_result_index < len(search_positions) - 1:
            current_result_index += 1
        else:
            current_result_index = 0
        next_result()
    # If text hasn't been entered into the Entry widget, display an error message
    else:
        messagebox.showerror("Search", "Please enter text before searching")

def find_previous():
    """
    The find_previous() function is similar to find_next() but searches backwards
    from the end of the text block.
    """
    global current_result_index
    global search_positions

    search_text = search_entry.get()

    if search_text:
        end_pos = "end-1c"
        if not search_positions:
            search_positions = []
            while True:
                pos = text_widget.search(search_text, end_pos, stopindex="1.0", backwards=True)
                if not pos:
                    break
                end_pos = pos
                text_widget.tag_add("found", pos, f"{pos}+{len(search_text)}c")
                search_positions.insert(0, pos)
            text_widget.tag_configure("found", background="yellow")
            current_result_index = len(search_positions)
        if current_result_index > 0:
            current_result_index -= 1
        else:
            current_result_index = len(search_positions) - 1
        next_result()
    # If text hasn't been entered into the Entry widget, display an error message
    else:
        messagebox.showerror("Search", "Please enter text before searching")

# Defining a function to highlight the current occurrence of the search term
def next_result():
    # Declaring global variables
    global current_result_index
    global search_positions

    # Highlighting the current occurrence of the search term
    if search_positions:
        text_widget.tag_remove("found", "1.0", "end")
        pos = search_positions[current_result_index]
        text_widget.tag_add("found", pos, f"{pos}+{len(search_entry.get())}c")
        text_widget.mark_set("insert", pos)
        text_widget.see(pos)

# Clear Find results to start over
def clear_find_results(event=None):
    # "event=None" is the secret sauce that makes keybinding work
    global current_result_index
    global search_positions

    if "found" in text_widget.tag_names():
        # Remove results highlighting
        text_widget.tag_remove("found", "1.0", "end")
        # Reset global variables to default for new search
        search_positions = []
        current_result_index = -1


    # Clear search results with clear_find_results upon entering new text in widget
    search_entry.bind("<KeyRelease>", clear_find_results)


# ***************** / Search Functions ***************** #

def create_custom_text(root, linenumbers_canvas): 
    global text
    text_editor_frame = Frame(root) 
    text = Text(text_editor_frame, font=("Helvetica", 16), selectbackground="yellow",
                selectforeground="black", undo=True, padx=5, pady=5, wrap="none")

    def proxy(*args):
        cmd = (text._orig,) + args
        result = text.tk.call(cmd)

        if (
            args[0] in ("insert", "replace", "delete")
            or args[0:3] == ("mark", "set", "insert")
            or args[0:2] == ("xview", "moveto")
            or args[0:2] == ("xview", "scroll")
            or args[0:2] == ("yview", "moveto")
            or args[0:2] == ("yview", "scroll")
        ):
            text.event_generate("<<Change>>", when="tail")

        return result

    text._orig = text._w + "_orig"
    text.tk.call("rename", text._w, text._orig)
    text.tk.createcommand(text._w, proxy)

    vertical_scrollbar = Scrollbar(text_editor_frame, orient="vertical", command=text.yview)
    text.configure(yscrollcommand=vertical_scrollbar.set)
    horizontal_scrollbar = Scrollbar(text_editor_frame, orient="horizontal", command=text.xview)
    text.configure(xscrollcommand=horizontal_scrollbar.set)

    text.grid(row=0, column=0, sticky="nsew")

    vertical_scrollbar.grid(row=0, column=1, sticky="ns")
    horizontal_scrollbar.grid(row=1, column=0, sticky="ew")
    text_editor_frame.grid_rowconfigure(0, weight=1)
    text_editor_frame.grid_columnconfigure(0, weight=1)

    text_editor_frame.grid(row=1, column=1, sticky="nsew", padx=2, pady=2)

    text.bind("<<Change>>", create_text_line_numbers(linenumbers_canvas, text))
    text.bind("<<Modified>>", create_text_line_numbers(linenumbers_canvas, text))
    text.bind("<Configure>", create_text_line_numbers(linenumbers_canvas, text))

    return text

def create_text_line_numbers(canvas, text_widget):   
    def redraw(*args):
        canvas.delete("all")

        i = text_widget.index("@0,0")
        while True:
            dline = text_widget.dlineinfo(i)
            if dline is None:
                break
            y = dline[1]
            linenum = str(i).split(".")[0]
            canvas.create_text(2, y, anchor="nw", text=linenum)
            i = text_widget.index("%s+1line" % i)

    return redraw

def toggle_linenumbers():
    if linenumbers_button_var.get():
        linenumbers_canvas.grid(row=1, column=0, sticky="NS")
        root.grid_rowconfigure(0, weight=0, minsize=0)
        root.grid_rowconfigure(1, weight=1, minsize=0, pad=5)
    else:
        linenumbers_canvas.grid_forget() 

def toggle_status_bar():
    global status_bar

    if statusbar_is_on.get() == 1:
        # Can't use grid and pack geometry managers on widgets that share the same parent.
        # ON
        status_bar = Frame(root, bd=5, height=25, highlightthickness=0)
        status_bar.grid(row=3, column=1, sticky="ew", pady=5)
        #status_bar.pack(side="bottom", sticky="sw", padyx=5, pady=5)

        # Search Widget
        global search_entry

        search_label = Label(status_bar, text="Search:")
        #search_label.pack(side="left", padx=2, pady=2)
        search_label.grid(row=0, column=0, padx=2, pady=2, sticky="w")

        # Creating an Entry widget for user to input search term    
        search_entry = Entry(status_bar)
        #search_entry.pack(side="left", padx=5, pady=5)
        search_entry.grid(row=0, column=1, padx=5, pady=5, sticky="w")

        # Creating a Button widgets to initiate the search and highlighting
        # Search down the text widget from the top
        search_next_button = Button(status_bar, text="Find Next", command=find_next)
        #search_button.pack(side=LEFT, padx=5, pady=5)    
        search_next_button.grid(row=0, column=2, padx=5, pady=5, sticky="w")

        # Search up the text widget from the bottom
        search_prev_button = Button(status_bar, text="Find Prev", command=find_previous)
        #search_button.pack(side=LEFT, padx=5, pady=5)
        search_prev_button.grid(row=0, column=3, padx=5, pady=5, sticky="w")

        clear_search_button = Button(status_bar, text="Clear Search", command=clear_find_results) 
        #clear_search_button.pack(side="left", padx=2, pady=2)
        clear_search_button.grid(row=0, column=4, padx=2, pady=2, sticky="w")

        # Add invisible button to create space between button groups
        space_button = Button(status_bar, text="",
                              padx=5, pady=5, relief="flat", width=5, state='disabled')
        #space_button.pack(side="left", padx=2, pady=2)
        space_button.grid(row=0, column=5, padx=2, pady=2, sticky="w")

        search_all_button = Button(status_bar, text="Find All", command=find_all) 
        #search_all_button.pack(side="left", padx=2, pady=2)
        search_all_button.grid(row=0, column=6, padx=2, pady=2, sticky="w")

        # Initializing the search_positions list and current_result_index variable
        search_positions = []
        current_result_index = -1    

    else:
        # OFF
        status_bar.destroy()

def create_menu():
    menubar = Menu(root)
    root.config(menu=menubar)

    file_menu = Menu(menubar, tearoff=False)
    menubar.add_cascade(label="File", menu=file_menu)

    options_menu = Menu(menubar, tearoff=False)
    menubar.add_cascade(label="Options", menu=options_menu)

    global linenumbers_button_var
    linenumbers_button_var = BooleanVar(value=True)

    options_menu.add_checkbutton(
        label="Show Line Numbers",
        variable=linenumbers_button_var,
        onvalue=True,
        offvalue=False,
        command=toggle_linenumbers)    

    global statusbar_is_on
    statusbar_is_on = BooleanVar(value=True)

    options_menu.add_checkbutton(
        label="Status Bar",
        variable=statusbar_is_on,
        onvalue=1,
        offvalue=0,
        command=toggle_status_bar)

def create_toolbar():
    toolbar_frame = Frame(root, bd=5, highlightthickness=0)

    bold_button = Button(toolbar_frame, text="Bold")
    bold_button.grid(row=0, column=0, padx=2, pady=0)

    italic_button = Button(toolbar_frame, text="Italic")
    italic_button.grid(row=0, column=1, padx=2, pady=0)

    underline_button = Button(toolbar_frame, text="Underline")
    underline_button.grid(row=0, column=2, padx=2, pady=0)

    toolbar_frame.grid(row=0, column=0, columnspan=2, sticky="nw")
    toolbar_frame.config(padx=0, pady=0)  

def create_window():
    global root, linenumbers_canvas, text_widget, status_bar 

    root = Tk()
    root.title("Text Editor")
    root.geometry("1200x690")
    root.resizable(True,True)

    root.grid_columnconfigure(1, weight=1)
    root.grid_rowconfigure(0, weight=0, minsize=0)
    root.grid_rowconfigure(1, weight=1, minsize=0)    

    linenumbers_canvas = Canvas(root)    
    linenumbers_canvas.grid(row=1, column=0, sticky="NS")
    root.grid_rowconfigure(1, minsize=linenumbers_canvas.winfo_reqheight())    

    linenumbers_canvas.grid_propagate(False)
    linenumbers_canvas.configure(width=30)

    text_widget = create_custom_text(root, linenumbers_canvas)   
    text_widget.insert("end", "Type some text here...")

    # Test text for the purposes of debugging
    text.insert("end", "one\ntwo\nthree\n")
    text.insert("end", "four\n", ("bigfont",))
    text.insert("end", "five\nsecond two\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n")
    text.insert("end", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nthree two")
    text.insert("end", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfour two")
    text.insert("end", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfive two")
    text.tag_configure("bigfont", font=("Helvetica", "24", "bold")) 


    create_menu()
    create_toolbar()   
    toggle_status_bar()

    root.mainloop()

if __name__ == "__main__":
    create_window()

