import os, sys
from tkinter import *
from tkinter import filedialog
from tkinter import font
from tkinter import messagebox
from tkinter import colorchooser
import tkinter.ttk as ttk
import win32print
import win32api

def create_custom_text(window, linenumbers_canvas):
    global text

    text_editor_frame = Frame(window)
    text = Text(text_editor_frame, font=("Helvetica", 16), selectbackground="yellow",
                selectforeground="black", undo=True, padx=5, pady=5, wrap="none")
				  
    def proxy(*args):
        cmd = (text._orig,) + args
        result = text.tk.call(cmd)

        if (
            args[0] in ("insert", "replace", "delete")
            or args[0:3] == ("mark", "set", "insert")
            or args[0:2] == ("xview", "moveto")
            or args[0:2] == ("xview", "scroll")
            or args[0:2] == ("yview", "moveto")
            or args[0:2] == ("yview", "scroll")
        ):
            text.event_generate("<<Change>>", when="tail")

        return result

    text._orig = text._w + "_orig"
    text.tk.call("rename", text._w, text._orig)
    text.tk.createcommand(text._w, proxy)

    vertical_scrollbar = Scrollbar(text_editor_frame, orient="vertical", command=text.yview)																
    text.configure(yscrollcommand=vertical_scrollbar.set)
									 
    horizontal_scrollbar = Scrollbar(text_editor_frame, orient="horizontal", command=text.xview)	 
    text.configure(xscrollcommand=horizontal_scrollbar.set)

    text.grid(row=0, column=0, sticky="nsew")  

    vertical_scrollbar.grid(row=0, column=1, sticky="ns")
    horizontal_scrollbar.grid(row=1, column=0, sticky="ew")

    text_editor_frame.grid_rowconfigure(0, weight=1)     
    text_editor_frame.grid_columnconfigure(0, weight=1)  
    
    text_editor_frame.grid(row=1, column=1, sticky="nsew", padx=2, pady=2) 
    text_editor_frame.grid_rowconfigure(0, weight=1)   
    text_editor_frame.grid_columnconfigure(0, weight=1)  

    window.grid_rowconfigure(0, weight=0)
    window.grid_rowconfigure(1, weight=1)
    window.grid_columnconfigure(0, weight=0)
    window.grid_columnconfigure(1, weight=1)

    # Events are used to update the line numbers whenever there is a change in the text widget or when it is resized.
    # Bind the <<Change>> event to the create_text_line_numbers function to redraw the line numbers whenever the TEXT changes
    text.bind("<<Change>>", lambda event: create_text_line_numbers(linenumbers_canvas, text, text_color))
    # Bind the <<Modified>> event to the create_text_line_numbers function to redraw the line numbers whenever the CONTENTS of the text widget are changed
    text.bind("<<Modified>>", lambda event: create_text_line_numbers(linenumbers_canvas, text, text_color))
    # Bind the <Configure> event to the create_text_line_numbers function to redraw the line numbers whenever the SIZE of the text widget changes
    text.bind("<Configure>", lambda event: create_text_line_numbers(linenumbers_canvas, text, text_color))
    
    return text

def create_search_bar(window):
    # Moved to Drop Down Menu function:
    # global search_bar_checkbutton_var    
    # search_bar_checkbutton_var = IntVar()
    
    def on_exit(event):
        event.widget['background'] = main_color #second_color #text_color
        event.widget['foreground'] = text_color #second_color         

    def on_enter(event):
        event.widget['background'] = text_color #second_color
        event.widget['foreground'] = main_color #second_color
    
    # ***************** Search Bar Widget ***************** #
    # Can't use grid and pack geometry managers on widgets that share the same parent.

    # Create Search Bar Frame to position buttons on
    global search_bar						
    search_bar = Frame(window, bd=5, height=25, highlightthickness=0)
    #search_bar.pack(side="bottom", sticky="sw", padyx=5, pady=5)
    search_bar.grid(row=3, column=1, sticky="ew", pady=5)
    search_bar.grid_remove()  # Hide search bar initially

    # Start with a pair of frames to provide horizontal padding to buttons

    global search_bar_button_frame_left
    # Contains search_label, search_entry, search_next_button, search_prev_button, clear_search_button
    search_bar_button_frame_left = Frame(search_bar, bg=main_color)
    search_bar_button_frame_left.configure(bg=main_color)
    search_bar_button_frame_left.grid(row=0, column=0, padx=5, sticky="w")
																							

    global search_bar_button_frame_right
    # Contains search_all_button
    search_bar_button_frame_right = Frame(search_bar, bg=main_color)
    search_bar_button_frame_right.configure(bg=main_color)
    search_bar_button_frame_right.grid(row=0, column=1, padx=15, pady=0, sticky="w")

    global search_label
								
    search_label = Label(search_bar_button_frame_left, text="Search:", fg=text_color, bg=main_color)
														 
    search_label.grid(row=0, column=0, padx=2, pady=2, sticky="w")

    # Creating an Entry widget for user to input search term
    global search_entry    
    search_entry = Entry(search_bar_button_frame_left)
    search_entry.grid(row=0, column=1, padx=5, pady=5, sticky="w")

    # Creating a Button widgets to initiate the search and highlighting

    # Search down the text widget from the top
    search_next_button = Button(search_bar_button_frame_left, text="Find Next", font=("Helvetica", 10), 
                            bd=0, padx=5, pady=5, command=find_next, relief="flat", borderwidth=0)
    search_next_button.grid(row=0, column=2, padx=5, pady=5, sticky="w")
    search_next_button.bind("<Enter>", on_enter)
    search_next_button.bind("<Leave>", on_exit)

    # Search up the text widget from the bottom
    search_prev_button = Button(search_bar_button_frame_left, text="Find Prev", font=("Helvetica", 10), 
                            bd=0, padx=5, pady=5, command=find_previous, relief="flat", borderwidth=0)
    search_prev_button.grid(row=0, column=3, padx=5, pady=5, sticky="w")
    search_prev_button.bind("<Enter>", on_enter)
    search_prev_button.bind("<Leave>", on_exit)
    
    # Clear search result highlighting from text widget
    clear_search_button = Button(search_bar_button_frame_left, text="Clear Search", font=("Helvetica", 10),
                                 bd=0, padx=5, pady=5, command=clear_find_results, relief="flat", borderwidth=0)
    clear_search_button.grid(row=0, column=4, padx=2, pady=2, sticky="w")
    clear_search_button.bind("<Enter>", on_enter)
    clear_search_button.bind("<Leave>", on_exit)
    
    # Search the entire contents of the text widget
    search_all_button = Button(search_bar_button_frame_left, text="Find All", font=("Helvetica", 10), 
                               bd=0, padx=5, pady=5, command=find_all, relief="flat", borderwidth=0)
    search_all_button.grid(row=0, column=6, padx=2, pady=2, sticky="w")
    search_all_button.bind("<Enter>", on_enter)
    search_all_button.bind("<Leave>", on_exit)


    search_bar_button_frame_left.grid_columnconfigure(2, weight=1)
    search_bar_button_frame_right.grid_columnconfigure(0, weight=1)


    # Initializing the search_positions list and current_result_index variable
    search_positions = []
    current_result_index = -1


    # Place cursor in Search Entry text box when the Search becomes visible
    search_entry.focus_set()    # Set focus to search entry widget

def create_status_bar(window):
    is_status_bar_visible = True


    global status_bar
    status_bar = Frame(window, background=main_color)  
    status_bar.grid(row=4, column=1, sticky="WE", pady=5) 

    global status_bar_label
    status_bar_label = Label(status_bar, text=status_bar_message, fg=text_color, bg=main_color)

    status_bar_label.grid(row=0, column=0, padx=0, pady=0, sticky="w")
																										
def create_text_line_numbers(canvas, text, text_color):    
    def redraw(*args):
        canvas.delete("all")

        i = text_widget.index("@0,0")
        while True:
            dline = text_widget.dlineinfo(i)
            if dline is None:
                break
            y = dline[1]
            linenum = str(i).split(".")[0]
            canvas.create_text(2, y, anchor="nw", text=linenum, fill=text_color)

            i = text_widget.index("%s+1line" % i)
    redraw()

    text.bind("<<Change>>", redraw)
    text.bind("<<Modified>>", redraw)
    text.bind("<Configure>", redraw)

    return redraw

status_bar_message = "Status Bar"

def toggle_status_bar():
    global is_status_bar_visible

    if search_bar.winfo_ismapped():
        is_status_bar_visible = True
    else:
        if status_bar_checkbutton_var.get() == 1:
            status_bar.grid(row=2, column=0, columnspan=2, sticky=W)
            is_status_bar_visible = True
        else:
            status_bar.grid_remove()
            is_status_bar_visible = False

def update_status_bar_message(new_message):
    status_bar_label.config(text=new_message)

# The event=None declaration ensures that the function can still be called without any arguments in the keybindings.
def toggle_search_bar(event=None):
    global is_status_bar_visible

    # If the Search Bar is already visible, remove it
    if search_bar.winfo_ismapped():
        search_bar.grid_remove()
        search_bar_checkbutton_var.set(0)
        if is_status_bar_visible:
            status_bar.grid(row=2, column=0, columnspan=2, sticky=W)
            status_bar_checkbutton_var.set(1)
    else:
        search_bar.grid(row=2, column=0, columnspan=2, sticky='w')
        search_bar_checkbutton_var.set(1)

        if is_status_bar_visible:
            status_bar.grid_remove()
            status_bar_checkbutton_var.set(0)

def selected_text_color():
    my_color = colorchooser.askcolor()[1]

    if my_color:
        color_font = font.Font(text, text.cget("font"))
        text.tag_configure("colored", font=color_font, foreground=my_color)
        current_tags = text.tag_names("sel.first")

        if "colored" in current_tags:
            text.tag_remove("colored", "sel.first", "sel.last")
        else:
            text.tag_add("colored", "sel.first", "sel.last")

def background_color():
    my_color = colorchooser.askcolor()[1]

    if my_color:
        text.config(bg=my_color)

def all_text_color():
    my_color = colorchooser.askcolor()[1]

    if my_color:
        text.config(fg=my_color)


# ***************** Format Menu Functions: Font Styling

# Bold Text
def bold_it():
    # Check if any text is selected, otherwise app throws an error
    if text.tag_ranges("sel"):
        # Create the font
        bold_font = font.Font(text, text.cget("font"))
        bold_font.configure(weight="bold")

        # Configure a tag
        text.tag_configure("bold", font=bold_font)

        # Define Current tags
        current_tags = text.tag_names("sel.first")

        # If statement to see if tag has been set
        if "bold" in current_tags:
            #Unbold the selected text
            text.tag_remove("bold", "sel.first", "sel.last")
        else:
            text.tag_add("bold", "sel.first", "sel.last")
    else:
        # print("There is no selected text.")
        # Alert user that no text has been selected
        status_bar_label.config(text="No text has been selected       ")
        messagebox.showinfo("alert", "No text has been selected")        
        status_bar_label.config(text="Ready       ")

# Italics Text
def italics_it():
    # Check if any text is selected, otherwise app throws an error
    if text.tag_ranges("sel"):    
        # Create the font
        italics_font = font.Font(text, text.cget("font"))
        italics_font.configure(slant="italic")

        # Configure a tag
        text.tag_configure("italic", font=italics_font)

        # Define Current tags
        current_tags = text.tag_names("sel.first")

        # If statement to see if tag has been set
        if "italic" in current_tags:
            #Unitalicize the selected text
            text.tag_remove("italic", "sel.first", "sel.last")
        else:
            text.tag_add("italic", "sel.first", "sel.last")
    else:
        # Alert user that no text has been selected
        status_bar_label.config(text="No text has been selected       ")
        messagebox.showinfo("alert", "No text has been selected")        
        status_bar_label.config(text="Ready       ")

# Underline Text
def underline_it():
    # Check if any text is selected, otherwise app throws an error
    if text.tag_ranges("sel"):    
        # Create the font
        underline_font = font.Font(text, text.cget("font"))
        underline_font.configure(underline=True)

        # Configure a tag
        text.tag_configure("underline", font=underline_font)

        # Define Current tags
        current_tags = text.tag_names("sel.first")

        # If statement to see if tag has been set
        if "underline" in current_tags:
            #Underline the selected text
            text.tag_remove("underline", "sel.first", "sel.last")
        else:
            text.tag_add("underline", "sel.first", "sel.last")
    else:
        # Alert user that no text has been selected
        status_bar_label.config(text="No text has been selected       ")
        messagebox.showinfo("alert", "No text has been selected")        
        status_bar_label.config(text="Ready       ")

# Strike Text
def strike_it():
    # Check if any text is selected, otherwise app throws an error
    if text.tag_ranges("sel"):    
        # Create the font
        strike_font = font.Font(text, text.cget("font"))
        strike_font.configure(overstrike=True)

        # Configure a tag
        text.tag_configure("strike", font=strike_font)

        # Define Current tags
        current_tags = text.tag_names("sel.first")

        # If statement to see if tag has been set
        if "strike" in current_tags:
            #Underline the selected text
            text.tag_remove("strike", "sel.first", "sel.last")
        else:
            text.tag_add("strike", "sel.first", "sel.last")
    else:
        # Alert user that no text has been selected
        status_bar_label.config(text="No text has been selected       ")
        messagebox.showinfo("alert", "No text has been selected")        
        status_bar_label.config(text="Ready       ")


# ***************** Search Menu Functions

# Declare search_positions as an empty list before using it
# Used to avoid "NameError: name 'search_positions' is not defined" error
search_positions = []
"""
A global list variable search_positions is declared as an empty list. 
It will be used to store the positions of search results in the text widget.
"""

def find_all(event=None):
    """  
    The find_all function is responsible for finding and highlighting all 
    occurrences of a search term within the text widget.
    It retrieves the search term from an entry widget named search_entry.
    If the search term is not empty, it initiates a search loop using the
    text_widget.search method. It starts searching from the beginning of the
    text widget (start_pos = "1.0") and continues until no further occurrences
    are found (pos = None).
    
    When an occurrence is found, it adds a tag named "found" to the corresponding
    positions using text_widget.tag_add.  The end position is calculated based
    on the length of the search term and added to the start position.
    
    If no search term is entered, it displays an error message using messagebox.showerror.
    """
    search_text = search_entry.get()

    if search_text:
        start_pos = "1.0"
        while True:
            pos = text_widget.search(search_text, start_pos, stopindex="end")
            if not pos:
                break
            end_pos = f"{pos}+{len(search_text)}c"
            text_widget.tag_add("found", pos, end_pos)
            start_pos = end_pos
        text_widget.tag_configure("found", background="yellow")
    else:
        # If text hasn't been entered into the Entry widget:
        if search_bar.winfo_ismapped():
             # Display an error message in a pop-up
             messagebox.showerror("Search", "Please enter text before searching")
        else:
            # Open Search Bar
            toggle_search_bar()
            # Shift keyboard focus to search_entry (Text field on Search Bar)
            search_entry.focus_set()

'''
# Defining a function to search for the next occurrence of the search term
def find_next(event=None):
    """
    The search function finds all the positions of the search term in the text
    and compiles them into a list called search_positions. It also highlights
    the first instance of the search term and sets the current_result_index
    variable to -1.
    """
        
    # Use the global keyword to access the search_positions variable from outside this function
    global search_positions
    global current_result_index 	
    # Maintain the search positions and highlight the next and previous results during navigation
							   

    # Retrieve the search term from the search_entry widget
    search_text = search_entry.get()

    # If the search text is not empty, begin the search
    # Find the search term in the Text widget and store the positions in a list
    if search_text:
        # Start searching from the beginning of the text widget
        start_pos = "1.0"
        
        """
        Added an if statement to check if search_positions is empty. If it's empty,
        that means it's the first time the function is being called, so it will
        perform the initial search and highlight the first instance of the search term.
        If search_positions is not empty, it will increment the current_result_index
        variable to move to the next search result, and if it reaches the end of
        the list, it will wrap around to the beginning. 
        """        
        if not search_positions:
            find_all()
            # Create an empty list to hold the positions of search results
            search_positions = []
            # Keep searching until there are no more matches
            while True:
                # Search for the next occurrence of the search text starting from start_pos
                pos = text_widget.search(search_text, start_pos, stopindex="end")
                # If no match is found, break out of the loop
                if not pos:
                    break
                # Calculate the end position of the match by adding the length of the search text to the start position
                end_pos = f"{pos}+{len(search_text)}c"
                # Apply the "found" tag to the matched text to highlight it
                text_widget.tag_add("found", pos, end_pos)
                # Update start_pos to the end position of the match to search for the next occurrence
                start_pos = end_pos
                # Add the position of the match to the search_positions list
                search_positions.append(pos)
            # Configuring the "found" tag with a yellow background
            text_widget.tag_configure("found", background="yellow")
            # Declaring global variables
            global current_result_index
            # Set the current_result_index to -1 to start with the first search result              
            # Setting the current_result_index variable to 0 highlights SECOND instance
            current_result_index = -1

        # Highlighting the next occurrence of the search term
        if current_result_index < len(search_positions) - 1:
            current_result_index += 1
        else:
            current_result_index = 0 #-1
        
        # Call the next_result function to show the first search result
        next_result() # This line ensure that the first instance is highlighted 
    else:       
        # If text hasn't been entered into the Entry widget:
        if search_bar.winfo_ismapped():
             # Display an error message in a pop-up
             messagebox.showerror("Search", "Please enter text before searching")
        else:
            # Open Search Bar
            toggle_search_bar()
            # Shift keyboard focus to search_entry (Text field on Search Bar)
            search_entry.focus_set()
'''
'''
def find_next(event=None):
    global search_positions
    global current_result_index
    
    search_text = search_entry.get()
    start_index = text_widget.index("insert")
    
    if not search_positions:
        find_all()
        search_positions = text_widget.search(search_text, "1.0", "end", count=True, regexp=True)
        current_result_index = -1
        
    if current_result_index < len(search_positions) - 1:
        current_result_index += 1
    else:
        current_result_index = 0
        
    found_index = search_positions[current_result_index]
    if found_index:
        text_widget.tag_remove("search", "1.0", "end")
        text_widget.tag_add("search", found_index, f"{found_index}+{len(search_text)}c")
        text_widget.see(found_index)  # Scroll to show the found text
'''

def find_next(event=None):
    global search_positions
    global current_result_index
    
    search_text = search_entry.get()
    start_index = text_widget.index("insert")
    
    if not search_positions:
        find_all()
        search_positions = text_widget.search(search_text, "1.0", "end", count=True, regexp=True)
        current_result_index = -1
        
    if current_result_index < len(search_positions) - 1:
        current_result_index += 1
    else:
        current_result_index = 0
        
    if current_result_index < len(search_positions):
        found_index = search_positions[current_result_index]
        if found_index:
            text_widget.tag_remove("search", "1.0", "end")
            text_widget.tag_add("search", found_index, f"{found_index}+{len(search_text)}c")
            text_widget.see(found_index)  # Scroll to show the found text

def find_previous(event=None):
    """
    The find_previous() function is similar to find_next() but searches backwards.
    The previous_result function scrolls the text widget to the position of the
    previous instance of the search term.
    """
    
    # Use the global keyword to access the current_result_index variable from outside this function    
    global current_result_index
    global search_positions
    #global text_widget
    
    #text_widget.tag_remove("found", "1.0", "end")

    search_text = search_entry.get()

    if search_text:
        end_pos = "end-1c"
        if not search_positions:
            find_all()
            search_positions = []
            while True:
                pos = text_widget.search(search_text, end_pos, stopindex="1.0", backwards=True)
                if not pos:
                    break
                end_pos = pos
                text_widget.tag_add("found", pos, f"{pos}+{len(search_text)}c")
                search_positions.insert(0, pos)
            text_widget.tag_configure("found", background="yellow")
            current_result_index = len(search_positions)
        if current_result_index > 0:
            current_result_index -= 1
        else:
            current_result_index = len(search_positions) - 1
        next_result()
    # If text hasn't been entered into the Entry widget, display an error message
    else:
        # If text hasn't been entered into the Entry widget:
        if search_bar.winfo_ismapped():
             # Display an error message in a pop-up
             messagebox.showerror("Search", "Please enter text before searching")
        else:
            # Open Search Bar
            toggle_search_bar()
            # Shift keyboard focus to search_entry (Text field on Search Bar)
            search_entry.focus_set()

# Defining a function to highlight the current occurrence of the search term
def next_result(event=None):
    """
    The next_result function highlights the next instance of the search term
    and updates the current_result_index variable to keep track of which
    result is currently being shown. If there are no more search results,
    it displays a message to the user.
    """
    
    # Declaring global variables
    # Use the global keyword to access the search_positions and current_result_index variables from outside this function
    global current_result_index
    global search_positions
    global current_result_index

    search_text = search_entry.get()

    # Highlighting the current occurrence of the search term
    # If there are search results
    if search_positions:
        # Remove any existing "found" tags on the text widget
        text_widget.tag_remove("found", "1.0", "end")
        # Get the position of the current search result from the search_positions list
        result_pos = search_positions[current_result_index]
        # Calculate the end position of the match by adding the length of the search text to the start position
        #end_pos = f"{result_pos}+{len(search_entry.get())}c"
        end_pos = f"{result_pos}+{len(search_text)}c"
        # Apply the "found" tag to the matched text to highlight it
        #text.tag_add("found", result_pos, end_pos)
        text_widget.tag_add("found", result_pos, end_pos)

        text_widget.mark_set("insert", result_pos)
        # Configure the text widget to scroll to the matched text
        text_widget.see(result_pos)

# Clear Find results to start over
def clear_find_results(event=None):
    # "event=None" is the secret sauce that makes keybinding work
    global current_result_index
    global search_positions

    # Check Current tags
    if "found" in text_widget.tag_names():
        # Remove results highlighting
        text_widget.tag_remove("found", "1.0", "end")
        # Reset global variables to default for new search
        search_positions = []
        current_result_index = -1

    # Clear search results with clear_find_results upon entering new text in widget
    search_entry.bind("<KeyRelease>", clear_find_results)
   
color_schemes = {    
    "Cherry Blossom": {
        "main_color": "#FF85A2",
        "second_color": "#FFC3A0",
        "selection_highlight": "#FF4D6D",
        "text_color": "#331F30",
    },
    "Cool Mint": {
        "main_color": "#4ae0c0",
        "second_color": "#80ffe0",
        "selection_highlight": "#2ee0c0",
        "text_color": "#1e1e1e",
    },
    "Default": {
        "main_color": "SystemButtonFace",
        "second_color": "White", #"SystemButtonFace"
        "selection_highlight": "#999999",
        "text_color": "black",
    },
    "Night Mode": {
        "main_color": "#000000",
        "second_color": "#373737",
        "selection_highlight": "dark green",
        "text_color": "green",
    },
}

active_color_scheme = None

checkbutton_vars = {}

main_color = "SystemButtonFace"
second_color = "White"
selection_highlight = "#999999"
text_color = "black"

def update_search_bar_colors():
    """
    Updates the colors of the Search Bar when the color scheme is changed

    Note: update_search_bar_colors and update_toolbar_button_colors must be 
    kept as seperate functions, otherwise the buttons on the search bar will not
    change color with the theme.
    """
    for button in search_bar_button_frame_left.winfo_children():
        button.configure(bg=main_color, fg=text_color)
    for button in search_bar_button_frame_right.winfo_children():
        button.configure(bg=main_color, fg=text_color)     

    # Make certain search entry box is the same color as the text widget
    if custom_color:
        # If custom palette is active, use custom color
        search_entry.config(bg=custom_color)
    else:
        search_entry.config(bg=second_color)

    # Change the Searchbar frame color with each Color Scheme change
    search_bar_button_frame_left.configure(bg=main_color)
    search_bar_button_frame_right.configure(bg=main_color)

def update_toolbar_button_colors():    
    for button in tool_bar_button_frame_left.winfo_children():
        button.configure(bg=main_color, fg=text_color)
    for button in tool_bar_button_frame_center.winfo_children():
        button.configure(bg=main_color, fg=text_color)
    for button in tool_bar_button_frame_right.winfo_children():
        button.configure(bg=main_color, fg=text_color)    

    tool_bar_button_frame_left.configure(bg=main_color) 
    tool_bar_button_frame_center.configure(bg=main_color) 
    tool_bar_button_frame_right.configure(bg=main_color)

def checkbutton_selected(scheme_name):
    global active_color_scheme, custom_color
    global main_color, second_color, selection_highlight, text_color

    # Get the current state of the "Choose Custom Palette" checkbutton
    custom_palette_active = custom_palette_var.get()

    if scheme_name == "Choose Custom Palette":
        if custom_palette_active:
            set_custom_color()
            active_color_scheme = None
        else:
            custom_color = None
            if active_color_scheme is not None:
                scheme_name = active_color_scheme
            else:
                scheme_name = "Default"

    if scheme_name != "Choose Custom Palette":
        var = checkbutton_vars[scheme_name]
        if var.get():
            if active_color_scheme != scheme_name:
                custom_palette_var.set(False)  
                active_color_scheme = scheme_name

                main_color = color_schemes[scheme_name]["main_color"]
                second_color = color_schemes[scheme_name]["second_color"]
                selection_highlight = color_schemes[scheme_name]["selection_highlight"]
                text_color = color_schemes[scheme_name]["text_color"]

                window.config(bg=main_color)
                toolbar_frame.config(bg=main_color)
                linenumbers_canvas.config(bg=main_color, selectforeground=text_color)
                
                if custom_palette_active:
                    text.config(bg=custom_color, insertbackground=text_color, selectforeground=selection_highlight)
                    search_entry.config(bg=custom_color)
                else:
                    text.config(bg=second_color, insertbackground=text_color, selectforeground=selection_highlight)
                    search_entry.config(bg=second_color)

                status_bar.config(bg=main_color)
                status_bar_label.config(bg=main_color, fg=text_color)
                status_bar_label.config(text=f"{scheme_name} color scheme activated       ")
                window.after(3000, lambda: status_bar_label.config(text="Ready       "))
                
                search_bar.config(bg=main_color)
                search_bar_button_frame_left.config(bg=main_color)
                search_bar_button_frame_right.config(bg=main_color)
                search_label.config(bg=main_color, fg=text_color)
                 
                create_text_line_numbers(linenumbers_canvas, text, text_color)
                
                update_search_bar_colors()
                update_toolbar_button_colors()

        else:
            active_color_scheme = None
            var.set(False)

    for name, var in checkbutton_vars.items():
        if name != "Choose Custom Palette" and name != scheme_name:
            var.set(False)

    if active_color_scheme is None:
        scheme_name = "Default"
        main_color = color_schemes[scheme_name]["main_color"]
        second_color = color_schemes[scheme_name]["second_color"]
        selection_highlight = color_schemes[scheme_name]["selection_highlight"]
        text_color = color_schemes[scheme_name]["text_color"]

        window.config(bg=main_color)
        toolbar_frame.config(bg=main_color)
        linenumbers_canvas.config(bg=main_color, selectforeground=text_color)

        if custom_palette_active:
            text.config(bg=custom_color, insertbackground=text_color, selectforeground=selection_highlight)
            search_entry.config(bg=custom_color)
        else:
            text.config(bg=second_color, insertbackground=text_color, selectforeground=selection_highlight)
            search_entry.config(bg=second_color)
       
        # Change the Status Bar Background
        status_bar.config(bg=main_color)
        status_bar_label.config(bg=main_color, fg=text_color)
        # Update the status bar message
        status_bar_label.config(text="Default color scheme restored       ")                
        # Schedule a task to reset the status bar message after 3 seconds (3000 milliseconds)
        window.after(3000, lambda: status_bar_label.config(text="Ready       "))
        
        search_bar.config(bg=main_color)
        search_bar_button_frame_left.config(bg=main_color)
        search_bar_button_frame_right.config(bg=main_color)
        search_label.config(bg=main_color, fg=text_color)           

        create_text_line_numbers(linenumbers_canvas, text, text_color)

        # Update the colors of Search bar buttons                
        update_search_bar_colors()
        # Update the colors of toolbar buttons when a color scheme is deactivated
        update_toolbar_button_colors()

    # Update the "Choose Custom Palette" checkbutton to reflect its state
    custom_palette_var.set(custom_palette_active)

def update_text_widget_color():
    active_scheme_names = [name for name, var in checkbutton_vars.items() if var.get()]

    if custom_color:
        text_widget.config(bg=custom_color)
    elif night_mode_var.get():
        text_widget.config(bg=color_schemes["Night Mode"]["second_color"])
    elif not active_scheme_names:
        text_widget.config(bg=color_schemes["Default"]["second_color"])
    else:
        active_color = None
        for name in active_scheme_names:
            if name in color_schemes:
                active_color = color_schemes[name]["second_color"]
                break

        if active_color:
            text_widget.config(bg=active_color)
        else:
            text_widget.config(bg=default_color_scheme["Default"]["second_color"])

custom_color = None

def choose_custom_palette(*args):
    global custom_color

    if custom_palette_var.get():
        chosen_color = colorchooser.askcolor(title="Choose Custom Palette")[1]

        if chosen_color:
            custom_color = chosen_color
            text.config(bg=custom_color)  # Change the background color to the custom color
            search_entry.config(bg=custom_color) # Change the background color of the search bar text box
            
        else:
            custom_color = None
    else:
        custom_color = None
        update_text_widget_color()  # Restore the appropriate background color
        search_entry.config(bg=second_color)  # Revert the background color of the search bar text box
           
highlight_enabled = False

def toggle_line_highlighting():
    if highlighting.get() == True:
        def highlight_current_line(interval=100):
            text.tag_remove("current_line", 1.0, "end")
            text.tag_add("current_line", "insert linestart", "insert lineend+1c")
            text.after(interval, highlight_current_line)
        highlight_current_line()
        text.tag_configure("current_line", background="#e9e9e9", selectbackground="#999999") 

    else:
        global highlight_enabled
        highlight_enabled = False
        
        text.tag_remove("current_line", 1.0, "end")
        text.tag_configure("current_line", background="white", selectbackground="yellow")
        text.tag_add("current_line", 1.0, "end")        

def toggle_linenumbers():
    if linenumbers_button_var.get():
        linenumbers_canvas.grid(row=1, column=0, sticky="NS")
        window.grid_rowconfigure(0, weight=0, minsize=0)
        window.grid_rowconfigure(1, weight=1, minsize=0)
    else:
        linenumbers_canvas.grid_forget()

def word_wrap():
    if word_wrap_checkbutton_var.get() == True:
        text.config(wrap="word")
        update_status_bar_message(new_message="Word Wrap On     ")
    else:
        text.config(wrap="none")
        update_status_bar_message(new_message="Word Wrap Off     ")   

def create_menu(window):
    # Create menu_bar
    menu_bar = Menu(window)
    window.config(menu=menu_bar)

    # Add Format Menu heading to the menu_bar
    format_menu = Menu(menu_bar, tearoff=False)
    menu_bar.add_cascade(label="Format", menu=format_menu)

    format_menu.add_command(label="Selected Text Color", command=selected_text_color)
    format_menu.add_command(label="All Text Color", command=all_text_color)
    format_menu.add_command(label="Background Color", command=background_color)
    format_menu.add_separator()
    format_menu.add_command(label="Bold", command=bold_it)
    format_menu.add_command(label="Italics", command=italics_it)
    format_menu.add_command(label="Underline", command=underline_it)
    format_menu.add_command(label="Strike", command=strike_it)

    # Add Options Menu heading to the menu_bar 
    options_menu = Menu(menu_bar, tearoff=0)
    menu_bar.add_cascade(label="Options", menu=options_menu)
 
    # Create a BooleanVar for the 'Night Mode' 
    global night_mode_var  
    night_mode_var = BooleanVar()
    checkbutton_vars["Night Mode"] = night_mode_var
    
    # Add a checkbutton for "Night Mode" color scheme in the Options menu
    options_menu.add_checkbutton(
        label="Night Mode",
        variable=checkbutton_vars["Night Mode"],
        command=lambda: checkbutton_selected("Night Mode"))
  
    # Create a BooleanVar for the "Night Mode" checkbutton
    default_mode_var = BooleanVar(value=True)
    checkbutton_vars["Default"] = default_mode_var
    
    # Add a checkbutton for "Night Mode" color scheme in the Options menu
    options_menu.add_checkbutton(
        label="Default Color Scheme",
        variable=checkbutton_vars["Default"],
        onvalue=True, 
        offvalue=False,
        command=lambda: checkbutton_selected("Default"))

    # Create a submenu for Color Schemes
    color_scheme_submenu = Menu(options_menu, tearoff=False)

    # Add the submenu to the Options Menu
    options_menu.add_cascade(label="Color Schemes", menu=color_scheme_submenu)

    # Toggles each individual color scheme on or off 
    # Create Color Scheme checkbuttons in a submenu of the Options menu
    for scheme_name in color_schemes:
        if scheme_name != "Default" and scheme_name != "Night Mode":
            var = BooleanVar()
            checkbutton_vars[scheme_name] = var     #MUST be inside for loop
            color_scheme_submenu.add_checkbutton(
                label=scheme_name,
                variable=var,
                command=lambda name=scheme_name: checkbutton_selected(name))

    # Change the background color of the Text Widget 
    global custom_palette_var
    custom_palette_var = BooleanVar()
    
    # Add an entry for "Choose Custom Palette" to the Options men
    options_menu.add_checkbutton(label="Choose Custom Palette",
        variable=custom_palette_var, 
        command=lambda: choose_custom_palette() if custom_palette_var.get() else choose_custom_palette(None))

    options_menu.add_separator()

    # Toggle line highlighting on and off
    global highlighting
    highlighting = BooleanVar()
    
    # Add a checkbutton for "Line Highlighting" in the Options menu
    options_menu.add_checkbutton(
        label="Line Highlighting", 
        variable=highlighting,
        onvalue=True, 
        offvalue=False, 
        command=toggle_line_highlighting)
    
    # Toggle line numbering on and off
    global linenumbers_button_var
    linenumbers_button_var = BooleanVar(value=True)

    # Add a checkbutton for "Show Line Numbers" in the Options menu
    options_menu.add_checkbutton(
        label="Show Line Numbers",
        variable=linenumbers_button_var,
        onvalue=True,
        offvalue=False,
        command=toggle_linenumbers)   
    
    # Toggle Status Bar Visibility on and off
    global status_bar_checkbutton_var
    # Create variable for status bar checkbutton
    status_bar_checkbutton_var = BooleanVar(value=True)  # Word Wrap is activated by default

    # Create check button for the Status Bar in the Options menu
    status_bar_checkbutton = options_menu.add_checkbutton(
        label="Status Bar", 
        variable=status_bar_checkbutton_var,
        onvalue=True,
        offvalue=False,        
        command=toggle_status_bar)   
    
    # Toggle Word Wrap on and off
    global word_wrap_checkbutton_var
    # Create variable for word wrap checkbutton 
    word_wrap_checkbutton_var = BooleanVar(value=False)  # Word Wrap is deactivated by default
    
    # Create check button for Word Wrap in the Options menu
    options_menu.add_checkbutton(
        label="Word Wrap",
        variable=word_wrap_checkbutton_var,
        onvalue=True,
        offvalue=False,
        command=word_wrap)    
   
    # Create "Search" heading in the menu_bar
    search_menu = Menu(menu_bar, tearoff=False)
    menu_bar.add_cascade(label="Search", menu=search_menu)

    # Toggle Search Bar visibility on and off
    global search_bar_checkbutton_var
    # Create variable for word wrap checkbutton 
    search_bar_checkbutton_var = BooleanVar(value=False)  # Search Bar is deactivated by default
    
    # Create check button for search bar in the search menu    
    search_bar_checkbutton = search_menu.add_checkbutton(
        label="Search", 
        variable=search_bar_checkbutton_var, 
        onvalue=True,
        offvalue=False,
        command=toggle_search_bar)    

    search_menu.add_command(label="Find Next", command=find_next, accelerator="(F3)")
    search_menu.add_command(label="Clear Search Results", command=clear_find_results)

# Create the Toolbar
def create_toolbar(window):
    global bold_button
    global italics_button
    global underline_button
    global font_color_button
    global highlight_button
    global redo_button
    global undo_button
    
    def on_exit(event):
        event.widget['background'] = main_color #second_color #text_color
        event.widget['foreground'] = text_color #second_color         

    def on_enter(event):
        event.widget['background'] = text_color #second_color
        event.widget['foreground'] = main_color #second_color #text_color 

    # Create Button Groups
    global toolbar_frame

    toolbar_frame = Frame(window, bd=5, height=25, highlightthickness=0)  
    toolbar_frame.grid(row=0, column=1, columnspan=2, sticky="nw")
    toolbar_frame.config(padx=0, pady=0)  

    # Start with a pair of frames to provide horizontal padding to buttons

    global tool_bar_button_frame_left
    # Contains bold_button, italics_button, underline_button   
    tool_bar_button_frame_left = Frame(toolbar_frame, bg=main_color)
    tool_bar_button_frame_left.configure(bg=main_color) 
    tool_bar_button_frame_left.grid(row=0, column=1, padx=0, pady=0, sticky="w")
    # Leave tool_bar_button_frame_left padx at 0 to keep buttons flush with the text widget.

    global tool_bar_button_frame_center
    # Contains search_all_button
    tool_bar_button_frame_center = Frame(toolbar_frame, bg=main_color)
    tool_bar_button_frame_center.configure(bg=main_color) 
    tool_bar_button_frame_center.grid(row=0, column=2, padx=15, pady=0, sticky="w")

    global tool_bar_button_frame_right
    # Contains search_all_button
    tool_bar_button_frame_right = Frame(toolbar_frame, bg=main_color)
    tool_bar_button_frame_right.configure(bg=main_color) 
    tool_bar_button_frame_right.grid(row=0, column=3, padx=15, pady=0, sticky="w")

    # Add Buttons to Toolbar Frame
   
    # Bold Button
    bold_button = Button(tool_bar_button_frame_left, text="B", font=("Helvetica", 12, "bold"), 
                         bd=0, padx=5, pady=5, command=bold_it, relief="flat", borderwidth=0)
    bold_button.config(bg=main_color, fg=text_color, 
                       highlightbackground=main_color, highlightcolor=selection_highlight)
    bold_button.pack(side="left", padx=2, pady=2)
    bold_button.bind("<Enter>", on_enter)
    bold_button.bind("<Leave>", on_exit)

    # Italics Button
    italics_button = Button(tool_bar_button_frame_left, text="I", font=("Helvetica", 12, "italic"),
                           bd=0, padx=5, pady=5, command=italics_it, relief="flat", borderwidth=0)
    italics_button.config(bg=main_color, fg=text_color, 
                       highlightbackground=main_color, highlightcolor=selection_highlight)
    italics_button.pack(side="left", padx=2, pady=2)
    italics_button.bind("<Enter>", on_enter)
    italics_button.bind("<Leave>", on_exit)

    # Underline Button
    underline_button = Button(tool_bar_button_frame_left, text="U", font=("Helvetica", 12, "underline"),
                              bd=0, padx=5, pady=5, command=underline_it, relief="flat", borderwidth=0)
    underline_button.config(bg=main_color, fg=text_color, 
                       highlightbackground=main_color, highlightcolor=selection_highlight)
    underline_button.pack(side="left", padx=2, pady=2)
    underline_button.bind("<Enter>", on_enter)
    underline_button.bind("<Leave>", on_exit)

    # Font Color
    font_color_button = Button(tool_bar_button_frame_center, text="Font Color",
                               bd=0, padx=5, pady=5, command=selected_text_color, relief="flat", borderwidth=0)
    font_color_button.config(bg=main_color, fg=text_color, 
                       highlightbackground=main_color, highlightcolor=selection_highlight)
    font_color_button.pack(side="left", padx=2, pady=2)
    font_color_button.bind("<Enter>", on_enter)
    font_color_button.bind("<Leave>", on_exit)    

	   
    highlight_button = Button(tool_bar_button_frame_center, text="Highlight",
                              bd=0, padx=5, pady=5, command=background_color, relief="flat", borderwidth=0)
    highlight_button.config(bg=main_color, fg=text_color, 
                       highlightbackground=main_color, highlightcolor=selection_highlight)
    highlight_button.pack(side="left", padx=2, pady=2)
    highlight_button.bind("<Enter>", on_enter)
    highlight_button.bind("<Leave>", on_exit)
    
    # Redo Button
    redo_button = Button(tool_bar_button_frame_right, text="Redo",
                         bd=0, padx=5, pady=5, command=text.edit_redo, relief="flat", borderwidth=0)
    redo_button.pack(side="left", padx=2, pady=2)
    redo_button.config(bg=main_color, fg=text_color,
                       highlightbackground=main_color, highlightcolor=selection_highlight)
    redo_button.bind("<Enter>", on_enter)
    redo_button.bind("<Leave>", on_exit)

    # Undo Button
    undo_button = Button(tool_bar_button_frame_right, text="Undo", 
                         bd=0, padx=5, pady=5, command=text.edit_undo, relief="flat", borderwidth=0)
    undo_button.config(bg=main_color, fg=text_color, 
                       highlightbackground=main_color, highlightcolor=selection_highlight)
    undo_button.pack(side="left", padx=2, pady=2)
    undo_button.bind("<Enter>", on_enter)
    undo_button.bind("<Leave>", on_exit)

    
    # Set the weight of row 0 and row 1 to 1, so that they both expand evenly
    window.grid_rowconfigure(0, weight=1)
    
def create_bindings(window):    
    # ***************** Search Bindings ***************** #
    # Note: search_entry.bind("<Return>" will not result in persistant highlighting     

    # Keyboard shortcut to open Search Bar 
    window.bind("<Control-F>", lambda event: toggle_search_bar())
    window.bind("<Control-f>", lambda event: toggle_search_bar()) 

    # Keyboard shortcut to close Search Bar 
    search_entry.bind("<KeyRelease-Escape>", toggle_search_bar)
    
    # Keyboard shortcuts to Search without pressing a button
    search_entry.bind("<KeyRelease-Return>", lambda event: find_all())

    # Keyboard shortcut to find the next occurrence (F3)
    # window.bind("<F3>", find_next) # No lambda results in "TypeError: find_next() takes 0 positional arguments but 1 was given"
    window.bind("<KeyRelease-F3>", lambda event: find_next())
    
    # Keyboard shortcut to find the previous occurrence (Shift+F3)
    window.bind("<Shift-F3>", find_previous)
    # window.bind("<KeyRelease-Shift-F3>", lambda event: find_previous())  
    
    # Clear search results with clear_find_results upon entering new text in widget
    search_entry.bind("<KeyRelease>", clear_find_results)
    # Keyboard shortcut to clear Search Results
    search_entry.bind("<Escape>", clear_find_results)

def create_window():
    global window
    
    window = Tk()
    window.title("Text Editor")
    window.geometry("1200x690")
    window.resizable(True,True)

    window.grid_columnconfigure(1, weight=1)
    window.grid_rowconfigure(0, weight=0, minsize=0)
    window.grid_rowconfigure(1, weight=1, minsize=0)

    global linenumbers_canvas
    linenumbers_canvas = Canvas(window, width=40, highlightthickness=0)	
																						   
    linenumbers_canvas.grid(row=1, column=0, sticky="NS")
    window.grid_rowconfigure(1, minsize=linenumbers_canvas.winfo_reqheight())    

    linenumbers_canvas.grid_propagate(False)
    linenumbers_canvas.configure(width=30)

    # Create text widget
    global text_widget
    text_widget = create_custom_text(window, linenumbers_canvas)   
    text_widget.insert("end", "Type some text here...")

    text.insert("end", "one\ntwo\nthree\n")
    text.insert("end", "four\n", ("bigfont",))
    text.insert("end", "five\nsecond two\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n")
    text.insert("end", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nthree two")
    text.insert("end", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfour two")
    text.insert("end", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfive two")
    text.tag_configure("bigfont", font=("Helvetica", "24", "bold")) 

    create_search_bar(window)
    create_status_bar(window)
    create_menu(window)
    create_toolbar(window)
    update_toolbar_button_colors()
    toggle_linenumbers()
    toggle_status_bar()
    create_bindings(window)
    window.mainloop()

if __name__ == "__main__":
    create_window()

