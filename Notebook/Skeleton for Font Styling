"""
Having abandoned my attempt to create a Wordpad clone due to a lack of updated
.rtf libraries for Python 3.x, I now need to rethink how I will be styling the
text in my Tkinter text widget in such a way that it can still be easily converted
to a .docx file format with a straightforward function.  This code is my testbed
for creating that code without metaphorcially ripping up the floorboards on my 
current Notepad project.
"""

# This code is a fork of Text-Editor by Singamandeep
# https://github.com/singamandeep/Text-Editor
# I'm only interested in how he wrote the font tool bar


# Stripping code back down to only font and size comboboxes in an attempt
# to figure out why the font combobox isn't updating!


from tkinter import *
from tkinter import filedialog 
from tkinter import font
from tkinter import colorchooser
from tkinter import messagebox
from tkinter import simpledialog
import ttk

import numpy as np
import os
import PIL
from PIL import Image, ImageTk
import re # For finding font attributes to update Font and Size combo boxes
import uuid # For unique text tags in make_tag Function
# a 36-character alphanumeric string that can be used to identify information

root = Tk()
root.geometry("600x550")

# setting resizable window
root.resizable(True, True)
root.minsize(600, 550) # minimimum size possible

# MAIN MENU METHODS 
global current_tags
current_tags = []
global last_selection
last_selection = None

def remove_all_formatting_tags():
    global last_selection
    # Get all current tags related to formatting
    formatting_tags = ["bold", "italic", "underline", "overstrike", 
                       "background_color", "font_color",
                       "current_font_family", "current_font_size"]

    # Clear all formatting tags from the text widget
    for tag in current_tags:
        if tag in formatting_tags:
            current_tags.remove(tag)

def make_tag():
    global last_selection

    # Check if any text is selected
    if text.tag_ranges("sel"):
        # Get the tags applied to the selected text
        current_tags = text.tag_names("sel.first")

        # Remove fontColor and fontBackground from current_tags
        for tag in ["font_color_change", "background_color_change"]:
            if tag in current_tags:
                current_tags.remove(tag)

        # Determine font weight, slant, underline, and overstrike
        weight = "bold" if "bold" in current_tags else "normal"
        slant = "italic" if "italic" in current_tags else "roman"
        underline = 1 if "underline" in current_tags else 0
        overstrike = 1 if "overstrike" in current_tags else 0

        # Generate a unique tag for the selected text
        tag_name = "font_" + str(uuid.uuid4())
        text.tag_add(tag_name, "sel.first", "sel.last")

        # Configure the tag with the desired font and style attributes
        text.tag_configure(tag_name, font=(current_font_family, current_font_size, weight, slant),
                           underline=underline, overstrike=overstrike,
                           foreground=fontColor, background=fontBackground)

        # Print each configured tag
        print("Configured tags:")
        for tag in text.tag_names("sel.first"):
            print(tag)

        # Retrieve the font family associated with the tag
        font_family = text.tag_cget(tag_name, "font")[0]

        # Print the font family associated with the tag
        print("Font family:", font_family)

        # Check if the user is highlighting a new passage of text
        current_selection = text.tag_ranges("sel")

        if current_selection != last_selection:
            # Remove previous formatting tags from the selected range
            for tag in current_tags:
                if tag != "sel":  # Skip the "sel" tag
                    text.tag_remove(tag, "sel.first", "sel.last")
            last_selection = current_selection
    else:
        # Alert the user that no text has been selected
        messagebox.showinfo("alert", "No text has been selected")


# FORMAT BAR METHODS
def change_font(event): # current_font_family
    # Get the selected font family from the combobox
    selected_font_family = all_fonts.get()

    # Check if any text is selected
    if text.tag_ranges("sel"):
        # Remove previous font family tags from the selected range
        for tag in text.tag_names("sel.first"):
            if tag == "font_family":
                text.tag_remove(tag, "sel.first", "sel.last")

        # Apply font family tag to the selected text
        font_family_tag = "font_family_" + selected_font_family
        text.tag_add(font_family_tag, "sel.first", "sel.last")

        # Configure the font family tag
        text.tag_configure(font_family_tag, font=(selected_font_family, current_font_size))
    else:
        # Alert the user that no text has been selected
        messagebox.showinfo("alert", "No text has been selected")
        

def change_size(event):
    # Get the selected font size from the combobox
    selected_font_size = int(all_size.get())

    # Check if any text is selected
    if text.tag_ranges("sel"):
        # Remove previous font size tags from the selected range
        for tag in text.tag_names("sel.first"):
            if tag == "font_size":
                text.tag_remove(tag, "sel.first", "sel.last")

        # Apply font size tag to the selected text
        font_size_tag = "font_size_" + str(selected_font_size)
        text.tag_add(font_size_tag, "sel.first", "sel.last")

        # Configure the font size tag
        text.tag_configure(font_size_tag, font=(current_font_family, selected_font_size))
    else:
        # Alert the user that no text has been selected
        messagebox.showinfo("alert", "No text has been selected")


# FORMATTING BAR
formattingbar = Frame(root, padx=2, pady=2)

# FORMATTING BAR COMBOBOX - FOR FONT AND SIZE
# font combobox
all_fonts = StringVar()

# Get all font families
font_families = font.families()

# Set default font
default_font = "Arial" 

if default_font in font_families:
    all_fonts.set(default_font)
else:
    all_fonts.set(font_families[0])  # Set the first available font as default

font_menu = ttk.Combobox(formattingbar, textvariable=all_fonts, state="readonly")
font_menu.pack(side="left", padx=4, pady=4)
font_menu['values'] = font_families
font_menu.bind('<<ComboboxSelected>>', change_font)

# size combobox
all_size = StringVar()
# Initialize the StringVar with a large enough value to hold font sizes up to 999
#all_size = StringVar(value='12')

size_menu = ttk.Combobox(formattingbar, textvariable=all_size , state='readonly', width=5)
size_menu.pack(in_=formattingbar, side="left", padx=4, pady=4)
size_menu['values'] = (10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30)
size_menu.bind('<<ComboboxSelected>>', change_size)
size_menu.current(1)


# CREATING TEXT AREA - FIRST CREATED A FRAME AND THEN APPLIED TEXT OBJECT TO IT.
text_frame = Frame(root, borderwidth=1, relief="sunken")
text = Text(wrap="word", font=(default_font, 12), background="white", borderwidth=0, highlightthickness=0 , undo= True)
text.pack(in_=text_frame, side="left", fill="both", expand=True) # pack text object.


# Text for Debugging
text.insert("end", "This first sentence tests the bold formatting feature.\n")
text.insert("end", "\n")
text.insert("end", "This second sentence tests the italics formatting feature.\n")
text.insert("end", "\n")
text.insert("end", "This third sentence demonstrates the ability to underline words.\n")
text.insert("end", "\n")


# PACK TOOLBAR, FORMATBAR, STATUSBAR AND TEXT FRAME.
formattingbar.pack(side="top", fill="x")
text_frame.pack(side="bottom", fill="both", expand=True)
text.focus_set()


def get_font_family(tag_name):
    if text.tag_configure(tag_name):
        # Get the font configuration
        font_tuple = text.tag_cget(tag_name, "font")
        if font_tuple:
            # Extract the font family from the font configuration tuple
            font_family = font_tuple[0]
            return font_family
    return None


def update_font_combobox(event):
    # Get the index of the clicked position
    cursor_pos = text.index("@{},{}".format(event.x, event.y))

    # Get the tag names associated with the cursor position
    tag_names = text.tag_names(cursor_pos)

    if tag_names:
        # Get the font family associated with the first tag name
        font_family = get_font_family(tag_names[0])

        if font_family:
            # Set the font combobox to display the font family
            all_fonts.set(font_family)


# Bind the update_font_combobox function to the mouse click event on the text widget
text.bind("<Button-1>", update_font_combobox)



def get_font_size(tag_name):
    if text.tag_configure(tag_name):
        # Get the font configuration
        font_tuple = text.tag_cget(tag_name, "font")
        if font_tuple:
            for item in font_tuple:
                if isinstance(item, int) or (isinstance(item, str) and item.isdigit()):
                    return int(item)
    return None



# I'm now using a regular expression (\d+) to find the font size in the font attribute so that it doesn't get truncated in the combobox.
def update_size_combobox(event):
    # Get the index of the clicked position
    cursor_pos = text.index("@{},{}".format(event.x, event.y))

    # Get the tag names associated with the cursor position
    tag_names = text.tag_names(cursor_pos)    

    if tag_names:
        # Get the font attribute configured for the clicked position
        font_attr = text.tag_cget(tag_names[0], "font")

        # Check that the font attribute is not empty and contains both font family and size
        if font_attr:
            # Use regular expression (\d+) to find the font size in the font attribute
            font_size_match = re.search(r'\d+', font_attr)

            if font_size_match:
                # Extract the font size from the matched string
                font_size = font_size_match.group()

                # Set the font size combobox to display the font size
                all_size.set(font_size)


# Bind the update_size_combobox function to the mouse click event on the text widget
text.bind("<Button-1>", update_size_combobox)


# MAINLOOP OF THE PROGRAM
root.mainloop()

