{
	"All Tokens":{
		" ": {
			"name":" ",
			"description": " ",
			"sample_expression": " ",
			"sample_result": " "
		}
	},
	"Anchors":{
		"^":{
			"name":"Beginning",
			"description":"Matches the beginning of the string, or the beginning of a line if the multiline flag (m) is enabled.",
			"sample_expression":"^\\w+",
			"sample_result":"[she] sells seashells"
		},
		"$":{
			"name":"End",
			"description":"Matches the end of the string, or the end of a line if the multiline flag (m) is enabled. ",
			"sample_expression":"\\w+$",
			"sample_result":"she sells [seashells]"
		},
		"\\A": {
			"name": "Start of String",
			"description": "Matches the beginning of the string, regardless of multiline mode.",
			"sample_expression": "Hello World\nHello Again",
			"sample_result": "[H]ello World\nHello Again"
		},
		"\\b":{
			"name":"Word Boundary",
			"description":"Matches a word boundary position between a word character and non-word character.",
			"sample_expression":"s\\b",
			"sample_result":"she sell[s] seashell[s]"
		},
		"\\B":{
			"name":"Not Word Boundary",
			"description":"Non-word boundary",
			"sample_expression":"s\\B",
			"sample_result":"she sells sea[s]hells"
		},
		"\\G": {
			"name": "Start of Match",
			"description": "Matches the position where the previous match ended, or the start of the string if no previous match.",
			"sample_expression": "apple orange banana apple",
			"sample_result": "[apple] orange banana apple"
		},
		"\\z": {
			"name": "Absolute End of String",
			"description": "Matches the very end of the string, ignoring multiline mode.",
			"sample_expression": "Hello World\nHello Again",
			"sample_result": "Hello World\nHello Agai[n]"
		},
		"\\Z": {
			"name": "End of String (Before Final Newline)",
			"description": "Matches the end of the string, but before a final newline (if one exists).",
			"sample_expression": "Hello World\nHello Again\n",
			"sample_result": "Hello World\nHello Agai[n]\n"
		}
	},
	"Character Classes":{
		"a?": {
			"name": "Optional Match",
			"description": "Matches zero or one occurrences of 'a'.",
			"sample_expression": "bat bt",
			"sample_result": "b[a]t b[]t"
		},
		"a*": {
			"name": "Zero or More",
			"description": "Matches zero or more occurrences of 'a'.",
			"sample_expression": "baaaat bt",
			"sample_result": "b[aaaa]t b[]t"
		},
		"a+": {
			"name": "One or More",
			"description": "Matches one or more occurrences of 'a'.",
			"sample_expression": "baaaat bt",
			"sample_result": "b[aaaa]t bt"
		},
		"a{3}": {
			"name": "Exact Quantifier",
			"description": "Matches exactly 3 occurrences of 'a'.",
			"sample_expression": "baaaat",
			"sample_result": "b[aaa]at"
		},
		"a{3,}": {
			"name": "At Least Quantifier",
			"description": "Matches 3 or more occurrences of 'a'.",
			"sample_expression": "baaaaat",
			"sample_result": "b[aaaaa]t"
		},
		"a{3,6}": {
			"name": "Range Quantifier",
			"description": "Matches between 3 and 6 occurrences of 'a'.",
			"sample_expression": "baaaaaaat",
			"sample_result": "b[aaaaaa]at"
		},
		"a|b":{
			"name":"Alternation",
			"description":"Match either a or b",
			"sample_expression":"b(a|e|i)d",
			"sample_result":"[bad] bud bod [bed] [bid]"
		},
		"[abc]":{
			"name":"Character Set",
			"description":"Match a single character present in the set",
			"sample_expression":"[aeiou]",
			"sample_result":"gl[i]b j[o]cks v[e]x dw[a]rv[e]s!"
		},
		"[^abc]":{
			"name":"Negated Character Set",
			"description":"Match a single character NOT present in the set",
			"sample_expression":"[^aeiou]",
			"sample_result":"[gl]i[b j]o[cks v]e[x dw]a[rv]e[s!]"
		},
		"[a-z]": {
			"name": "Lowercase Letter Range",
			"description":"Matches a character between two specified characters inclusive.",
			"sample_expression":"[g-s]",
			"sample_result":"abcdef[ghijklmnopqrs]tuvwxyz"
		},
		"[A-Z]": {
			"name": "Uppercase Letter Range",
			"description": "Matches any uppercase letter from 'A' to 'Z'.",
			"sample_expression": "[A-Z]",
			"sample_result": "Matches 'G' in 'Great'"
		},
		"[a-zA-Z]": {
			"name": "Alphabetic Range",
			"description":"Match a single character in the range a-z or A-Z",
			"sample_expression":"[xyzABC]",
			"sample_result":"[A]a[B]b[C]cDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwX[x]Y[y]Z[z]"
		},
		"[^a-z]": {
			"name": "Negated Lowercase Range",
			"description":"Match a single character NOT between two specified characters",
			"sample_expression":"[g-s]",
			"sample_result":"[abcdef]ghijklmnopqrs[tuvwxyz]"
		},
		"[0-9]": {
			"name": "Digit Range",
			"description": "Matches any digit from 0 to 9.",
			"sample_expression": "[0-9]",
			"sample_result": "Matches '4' in '42'"
		},
		"\\b":{
			"name":"",
			"description":"A word boundary",
			"sample_expression":"",
			"sample_result":""
		},
		"\\B":{
			"name":"",
			"description":"Non-word boundry",
			"sample_expression":"",
			"sample_result":""
		},
		
		"\\d":{
			"name": "Digit Shortcut",
			"description":"Match any digit character (0 -9). Equivalent to [0-9].",
			"sample_expression":"(555) 555-5555",
			"sample_result":"Phone: ([555]) [555]-[5555]"
		},
		"\\D":{
			"name": "Non-Digit Shortcut",
			"description":"Match any non-digit character. Equivalent to [^0-9].",
			"sample_expression":"(555) 555-5555",
			"sample_result":"[Phone:] [(]555[)] 555[-]5555"
		},
		"\\p{}":{
			"name":"Unicode Script",
			"description":"Matches any character in specified unicode script.",
			"sample_expression":"",
			"sample_result":"Character sets include Arabic, Armenian, Bengali, Cherokee, Cyrillic, Greek, Hebrew, Japanese, Korean, Latin, Thai"
		},
		"\\P{}":{
			"name":"Not Unicode Script",
			"description":"Matches any character not in specified unicode script.",
			"sample_expression":"",
			"sample_result":""
		},		
		"\\p{L}": {
			"name": "Unicode Category: Letter",
			"description": "Matches any letter character from any language.",
			"sample_expression": "\\p{L}+",
			"sample_result": "[Hello] [你好] 123"
		},
		"\\P{L}": {
			"name": "Unicode Category: Not Letter",
			"description": "Matches any character that is not a letter.",
			"sample_expression": "\\P{L}+",
			"sample_result": "Hello 你好 [123]"
		},
		"\\p{Ll}":{
			"name": "Unicode Category: Lowercase Letter",
			"description": "Matches any lowercase letter character from any language.",
			"sample_expression": "Regex: '\\p{Ll}+' - Text: 'Hello world, привет мир!'",
			"sample_result": "[world] [привет] [мир]"
		},
		"\\p{Han}": {
			"name": "Unicode Script: Han",
			"description": "Matches any Han character (used in Chinese, Japanese, and Korean).",
			"sample_expression": "\\p{Han}+",
			"sample_result": "Hello [你好] 123"
		},
		"\\P{Han}": {
			"name": "Unicode Script: Not Han",
			"description": "Matches any character that is not a Han character.",
			"sample_expression": "\\P{Han}+",
			"sample_result": "[Hello ]你好 [123]"
		},
		"\\s":{
			"name": "Whitespace Character",
			"description":"Match any whitespace character",
			"sample_expression":"\\s",
			"sample_result":"Hello[ ]World!"
		},
		"\\S":{
			"name": "Non-Whitespace Character",
			"description":"Match any non-whitespace character",
			"sample_expression":"\\S",
			"sample_result":"[Hello] [World!]"
		},		
		"[\\s\\S]":{
			"name":"Match Any",
			"description":"A character set that can be used to match any character, including line breaks, without the dotall flag (s).",
			"sample_expression":"[\\s\\S]",
			"sample_result":"[glib jocks vex dwarves!]"
		},
		"\\w":{
			"name":"Word",
			"description":"Match any low-ascii character or underscore. Equivalent to [A-Za-z0-9_].",
			"sample_expression":"bonjour, mon frère",
			"sample_result":"[bonjour], [mon] [fr]è[re]"
		},
		"\\W":{
			"name": "Non-Word Character",
			"description":"Match any non-word character. Equivalent to [^A-Za-z0-9_].",
			"sample_expression":"bonjour, mon frère",
			"sample_result":"bonjour[, ]mon[ ]fr[è]re"
		},
		".":{
			"name":"Match Any Character",
			"description":"Match any character except line terminators (linebreaks). Equivalent to [^\\n\\r].",
			"sample_expression":".",
			"sample_result":"[glib jocks vex dwarves!]"
		},
		"(?:...)":{
			"name": "Non-Capturing Group",
			"description": "Groups part of a pattern without capturing it for back-references.",
			"sample_expression": "(?:cat|dog)",
			"sample_result": "I have a [cat] and a [dog]."
		},                
		"(...)":{
			"name": "Capturing Group",
			"description": "Groups part of a pattern and captures it for back-references.",
			"sample_expression":"(\\d+) (Captures one or more digits.)",
			"sample_result": "My number is [12345]."
		},
		"^": {
			"name": "Start of Line",
			"description": "Matches the start of a string or line.",
			"sample_expression": "Hello world",
			"sample_result": "[Hello] world"
		},
		"$": {
			"name": "End of Line",
			"description": "Matches the end of a string or line.",
			"sample_expression": "Hello world",
			"sample_result": "Hello [world]"
		},
		"[[:alnum:]]": {
			"name": "Alphanumeric",
			"description": "Matches any letter or digit.",
			"sample_expression": "[[:alnum:]]",
			"sample_result": "Matches 'A' in 'A1'"
		},
		"[[:alpha:]]": {
			"name": "Alphabetic",
			"description": "Matches any letter.",
			"sample_expression": "[[:alpha:]]",
			"sample_result": "Matches 'B' in 'Beta'"
		},
		"[[:ascii:]]": {
			"name": "ASCII Characters",
			"description": "Matches any ASCII character (codes 0-127).",
			"sample_expression": "[[:ascii:]]",
			"sample_result": "Matches '$' in '$100'"
		},
		"[[:blank:]]": {
			"name": "Space or Tab",
			"description": "Matches only space or tab characters.",
			"sample_expression": "[[:blank:]]",
			"sample_result": "Matches tab in 'Name\tAge'"
		},
		"[[:cntrl:]]": {
			"name": "Control Characters",
			"description": "Matches control characters like newlines and tabs.",
			"sample_expression": "[[:cntrl:]]",
			"sample_result": "Matches newline in 'Hello\\nWorld'"
		},
		"[[:digit:]]": {
			"name": "Digits",
			"description": "Matches any numeric digit (equivalent to \\d).",
			"sample_expression": "[[:digit:]]",
			"sample_result": "Matches '3' in '3rd'"
		},
		"[[:graph:]]": {
			"name": "Visible Characters",
			"description": "Matches any character except spaces.",
			"sample_expression": "[[:graph:]]",
			"sample_result": "Matches '!' in 'Hello!' but not space in 'Hello World'"
		},
		"[[:lower:]]": {
			"name": "Lowercase Letters",
			"description": "Matches any lowercase letter.",
			"sample_expression": "[[:lower:]]",
			"sample_result": "Matches 'g' in 'guitar'"
		},
		"[[:print:]]": {
			"name": "Printable Characters",
			"description": "Matches any visible character including spaces.",
			"sample_expression": "[[:print:]]",
			"sample_result": "Matches 'A' in 'ABC' and space in 'Hello World'"
		},
		"[[:punct:]]": {
			"name": "Punctuation Characters",
			"description": "Matches any punctuation mark.",
			"sample_expression": "[[:punct:]]",
			"sample_result": "Matches '?' in 'What?'"
		},
		"[[:space:]]": {
			"name": "Whitespace",
			"description": "Matches any whitespace character.",
			"sample_expression": "[[:space:]]",
			"sample_result": "Matches space in 'hello world'"
		},
		"[[:upper:]]": {
			"name": "Uppercase Letters",
			"description": "Matches any uppercase letter.",
			"sample_expression": "[[:upper:]]",
			"sample_result": "Matches 'Z' in 'Zebra'"
		},
		"[[:word:]]": {
			"name": "Word Characters",
			"description": "Matches any letter, digit, or underscore.",
			"sample_expression": "[[:word:]]",
			"sample_result": "Matches 'C' in 'Code_123'"
		},
		"[[:xdigit:]]": {
			"name": "Hexadecimal Digits",
			"description": "Matches any valid hexadecimal digit (0-9, A-F, a-f).",
			"sample_expression": "[[:xdigit:]]",
			"sample_result": "Matches 'F' in 'FF00FF'"
		},
		"[[:<:]]": {
			"name": "Start of Word",
			"description": "Matches the start of a word boundary.",
			"sample_expression": "[[:<:]]word",
			"sample_result": "Matches 'word' at the start of a word"
		},
		"[[:>:]]": {
			"name": "End of Word",
			"description": "Matches the end of a word boundary.",
			"sample_expression": "word[[:>:]]",
			"sample_result": "Matches 'word' at the end of a word"
		}
	},
	"Escaped Characters":{
		"\\": {
			"name":"Reserved Characters",
			"description": "Preceeds character for literal representation. (+*?^$\\.[]{}()|/)",
			"sample_expression": "\\+",
			"sample_result": "1 [+] 1 = 2"
		},
		"\\000":{
			"name":"Octal Escape",
			"description":"Octal escaped character in the form \\000. Value must be less than 255",
			"sample_expression":"\\251",
			"sample_result":"All Rights Reserved [©]2025"
		},
		"\\xFF":{
			"name":"Hexadecimal Escape",
			"description":"Hexadecimal escaped character in the form \\xFF",
			"sample_expression":"\\xA9",
			"sample_result":"All Rights Reserved [©]2025"
		},
		"\\uFFFF":{
			"name":"Unicode Escape",
			"description":"Unicode escaped character in the form \\uFFFF",
			"sample_expression":"\u00A9",
			"sample_result":"All Rights Reserved [©]2025"
		},
		"\\u{FFFF}":{
			"name":"Extended Unicode Escape",
			"description":"Unicode escaped character in the form \\u{FFFF}.",
			"sample_expression":"\\u{00A9}",
			"sample_result":"All Rights Reserved [©]2025. \n(Supports a full range of unicode point escapes with any number of hex digits.)"
		},
		"\\c":{
			"name":"Control Character Escape",
			"description":"Escaped control character ranging from \\cA to \\cZ.",
			"sample_expression":"\\cI",
			"sample_result":"[    ]\\cI matches TAB (char code 9)."
		},
		"\\n":{
			"name":"Line Feed",
			"description":"Matches a LINE FEED character (char code 10).",
			"sample_expression":"",
			"sample_result":""
		},
		"\\v":{
			"name":"Vertical Tabe",
			"description":"Matches a VERTICAL TAB character (char code 11).",
			"sample_expression":"",
			"sample_result":""
		}
	},
	"Flags/Modifiers":{
		"(?A)": {
			"name": "Anchored Mode",
			"description": "Forces the pattern to only match at the start of the string.",
			"sample_expression": "(?A)Hello",
			"sample_result": "[Hello] world.  Hello again!"
		},
		"g": {
			"name": "Global Search",
			"description": "Matches all occurrences, not just the first.",
			"sample_expression": "g:\\b\\w+\\b",
			"sample_result": "[hello] [world]"
		},
		"(?i)": {
			"name": "Case-Insensitive Matching",
			"description": "Makes the pattern case-insensitive.",
			"sample_expression": "(?i)world",
			"sample_result": "Hello [WORLD]"
		},
		"(?J)": {
			"name": "Duplicate Named Groups Allowed",
			"description": "Permits multiple groups to have the same name.",
			"sample_expression": "(?J)(?P<word>hello)|(?P<word>world)",
			"sample_result": "[hello]"
		},
		"(?m)": {
			"name": "Multi-line Matching",
			"description": "Allows ^ and $ to match line start and end in multi-line strings.",
			"sample_expression": "(?m)^hello",
			"sample_result": "[hello] World"
		},
		"(?n)": {
			"name": "Non-Capturing Mode",
			"description": "Makes all groups non-capturing by default.",
			"sample_expression": "(?n)(hello|world)",
			"sample_result": "[hello]"
		},
		"(?s)": {
			"name": "Dot Matches Newline",
			"description": "Allows the dot (.) to match newline characters.",
			"sample_expression": "(?s).+",
			"sample_result": "[hello\nworld]"
		},
		"(?U)": {
			"name": "Ungreedy Mode",
			"description": "Makes quantifiers lazy by default.",
			"sample_expression": "(?U).+?",
			"sample_result": "[h]"
		},
		"(?u)": {
			"name": "Unicode Mode",
			"description": "Enables Unicode support for pattern matching.",
			"sample_expression": "(?u)\\w+",
			"sample_result": "[résumé]"
		},
		"(?X)": {
			"name": "Extra Mode",
			"description": "Ignores unescaped whitespace and allows comments in patterns.",
			"sample_expression": "(?X)word # comment",
			"sample_result": "[word]"
		},
		"(?x)": {
			"name": "Verbose Mode",
			"description": "Allows regex to be written with whitespace and comments for clarity, ignoring non-escaped spaces.",
			"sample_expression": "(?x) a \\d{3} # Matches 'a' followed by 3 digits",
			"sample_result": "[a123]"
		},
		"(?xx)": {
			"name": "Verbose Mode",
			"description": "Allows whitespace and comments for readability.",
			"sample_expression": "(?xx)\\d+ # Match a number",
			"sample_result": "[123]"
		}
	},
	"General Tokens":{
		"\\0": {
			"name": "Null Character",
			"description": "Null character (Unicode character U+0000). Used in string termination in some programming languages.",
			"sample_expression": "A\\0B",
			"sample_result": "[A\\x00B]"
		},
		"\\n": {
			"name": "Newline Character",
			"description": "Match newline character (Unicode character U+000A). Represents a line break.",
			"sample_expression": "Regex: 'Line1\\nLine2' - Text: 'Line1\\nLine2'",
			"sample_result": "[Line1\\nLine2]"
		},
		"\\r": {
			"name": "Carriage Return Character",
			"description": "Match carriage return character (Unicode character U+000D)."
			"sample_expression": "Regex: 'Line1\\rLine2' - Text: 'Line1\\rLine2'",
			"sample_result": "[Line1\rLine2] \n(Often used in combination with \\n for line breaks on Windows systems.)"
		},
		"\\t": {
			"name": "Tab Character",
			"description": "Match tab character (Unicode character U+0009). Represents horizontal tabulation.",
			"sample_expression": "Regex: 'Col1\\tCol2' - Text: 'Col1\\tCol2'",
			"sample_result": "[Col1\\tCol2]"
		}
	},
	"Group Constructs":{
		"(?:...)":{
			"name":"Non-Capturing Group",
			"description":"Groups multiple tokens together without creating a capture group.",
			"sample_expression":"(?:ha)+",
			"sample_result":"[hahaha] [ha]a [ha]h!"
		},
		"(...)":{
			"name":"Capturing Group",
			"description":"Capture everything enclosed. Groups multiple tokens together and creates a capture group for extracting a substring or using a backreference.",
			"sample_expression":"(ha)+",
			"sample_result":"[hahaha] [ha]a [ha]h!"
		},        
		"(?>...)": {
			"name": "Atomic Group (Non-Capturing)",
			"description": "Matches the content inside the group but does not allow backtracking.",
			"sample_expression": "t(?>he|him)re",
			"sample_result": "[the]re but not th[him]re"
		},
		"(?|...)": {
			"name": "Duplicate/Reset Subpattern Group Number",
			"description": "Different alternatives share the same capture group number.",
			"sample_expression": "(?|cat|(dog))",
			"sample_result": "I have a [cat], and she has a [dog]."
		},
		"(?#...)": {
			"name": "Comment Group",
			"description": "Adds a comment inside a regex, ignored during matching.",
			"sample_expression": "apple(?# This is a comment) juice",
			"sample_result": "[apple juice]"
		},        
		"(?'name'...)": {
			"name": "Named Capturing Group",
			"description": "Creates a capturing group that can be referenced using 'name'.",
			"sample_expression": "(?'word'\\w+)",
			"sample_result": "[apple] [banana] [cherry]"
		},
		"(?<name>...)": {
			"name": "Named Capturing Group",
			"description": "Creates a capturing group that can be referenced via the specified name.",
			"sample_expression": "(?<word>\\w+)",
			"sample_result": "[apple] [banana] [cherry]"
		},
		"(?P<name>...)": {
			"name": "Named Capturing Group (Python)",
			"description": "Creates a named capturing group, mostly used in Python's re module.",
			"sample_expression": "(?P<word>\\w+)",
			"sample_result": "[apple] [banana] [cherry]"
		},
		"(?imsxUJnxx)": {
			"name": "Inline Modifiers",
			"description": "Enables or disables specific regex flags for the entire pattern.",
			"sample_expression": "(?i)hello",
			"sample_result": "[hello] [Hello] [HELLO] [hElLo]"
		},
		"(?imsxUJnxx:...)": {
			"name": "Localized Inline Modifiers",
			"description": "Enables or disables specific regex flags for a specific part of the pattern.",
			"sample_expression": "(?i:hello) world",
			"sample_result": "[hello world] [Hello world] [HELLO world] [hElLo world]"
		},
		"(?(1)yes|no)": {
			"name": "Conditional Statement",
			"description": "Checks if the first capturing group exists. If it does, matches 'yes'; otherwise, matches 'no'.",
			"sample_expression": "(hello)?(?(1)world|universe)",
			"sample_result": "[hello world] [universe]"
		},
		"(?(R)yes|no)": {
			"name": "Conditional Statement",
			"description": "Checks if recursion is occurring. If it is, matches 'yes'; otherwise, matches 'no'.",
			"sample_expression": "(?(R)recurse|base)",
			"sample_result": "[base] [recurse recurse recurse base]"
		},
		"(?(R#)yes|no)": {
			"name": "Recursive Conditional Statement",
			"description": "Checks if a specific numbered capturing group is recursing. If so, matches 'yes'; otherwise, matches 'no'.",
			"sample_expression": "(?:(?R)|end)(?(R#1)yes|no)",
			"sample_result": "[end no] [end yes]"
		},
		"(?(R&name)yes|no)": {
			"name": "Conditional Statement",
			"description": "Checks if a specific named capturing group is recursing. If it is, matches 'yes'; otherwise, matches 'no'.",
			"sample_expression": "(?:(?&group)|end)(?(R&group)yes|no)",
			"sample_result": "[end no] [end yes]"
		},
		"(?(?=...)yes|no)": {
			"name": "Lookahead Conditional",
			"description": "Checks if the lookahead condition is met. If it is, matches 'yes'; otherwise, matches 'no'.",
			"sample_expression": "(?(?=hello)world|universe)",
			"sample_result": "hello[world] [universe]"
		},
		"(?(?<=...)yes|no)": {
			"name": "Lookbehind Conditional",
			"description": "Checks if the lookbehind condition is met. If it is, matches 'yes'; otherwise, matches 'no'.",
			"sample_expression": "(?(?<=hello )world|universe)",
			"sample_result": "hello [world] [universe]"
		},
		"(?R)": {
			"name": "Recursive Pattern",
			"description": "Recursively matches the entire pattern inside itself, useful for nested structures like parentheses.",
			"sample_expression": "(\\((?R)?\\))",
			"sample_result": "[(())] [(())]"
		},
		"(?n)": {
			"name": "Atomic Group by Number",
			"description": "Defines an atomic group referenced by its number, preventing backtracking.",
			"sample_expression": "(?1)abc",
			"sample_result": "[abc]"
		},
		"(?+1)": {
			"name": "Relative Capture Group Reference",
			"description": "Matches the expression defined in the first relative capture group.",
			"sample_expression": "(foo)(?+1)",
			"sample_result": "[foofoo]"
		},
		"(?&name)": {
			"name": "Named Capture Group Reference",
			"description": "Matches the expression defined in the named capture group 'name'.",
			"sample_expression": "(?<word>hello) (?&word)",
			"sample_result": "[hello hello]"
		},
		"(?P=name)": {
			"name": "Named Backreference",
			"description": "Matches the exact text captured by the named group 'name'.",
			"sample_expression": "(?P<word>hello) (?P=word)",
			"sample_result": "[hello hello]"
		},
		"(?P>name)": {
			"name": "Subpattern Call",
			"description": "Matches the expression defined in the named capture group 'name'.",
			"sample_expression": "(?P<word>\\d+) (?P>word)",
			"sample_result": "[123 123]"
		},
		"(?(DEFINE)...)": {
			"name": "Pattern Definition Block",
			"description": "Allows defining patterns before using them later in the expression.",
			"sample_expression": "(?(DEFINE)(?<word>hello))(?&word) world",
			"sample_result": "[hello world]"
		},
		"?:": {
			"name": "Non-Capturing Group",
			"description": "Groups regex without capturing the matched text.",
			"sample_expression": "(?:hello) world",
			"sample_result": "[hello world]"
		},
		"(?=...)": {
			"name": "Positive Lookahead",
			"description": "Match a group before your main pattern without including it in the result.",
			"sample_expression": "\\w+(?=ing)",
			"sample_result": "[read]ing [writ]ing [jump]ing run"
		},
		"(?!...)": {
			"name": "Negative Lookahead",
			"description": "Specifies a group that cannot match after the main expression (if it matches, the result is discarded).",
			"sample_expression": "\\d(?!px)",
			"sample_result": "[1]pt 2px [3]em 4px"
		},
		"(?<=...)": {
			"name": "Positive Lookbehind",
			"description": "Matches a group before the main expression without including it in the result.",
			"sample_expression": "(?<=#)\\w+",
			"sample_result": "#[Title] #[Heading] #subtext"
		},
		"(?<!...)": {
			"name": "Negative Lookbehind",
			"description": "Specifies a group that cannot match before the main expression (if it matches, the result is discarded).",
			"sample_expression": "(?<!-)\\d+",
			"sample_result": "The temperature is [-10] but feels like [5] degrees"
		},
		"(*ACCEPT)": {
			"name": "Control Verb - ACCEPT",
			"description": "Forces an immediate successful match and stops further processing.",
			"sample_expression": "a(*ACCEPT)b",
			"sample_result": "[a]b ab ac"
		},
		"(*FAIL)": {
			"name": "Control Verb - FAIL",
			"description": "Forces an immediate match failure at this point.",
			"sample_expression": "a(*FAIL)b",
			"sample_result": "No matches"
		},
		"(*MARK:NAME)": {
			"name": "Control Verb - MARK",
			"description": "Sets a named mark that can be referenced later.",
			"sample_expression": "a(*MARK:test)b",
			"sample_result": "[a]b ab ac"
		},
		"(*COMMIT)": {
			"name": "Control Verb - COMMIT",
			"description": "Once encountered, commits to the match attempt and prevents backtracking.",
			"sample_expression": "a(*COMMIT)b|ac",
			"sample_result": "[a]b ac"
		},
		"(*PRUNE)": {
			"name": "Control Verb - PRUNE",
			"description": "When encountered, if a match attempt fails after this point, backtracking will not consider alternatives before this point.",
			"sample_expression": "a(*PRUNE)b|ac",
			"sample_result": "[a]b ac"
		},
		"(*SKIP)": {
			"name": "Control Verb - SKIP",
			"description": "Forces the regex engine to skip the remainder of the current match attempt and start a new attempt at the next position.",
			"sample_expression": "a(*SKIP)b|ac",
			"sample_result": "ac"
		},
		"(*THEN)": {
			"name": "Control Verb - THEN",
			"description": "Forces the regex engine to try the next alternative in the group without backtracking to previous ones.",
			"sample_expression": "(apple(*THEN)banana|apple|pear) tree",
			"sample_result": "[apple tree] [pear tree]"
		},
		"(*UTF)":{
			"name":"UTF Modifier",
			"description":"Ensures the pattern is matched using UTF encoding.",
			"sample_expression":"(*UTF)apple",
			"sample_result":"[apple]"
		},
		"(*UTF8)":{
			"name":"UTF-8 Modifier",
			"description":"Ensures that Unicode characters are correctly matched using UTF-8 encoding.",
			"sample_expression":"(*UTF8)\\w+",
			"sample_result":"[hello] [world]"
		},
		"(*UTF16)":{
			"name":"UTF-16 Modifier",
			"description":"Ensures that Unicode characters are correctly matched using UTF-16 encoding.",
			"sample_expression":"(*UTF16)[\u00E9]",
			"sample_result":"r[é]sum[é]"
		},
		"(*UTF32)":{
			"name":"UTF-32 Modifier",
			"description":"Ensures that Unicode characters are correctly matched using UTF-32 encoding.",
			"sample_expression":"(*UTF32)[\\U0001F600]",
			"sample_result":"[😀]"
		},
		"(*UCP)": {
			"name": "Unicode Character Property Modifier",
			"description": "Enables Unicode Character Property support for matching based on character properties.",
			"sample_expression": "(*UCP)\\p{L} matches any character that is a letter.",
			"sample_result": "[abc]"
		},
		"(*CR)": {
			"name": "Carriage Return Modifier",
			"description": "Enforces the use of carriage return (CR) as the line break character, overriding other line break formats.",
			"sample_expression": "(*CR).",
			"sample_result": "hello\r"
		},
		"(*LF)": {
			"name": "Line Feed Modifier",
			"description": "Forces the regex engine to recognize only line feeds (LF, \\n) as line breaks.",
			"sample_expression": "(*LF)^hello$",
			"sample_result": "[hello]"
		},
 		"(*CRLF)": {
			"name": "Carriage Return + Line Feed Modifier",
			"description": "Enforces Windows-style line breaks (CRLF, \\r\\n).",
			"sample_expression": "(*CRLF)^hello$",
			"sample_result": "[hello]"
		},
		"(*BSR_UNICODE)": {
			"name": "Unicode Line Break Mode",
			"description": "Treats all Unicode line breaks as valid (\\n, \\r, \\r\\n, U+0085, U+2028, U+2029).",
			"sample_expression": "(*BSR_UNICODE).*",
			"sample_result": "[Line1] [Line2] [Line3] [Line4] [Line5]"
		},
		"(*BSR_ANYCRLF)": {
			"name": "Any CRLF Line Break Mode",
			"description": "Only recognizes \\n, \\r, and \\r\\n as line breaks.",
			"sample_expression": "(*BSR_ANYCRLF).*",
			"sample_result": "[Line1] [Line2] [Line3] [Line4 Line5]"
		},
		"(*ANYCRLF)": {
			"name": "CRLF-Only Mode",
			"description": "Forces the regex engine to use only \\n, \\r, and \\r\\n as valid line breaks.",
			"sample_expression": "(*ANYCRLF)^hello$",
			"sample_result": "[hello]"
		},
		"(*ANY)": {
			"name": "Any Line Break Mode",
			"description": "Allows the pattern to match any Unicode line break sequence.",
			"sample_expression": "(*ANY).+",
			"sample_result": "First line[⏎]Second line[⏎]Third line"
		},
		"(*NOTEMPTY)": {
			"name": "No Empty Match",
			"description": "Prevents empty matches in the pattern.",
			"sample_expression": "(*NOTEMPTY)^.*$",
			"sample_result": "Match: 'Hello'[⏎]Match: 'World'[⏎]No match: ''"
		},
		"(*NOTEMPTY_ATSTART)": {
			"name": "No Empty Match at Start",
			"description": "Prevents empty matches only at the start of the string.",
			"sample_expression": "(*NOTEMPTY_ATSTART)^.*$",
			"sample_result": "Match: 'Hello'[⏎]Match: 'World'[⏎]No match at start: ''"
		},
		"(*NO_JIT)": {
			"name": "Disable JIT Compilation",
			"description": "Disables just-in-time compilation for the regex engine.",
			"sample_expression": "(*NO_JIT)\\d+",
			"sample_result": "123 matched[⏎]456 matched"
		},
		"(*LIMIT_RECURSION=d)": {
			"name": "Limit Recursion Depth",
			"description": "Restricts the depth of recursive pattern matching to prevent excessive memory usage.",
			"sample_expression": "(*LIMIT_RECURSION=10)(a+)+",
			"sample_result": "Matches 'aaaaaaaaaa', fails on deeper recursion"
		},
		"(*LIMIT_MATCH=x)": {
			"name": "Limit Match Attempts",
			"description": "Restricts the number of match attempts before the regex engine gives up.",
			"sample_expression": "(*LIMIT_MATCH=1000)a*",
			"sample_result": "Matches 'aaaa' but fails after 1000 attempts"
		},
		"(*NO_AUTO_POSSESS)": {
			"name": "Disable Auto-Possessification",
			"description": "Prevents automatic possessive quantifier optimization.",
			"sample_expression": "(*NO_AUTO_POSSESS)a*?",
			"sample_result": "Matches 'aaa' but allows backtracking"
		},
		"(*NO_START_OPT)": {
			"name": "Disable Start Optimization",
			"description": "Prevents optimizations that assume matches start at the beginning.",
			"sample_expression": "(*NO_START_OPT)foo",
			"sample_result": "Matches 'foo' even if scanning inefficiently"
		},
		"(?i)": {
			"name": "Case-Insensitive Mode",
			"description": "Makes the pattern case-insensitive.",
			"sample_expression": "(?i)hello",
			"sample_result": "Matches: 'Hello', 'HELLO', 'hElLo'"
		},
		"(?L)": {
			"name": "Locale-Sensitive Mode",
			"description": "Uses locale-specific rules for character matching.",
			"sample_expression": "(?L)\\w+",
			"sample_result": "Matches words according to the active locale"
		},
		"(?m)": {
			"name": "Multiline Mode",
			"description": "Makes ^ and $ match at the start and end of each line, not just the string.",
			"sample_expression": "(?m)^hello",
			"sample_result": "Matches 'hello' at the start of each line"
		},
		"(?s)": {
			"name": "Single-Line (Dotall) Mode",
			"description": "Allows the dot (.) to match newline characters.",
			"sample_expression": "(?s)a.b",
			"sample_result": "Matches 'a\\nb'"
		},
		"(?u)": {
			"name": "Unicode Mode",
			"description": "Enables Unicode-aware character classes and matching.",
			"sample_expression": "(?u)\\w+",
			"sample_result": "Matches Unicode words like 'résumé' and 'こんにちは'"
		},
		"(?x)": {
			"name": "Verbose Mode",
			"description": "Allows whitespace and comments in the regex for readability.",
			"sample_expression": "(?x) a \\d+ # Match 'a' followed by digits",
			"sample_result": "Matches 'a123'"
		},
		"(?-...)": {
			"name": "Disable Specific Flags",
			"description": "Temporarily disables specific flags inside a regex.",
			"sample_expression": "(?i)Hello (?-i)World",
			"sample_result": "Matches 'HELLO World' but not 'HELLO WORLD'"
		}
	},
	"Meta Sequences":{
		".":{
			"name":"",
			"description":"Matches any character except a newline",
			"sample_expression":"",
			"sample_result":""
		},
		"a|b":{
			"name":"",
			"description":"Acts as an OR operator between expressions",
			"sample_expression":"",
			"sample_result":""
		},
		"\\s": {
			"name": "Whitespace Character",
			"description": "Matches any whitespace character [ \\t\n\\r\\x0c].",
			"sample_expression": "apple orange\tbanana\ncarrot",
			"sample_result": "apple [ ]orange[\t]banana[\n]carrot"
		},
		"\\S": {
			"name": "Non-Whitespace Character",
			"description": "Matches any non-whitespace character [^ \\t\\n\\r\\x0c].",
			"sample_expression": "apple orange\tbanana\ncarrot",
			"sample_result": "[apple] [orange][\t]banana[\n]carrot"
		},
		"\\d": {
			"name": "Digit Character",
			"description": "Matches any digit character [0-9].",
			"sample_expression": "apple 123 orange 456",
			"sample_result": "apple [123] orange [456]"
		},
		"\\D": {
			"name": "Non-Digit Character",
			"description": "Matches any non-digit character [^0-9].",
			"sample_expression": "apple 123 orange 456",
			"sample_result": "[apple] [ ]123 [orange] [ ]456"
		},
		"\\w": {
			"name": "Word Character",
			"description": "Matches any word character [a-zA-Z0-9_].",
			"sample_expression": "apple123 _banana",
			"sample_result": "[apple123] [_]banana"
		},
		"\\W": {
			"name": "Non-Word Character",
			"description": "Matches any non-word character [^a-zA-Z0-9_].",
			"sample_expression": "apple123 _banana!",
			"sample_result": "[ ]apple123 [_]banana[!]"
		},
		"\\X": {
			"name": "Unicode Grapheme Cluster",
			"description": "Matches a single Unicode grapheme cluster (including combined characters and emojis).",
			"sample_expression": "ÀB🇺🇸C",
			"sample_result": "[À][B][🇺🇸][C]"
		},
		"\\C": {
			"name": "Single Data Unit",
			"description": "Matches a single data unit (byte) in the string, ignoring Unicode semantics (rarely used).",
			"sample_expression": "abc",
			"sample_result": "[a][b][c]"
		},
		"\\R": {
			"name": "Unicode Newline Sequence",
			"description": "Matches any Unicode newline sequence (\\n, \\r, \\r\\n, \\x85, \\u2028, \\u2029).",
			"sample_expression": "Hello\r\nWorld",
			"sample_result": "Hello[\r\n]World"
		},
		"\\N": {
			"name": "Non-Newline Character",
			"description": "Matches any character except a newline.",
			"sample_expression": "Hello\nWorld",
			"sample_result": "[H][e][l][l][o]\n[W][o][r][l][d]"
		},
		"\\x0b": {
			"name": "Vertical Tab (Vertical Whitespace)",
			"description": "Matches the vertical tab character (\\x0b).",
			"sample_expression": "Hello\\x0bWorld",
			"sample_result": "Hello[\\x0b]World"
		},
		"\\V": {
			"name": "Non-Vertical Whitespace",
			"description": "Matches any character except vertical whitespace (\\x0b).",
			"sample_expression": "Hello\\x0bWorld",
			"sample_result": "[H][e][l][l][o]\\x0b[W][o][r][l][d]"
		},
		"\\h": {
			"name": "Horizontal Whitespace",
			"description": "Matches any horizontal whitespace character (spaces, tabs).",
			"sample_expression": "Hello\tWorld",
			"sample_result": "Hello[\t]World"
		},
		"\\H": {
			"name": "Non-Horizontal Whitespace",
			"description": "Matches any character except horizontal whitespace.",
			"sample_expression": "Hello\tWorld",
			"sample_result": "[H][e][l][l][o]\t[W][o][r][l][d]"        
		},
		"\\K":{
			"name": "Reset Match",
			"description":"Used to drop everything matched before it, effectively resetting the match start.",
			"sample_expression":"\\d+\\K\\w+",
			"sample_result":"123[ABC]"
		},
		"\\#": {
			"name": "Backreference to First Capturing Group",
			"description": "Matches the exact text captured in the first capturing group.",
			"sample_expression": "(\\w+)\\s\\1 would match a repeated word",
			"sample_result": "[apple] [apple] banana"
		},
		"\\pX": {
			"name": "Unicode Property Match",
			"description": "Matches a character belonging to a specific Unicode property (e.g., \\p{Lu} for uppercase letters).",
			"sample_expression": "\\p{Nd} for digits",
			"sample_result": "Hello [1][2][3]"
		},
		"\\p{...}": {
			"name": "Unicode Property Match",
			"description": "Matches any character belonging to the specified Unicode property or script category.",
			"sample_expression": "\\p{L} matches any letter",
			"sample_result": "[H][e][l][l][o] 你好 123"
		},
		"\\PX": {
			"name": "Negation of Unicode Property",
			"description": "Matches any character that does not belong to the specified Unicode property.",
			"sample_expression": "\\P{L}, it would match non-letter characters.",
			"sample_result": "Hello [你][好] 123"
		},
		"\\P{...}": {
			"name": "Negation of Unicode Property Match",
			"description": "Matches any character that does not belong to the specified Unicode property or script category.",
			"sample_expression": "\\P{L} matches anything that isn't a letter.",
			"sample_result": "Hello 你好 [1][2][3]"
		},
		"\\Q...\\E": {
			"name": "Literal Match",
			"description": "Quotes a sequence of characters, treating them as literal text instead of interpreting them as regex metacharacters.",
			"sample_expression": "\\Q(2+2)*3?\\E matches the exact string '(2+2)*3?'",
			"sample_result": "Find this: [(2+2)*3?]"
		},
		"\\k{name}": {
			"name": "Named Backreference",
			"description": "Matches the text captured by a named capturing group.",
			"sample_expression": "(?<word>\\w+) captures a word. \\k{name}) references the previously captured word.",
			"sample_result": "[word] [word]"
		},
		"\\k<name>": {
			"name": "Named Backreference (Angle Brackets)",
			"description": "Matches the text captured by a named capturing group, using angle brackets syntax.",
			"sample_expression": "?<word>\\w+)\\s\\k<word> matches repeated words",
			"sample_result": "[apple] [apple]"
		},
		"\\k'name'": {
			"name": "Named Backreference (Single Quotes)",
			"description": "Matches the text captured by a named capturing group, using single quotes syntax.",
			"sample_expression": "(?<'word'>\\w+) captures a word. \\k'word' references the previously captured word.",
			"sample_result": "[banana] [banana]"
		},
		"\\gn": {
			"name": "Backreference to nth Capturing Group",
			"description": "Matches the same text as the nth capturing group.",
			"sample_expression": "(cat) dog \\g1",
			"sample_result": "[cat] dog [cat]"
		},
		"\\g{n}": {
			"name": "Backreference to nth Capturing Group (Alternative Syntax)",
			"description": "Matches the same text as the nth capturing group using curly brace notation.",
			"sample_expression": "(apple) banana \\g{1}",
			"sample_result": "[apple] orange [apple]"
		},
		"\\g{-n}": {
			"name": "Relative Backreference",
			"description": "Matches text captured by the nth previous capturing group.",
			"sample_expression": "car bike car",
			"sample_result": "[car] bike [car]"
		},
		"\\g<n>": {
			"name": "Named Backreference (Angle Brackets)",
			"description": "Matches the text captured by the nth capturing group using angle bracket syntax.",
			"sample_expression": "hello world hello",
			"sample_result": "[hello] world [hello]"
		},
		"\\g<+n>": {
			"name": "Forward Reference",
			"description": "Matches the text of an upcoming capture group.",
			"sample_expression": "123 456 123",
			"sample_result": "[123] 456 [123]"
		},
		"\\g'n'": {
			"name": "Backreference (Single Quotes)",
			"description": "Matches the text captured by the nth capturing group using single quotes.",
			"sample_expression": "yes no yes",
			"sample_result": "[yes] no [yes]"
		},
		"\\g'+n'": {
			"name": "Relative Forward Reference",
			"description": "Matches text in an upcoming capture group.",
			"sample_expression": "A B A",
			"sample_result": "[A] B [A]"
		},
		"\\g{letter}": {
			"name": "Named Backreference (Curly Braces)",
			"description": "Matches the same text captured by the named group 'letter'.",
			"sample_expression": "(?P<letter>red) blue \\g{letter} first captures 'red' in (?P<letter>red), and \\g{letter} ensures that 'red' appears again",
			"sample_result": "[red] blue [red]"
		},
		"\\g<letter>": {
			"name": "Named Backreference (Angle Brackets)",
			"description": "Matches the same text captured by the named group 'letter'.",
			"sample_expression": "(?P<letter>dog) cat \\g<letter> captures 'dog' and ensures it appears again.",
			"sample_result": "[dog] cat [dog]"
		},
		"\\g'letter'": {
			"name": "Named Backreference (Single Quotes)",
			"description": "Matches the same text captured by the named group 'letter'.",
			"sample_expression": "(?P<letter>123) abc \\g'letter' captures '123' and ensures it appears again.",
			"sample_result": "[123] abc [123]"
		},
		"\\g{word}": {
			"name": "Named Backreference in a Sentence",
			"description": "Matches a previously captured word and ensures repetition in a sentence.",
			"sample_expression": "(?P<word>quick) fox jumps over the \\g{word} fox",
			"sample_result": "The [quick] fox jumps over the [quick] fox."
		},
		"\\xYY": {
			"name": "Hex Character YY",
			"description": "Matches a character represented by the hexadecimal value YY.",
			"sample_expression": "\\x41 (\\x41 represents the ASCII character 'A')",
			"sample_result": "[A]pple"
		},
		"\\x{YYYY}": {
			"name": "Unicode Hex Character YYYY",
			"description": "Matches a Unicode character represented by the hexadecimal value YYYY.",
			"sample_expression": "\\x{1F60A} (\\x{1F60A} represents the Unicode character 😊)",
			"sample_result": "Hello there [😊]!"
		},
		"\\ddd": {
			"name": "Octal Character",
			"description": "Matches a character represented by the octal value ddd.",
			"sample_expression": "\\101 (\\101 (octal) corresponds to ASCII 'A')",
			"sample_result": "[A]pple"
		},
		"\\cY": {
			"name": "Control Character Y",
			"description": "Matches the control character represented by Ctrl + Y.",
			"sample_expression": "\\cJ (\\cJ corresponds to Ctrl + J, which is a newline (\\n).)",
			"sample_result": "Hello[\\n]World"
		},
		"[\\b]": {
			"name": "Backspace Character",
			"description": "Matches a backspace character (ASCII 8). Only the backspace character when in a character class.",
			"sample_expression": "abc\\bdef",
			"sample_result": "abc[\\b]def"
		},
		"\\": {
			"name": "Escape Character",
			"description": "Escapes special characters to treat them as literals.",
			"sample_expression": "\\.",
			"sample_result": "File name: report[.]txt"
		}
	},
	"Quantifiers":{
		"*":{
			"name":"Star",
			"description":"Matches 0 or more repetitions of the preceding element",
			"sample_expression":"b\\w*",
			"sample_result":"[b] [be] [bee] [beer] [beers]"
		},
		"+":{
			"name":"Plus",
			"description":"Matches 1 or more repetitions of the preceding element",
			"sample_expression":"b\\w+",
			"sample_result":"b [be] [bee] [beer] [beers]"
		},
		"?":{
			"name":"Optional",
			"description":"Matches 0 or 1 repetition of the preceding element",
			"sample_expression":"colou?r",
			"sample_result":"[color] [colour]"
		},
		"{n}": {
			"name": "Quantifier",
			"description": "Matches exactly n repetitions of the preceding element",
			"sample_expression": "a{3}",
			"sample_result": "b[aaa]t"
		},
		"{n,}": {
			"name": "Quantifier (At Least n)",
			"description": "Matches n or more repetitions of the preceding element",
			"sample_expression": "a{2,}",
			"sample_result": "b[aaaa]t"
		},
		"{n,m}": {
			"name": "Quantifier Range",
			"description": "Matches between n and m repetitions of the preceding element",
			"sample_expression": "a{2,4}",
			"sample_result": "b[aaaa]t"
		},
		"a*": {
			"name": "Greedy qualifier",
			"description": "Matches as many characters as possible.",
			"sample_expression": "a*",
			"sample_result": "b[aaaa]t"
		},
		"a*?": {
			"name": "Lazy qualifier",
			"description": "Matches as few characters as possible.",
			"sample_expression": "a*? matches [] occur before each a, capturing the smallest match (which is empty).",
			"sample_result": "b[]a[]a[]a[]a[]t"
		},
		"a*+": {
			"name": "Possessive qualifier",
			"description": "Matches as many characters as possible; backtracking can't reduce the characters matched.",
			"sample_expression": "a*+t",
			"sample_result": "b[aaaa]t"
		},
		"*?":{
			"name":"Lazy",
			"description":"Lazy match 0 or more times",
			"sample_expression":"b\\w+?",
			"sample_result":"b [be] [be]e [be]er [be]ers"
		},
		"+?": {
			"name": "Lazy One or More",
			"description": "Matches one or more repetitions of the preceding element, but as few as possible. This is the lazy (or reluctant) version of '+'. It prioritizes the shortest possible match that still satisfies the overall pattern. This is useful when you have multiple potential matches and want to stop at the first one that works.",
			"sample_expression": "ab+?",
			"sample_result": "[abb]bbc"
		},
		"??": {
			"name": "Lazy Zero or One",
			"description": "Matches zero or one repetition of the preceding element, but prefers zero. This is the lazy (or reluctant) version of '?'. It will only match one occurrence if necessary to satisfy the rest of the pattern. This is useful for making optional parts of a pattern truly optional, especially when used with other quantifiers.",
			"sample_expression": "colou??r",
			"sample_result": "[color] col[our]"
		}
	},
	"Substitution":{
		"$0":{
			"name": "Complete Match",
			"description": "Complete match contents",
			"sample_expression": "(Hello world)",
			"sample_result": "[Hello world]"
		},
		"$1":{
			"name": "Capture Group",
			"description": "Contents in capture group 1",
			"sample_expression": "(Hello) world",
			"sample_result": "[Hello]"
		},
		"$$":{
			"name": "Escaped Dollar Sign",
			"description": "Insert a dollar sign",
			"sample_expression": "(Price: )\\d+",
			"sample_result": "Price: [$100]"
		},
		"${foo}":{
			"name": "Named Capture Group",
			"description": "Contents in capture group 'foo'",
			"sample_expression": "(?<foo>Hello) world",
			"sample_result": "[Hello]"
		},
		"$n": {
			"name": "nth Captured Group",
			"description": "nth captured group",
			"sample_expression": "(Hello) (world)",
			"sample_result": "[Hello]"
		},
		"$`": {
			"name": "Before Match",
			"description": "Inserts the portion of the source string that precedes the match.",
			"sample_expression": "Hello (world)",
			"sample_result": "[Hello ]"
		},
		"$'": {
			"name": "After Match",
			"description": "Inserts the portion of the source string that follows the match.",
			"sample_expression": "(Hello) world",
			"sample_result": "[ world]"
		},
		"$&": {
			"name": "Match",
			"description": "Entire matched string",
			"sample_expression": "(Hello) world",
			"sample_result": "[Hello]"
		},
		"$+": {
			"name": "Last Captured Group",
			"description": "Last captured group",
			"sample_expression": "(Hello) (world)",
			"sample_result": "[world]"
		},
		"$_": {
			"name": "Entire Input String",
			"description": "Entire input string",
			"sample_expression": "(Hello)",
			"sample_result": "[Hello world]"
		},
		"\\x20": {
			"name": "Hexadecimal Space",
			"description": "Hexadecimal replacement values",
			"sample_expression": "Hello\\x20world",
			"sample_result": "[Hello world]"
		},
		"\\x{06fa}": {
			"name": "Hexadecimal Unicode",
			"description": "Hexadecimal replacement values",
			"sample_expression": "\\x{06fa}",
			"sample_result": "[ۺ]"
		},
		"\\t": {
			"name": "Tab Character",
			"description": "Insert a tab",
			"sample_expression": "Hello\\tWorld",
			"sample_result": "[Hello    World]"
		},
		"\\r": {
			"name": "Carriage Return",
			"description": "Insert a carriage return",
			"sample_expression": "Hello\\rWorld",
			"sample_result": "[Hello\rWorld]"
		},
		"\\n": {
			"name": "Newline Character",
			"description": "Insert a newline",
			"sample_expression": "Hello\\nWorld",
			"sample_result": "[Hello\nWorld]"
		},
		"\\f": {
			"name": "Form Feed",
			"description": "Insert a form-feed",
			"sample_expression": "Page1\\fPage2",
			"sample_result": "[Page1\fPage2]"
		},
		"\\U": {
			"name": "Uppercase Transformation",
			"description": "Convert matched text to uppercase",
			"sample_expression": "\\U(hello)",
			"sample_result": "[HELLO]"
		},
		"\\L": {
			"name": "Lowercase Transformation",
			"description": "Convert matched text to lowercase",
			"sample_expression": "\\L(HELLO)",
			"sample_result": "[hello]"
		},
		"\\E": {
			"name": "End Transformation",
			"description": "Terminate any Transformation",
			"sample_expression": "\\U(Hello)\\E World",
			"sample_result": "[HELLO World]"
		},
		"${1:+foo:bar}": {
			"name": "Conditional Replacement",
			"description": "Conditional replacement based on the first capture group",
			"sample_expression": "(hello) world",
			"sample_result": "[foo]"
		},
		"\\[": {
			"name": "Escaped Literal",
			"description": "Insert the escaped literal '['",
			"sample_expression": "\\[Hello]",
			"sample_result": "[[Hello]]"
		}
	}
}
