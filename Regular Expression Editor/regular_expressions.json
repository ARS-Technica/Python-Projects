{
		"All Tokens":{
		" ": {
			"name":" ",
			"description": " ",
			"sample_expression": " ",
			"sample_result": " "
		}
	},
	"Anchors":{
		"^":{
			"name":"Beginning",
			"description":"Matches the beginning of the string, or the beginning of a line if the multiline flag (m) is enabled.",
			"sample_expression":"^\\w+",
			"sample_result":"[she] sells seashells"
		},
		"$":{
			"name":"End",
			"description":"Matches the end of the string, or the end of a line if the multiline flag (m) is enabled. ",
			"sample_expression":"\\w+$",
			"sample_result":"she sells [seashells]"
		},
		"\\A": {
			"name": "Start of String",
			"description": "Matches the beginning of the string, regardless of multiline mode.",
			"sample_expression": "Hello World\nHello Again",
			"sample_result": "[H]ello World\nHello Again"
		},
		"\\b":{
			"name":"Word Boundary",
			"description":"Matches a word boundary position between a word character and non-word character or position (start / end of string). ",
			"sample_expression":"s\\b",
			"sample_result":"she sell[s] seashell[s]"
		},
		"\\B":{
			"name":"Not Word Boundary",
			"description":"Non-word boundary",
			"sample_expression":"s\\B",
			"sample_result":"she sells sea[s]hells"
		},
		"\\G": {
			"name": "Start of Match",
			"description": "Matches the position where the previous match ended, or the start of the string if no previous match.",
			"sample_expression": "apple orange banana apple",
			"sample_result": "[apple] orange banana apple"
		},
		"\\z": {
			"name": "Absolute End of String",
			"description": "Matches the very end of the string, ignoring multiline mode.",
			"sample_expression": "Hello World\nHello Again",
			"sample_result": "Hello World\nHello Agai[n]"
		},
		"\\Z": {
			"name": "End of String (Before Final Newline)",
			"description": "Matches the end of the string, but before a final newline (if one exists).",
			"sample_expression": "Hello World\nHello Again\n",
			"sample_result": "Hello World\nHello Agai[n]\n"
		}
	},
	"Character Classes":{
		"a?": {
			"name": "Optional Match",
			"description": "Matches zero or one occurrences of 'a'.",
			"sample_expression": "bat bt",
			"sample_result": "b[a]t b[]t"
		},
		"a*": {
			"name": "Zero or More",
			"description": "Matches zero or more occurrences of 'a'.",
			"sample_expression": "baaaat bt",
			"sample_result": "b[aaaa]t b[]t"
		},
		"a+": {
			"name": "One or More",
			"description": "Matches one or more occurrences of 'a'.",
			"sample_expression": "baaaat bt",
			"sample_result": "b[aaaa]t bt"
		},
		"a{3}": {
			"name": "Exact Quantifier",
			"description": "Matches exactly 3 occurrences of 'a'.",
			"sample_expression": "baaaat",
			"sample_result": "b[aaa]at"
		},
		"a{3,}": {
			"name": "At Least Quantifier",
			"description": "Matches 3 or more occurrences of 'a'.",
			"sample_expression": "baaaaat",
			"sample_result": "b[aaaaa]t"
		},
		"a{3,6}": {
			"name": "Range Quantifier",
			"description": "Matches between 3 and 6 occurrences of 'a'.",
			"sample_expression": "baaaaaaat",
			"sample_result": "b[aaaaaa]at"
		},
		"a|b":{
			"name":"Alternation",
			"description":"Match either a or b",
			"sample_expression":"b(a|e|i)d",
			"sample_result":"[bad] bud bod [bed] [bid]"
		},
		"[abc]":{
			"name":"Character Set",
			"description":"Match a single character present in the set",
			"sample_expression":"[aeiou]",
			"sample_result":"gl[i]b j[o]cks v[e]x dw[a]rv[e]s!"
		},
		"[^abc]":{
			"name":"Negated Character Set",
			"description":"Match a single character NOT present in the set",
			"sample_expression":"[^aeiou]",
			"sample_result":"[gl]i[b j]o[cks v]e[x dw]a[rv]e[s!]"
		},
		"[a-z]": {
			"name": "Lowercase Letter Range",
			"description":"Matches a character between two specified characters inclusive.",
			"sample_expression":"[g-s]",
			"sample_result":"abcdef[ghijklmnopqrs]tuvwxyz"
		},
		"[A-Z]": {
			"name": "Uppercase Letter Range",
			"description": "Matches any uppercase letter from 'A' to 'Z'.",
			"sample_expression": "[A-Z]",
			"sample_result": "Matches 'G' in 'Great'"
		},
		"[a-zA-Z]": {
			"name": "Alphabetic Range",
			"description":"Match a single character in the range a-z or A-Z",
			"sample_expression":"[xyzABC]",
			"sample_result":"[A]a[B]b[C]cDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwX[x]Y[y]Z[z]"
		},
		"[^a-z]": {
			"name": "Negated Lowercase Range",
			"description":"Match a single character NOT between two specified characters",
			"sample_expression":"[g-s]",
			"sample_result":"[abcdef]ghijklmnopqrs[tuvwxyz]"
		},
		"[0-9]": {
			"name": "Digit Range",
			"description": "Matches any digit from 0 to 9.",
			"sample_expression": "[0-9]",
			"sample_result": "Matches '4' in '42'"
		},
		"\\b":{
			"name":"",
			"description":"A word boundary",
			"sample_expression":"",
			"sample_result":""
		},
		"\\B":{
			"name":"",
			"description":"Non-word boundry",
			"sample_expression":"",
			"sample_result":""
		},
		
		"\\d":{
			"name": "Digit Shortcut",
			"description":"Match any digit character (0 -9). Equivalent to [0-9].",
			"sample_expression":"(555) 555-5555",
			"sample_result":"Phone: ([555]) [555]-[5555]"
		},
		"\\D":{
			"name": "Non-Digit Shortcut",
			"description":"Match any non-digit character. Equivalent to [^0-9].",
			"sample_expression":"(555) 555-5555",
			"sample_result":"[Phone:] [(]555[)] 555[-]5555"
		},
		"\\p{}":{
			"name":"Unicode Script",
			"description":"Matches any character in specified unicode script.",
			"sample_expression":"",
			"sample_result":"Character sets include Arabic, Armenian, Bengali, Cherokee, Cyrillic, Greek, Hebrew, Japanese, Korean, Latin, Thai"
		},
		"\\P{}":{
			"name":"Not Unicode Script",
			"description":"Matches any character not in specified unicode script.",
			"sample_expression":"",
			"sample_result":""
		},		
		"\\p{L}": {
			"name": "Unicode Category: Letter",
			"description": "Matches any letter character from any language.",
			"sample_expression": "\\p{L}+",
			"sample_result": "[Hello] [你好] 123"
		},
		"\\P{L}": {
			"name": "Unicode Category: Not Letter",
			"description": "Matches any character that is not a letter.",
			"sample_expression": "\\P{L}+",
			"sample_result": "Hello 你好 [123]"
		},
		"\\p{Ll}":{
			"name": "Unicode Category: Lowercase Letter",
			"description": "Matches any lowercase letter character from any language.",
			"sample_expression": "Regex: '\\p{Ll}+' - Text: 'Hello world, привет мир!'",
			"sample_result": "[world] [привет] [мир]"
		},
		"\\p{Han}": {
			"name": "Unicode Script: Han",
			"description": "Matches any Han character (used in Chinese, Japanese, and Korean).",
			"sample_expression": "\\p{Han}+",
			"sample_result": "Hello [你好] 123"
		},
		"\\P{Han}": {
			"name": "Unicode Script: Not Han",
			"description": "Matches any character that is not a Han character.",
			"sample_expression": "\\P{Han}+",
			"sample_result": "[Hello ]你好 [123]"
		},
		"\\s":{
			"name": "Whitespace Character",
			"description":"Match any whitespace character",
			"sample_expression":"\\s",
			"sample_result":"Hello[ ]World!"
		},
		"\\S":{
			"name": "Non-Whitespace Character",
			"description":"Match any non-whitespace character",
			"sample_expression":"\\S",
			"sample_result":"[Hello] [World!]"
		},		
		"[\\s\\S]":{
			"name":"Match Any",
			"description":"A character set that can be used to match any character, including line breaks, without the dotall flag (s).",
			"sample_expression":"[\\s\\S]",
			"sample_result":"[glib jocks vex dwarves!]"
		},
		"\\w":{
			"name":"Word",
			"description":"Match any low-ascii character or underscore. Equivalent to [A-Za-z0-9_].",
			"sample_expression":"bonjour, mon frère",
			"sample_result":"[bonjour], [mon] [fr]è[re]"
		},
		"\\W":{
			"name": "Non-Word Character",
			"description":"Match any non-word character. Equivalent to [^A-Za-z0-9_].",
			"sample_expression":"bonjour, mon frère",
			"sample_result":"bonjour[, ]mon[ ]fr[è]re"
		},
		".":{
			"name":"Match Any Character",
			"description":"Match any character except line terminators (linebreaks). Equivalent to [^\n\r].",
			"sample_expression":".",
			"sample_result":"[glib jocks vex dwarves!]"
		},
		"(?:...)":{
			"name": "Non-Capturing Group",
			"description": "Groups part of a pattern without capturing it for back-references.",
			"sample_expression": "(?:cat|dog)",
			"sample_result": "I have a [cat] and a [dog]."
		},                
		"(...)":{
			"name": "Capturing Group",
			"description": "Groups part of a pattern and captures it for back-references.",
			"sample_expression":"(\\d+) (Captures one or more digits.)",
			"sample_result": "My number is [12345]."
		},
		"^": {
			"name": "Start of Line",
			"description": "Matches the start of a string or line.",
			"sample_expression": "Hello world",
			"sample_result": "[Hello] world"
		},
		"$": {
			"name": "End of Line",
			"description": "Matches the end of a string or line.",
			"sample_expression": "Hello world",
			"sample_result": "Hello [world]"
		},
		"[[:alnum:]]": {
			"name": "Alphanumeric",
			"description": "Matches any letter or digit.",
			"sample_expression": "[[:alnum:]]",
			"sample_result": "Matches 'A' in 'A1'"
		},
		"[[:alpha:]]": {
			"name": "Alphabetic",
			"description": "Matches any letter.",
			"sample_expression": "[[:alpha:]]",
			"sample_result": "Matches 'B' in 'Beta'"
		},
		"[[:ascii:]]": {
			"name": "ASCII Characters",
			"description": "Matches any ASCII character (codes 0-127).",
			"sample_expression": "[[:ascii:]]",
			"sample_result": "Matches '$' in '$100'"
		},
		"[[:blank:]]": {
			"name": "Space or Tab",
			"description": "Matches only space or tab characters.",
			"sample_expression": "[[:blank:]]",
			"sample_result": "Matches tab in 'Name\tAge'"
		},
		"[[:cntrl:]]": {
			"name": "Control Characters",
			"description": "Matches control characters like newlines and tabs.",
			"sample_expression": "[[:cntrl:]]",
			"sample_result": "Matches newline in 'Hello\\nWorld'"
		},
		"[[:digit:]]": {
			"name": "Digits",
			"description": "Matches any numeric digit (equivalent to \\d).",
			"sample_expression": "[[:digit:]]",
			"sample_result": "Matches '3' in '3rd'"
		},
		"[[:graph:]]": {
			"name": "Visible Characters",
			"description": "Matches any character except spaces.",
			"sample_expression": "[[:graph:]]",
			"sample_result": "Matches '!' in 'Hello!' but not space in 'Hello World'"
		},
		"[[:lower:]]": {
			"name": "Lowercase Letters",
			"description": "Matches any lowercase letter.",
			"sample_expression": "[[:lower:]]",
			"sample_result": "Matches 'g' in 'guitar'"
		},
		"[[:print:]]": {
			"name": "Printable Characters",
			"description": "Matches any visible character including spaces.",
			"sample_expression": "[[:print:]]",
			"sample_result": "Matches 'A' in 'ABC' and space in 'Hello World'"
		},
		"[[:punct:]]": {
			"name": "Punctuation Characters",
			"description": "Matches any punctuation mark.",
			"sample_expression": "[[:punct:]]",
			"sample_result": "Matches '?' in 'What?'"
		},
		"[[:space:]]": {
			"name": "Whitespace",
			"description": "Matches any whitespace character.",
			"sample_expression": "[[:space:]]",
			"sample_result": "Matches space in 'hello world'"
		},
		"[[:upper:]]": {
			"name": "Uppercase Letters",
			"description": "Matches any uppercase letter.",
			"sample_expression": "[[:upper:]]",
			"sample_result": "Matches 'Z' in 'Zebra'"
		},
		"[[:word:]]": {
			"name": "Word Characters",
			"description": "Matches any letter, digit, or underscore.",
			"sample_expression": "[[:word:]]",
			"sample_result": "Matches 'C' in 'Code_123'"
		},
		"[[:xdigit:]]": {
			"name": "Hexadecimal Digits",
			"description": "Matches any valid hexadecimal digit (0-9, A-F, a-f).",
			"sample_expression": "[[:xdigit:]]",
			"sample_result": "Matches 'F' in 'FF00FF'"
		},
		"[[:<:]]": {
			"name": "Start of Word",
			"description": "Matches the start of a word boundary.",
			"sample_expression": "[[:<:]]word",
			"sample_result": "Matches 'word' at the start of a word"
		},
		"[[:>:]]": {
			"name": "End of Word",
			"description": "Matches the end of a word boundary.",
			"sample_expression": "word[[:>:]]",
			"sample_result": "Matches 'word' at the end of a word"
		}
	},
	"Escaped Characters":{
		"\\": {
			"name":"Reserved Characters",
			"description": "Preceeds character for literal representation. (+*?^$\\.[]{}()|/)",
			"sample_expression": "\\+",
			"sample_result": "1 [+] 1 = 2"
		},
		"\\000":{
			"name":"Octal Escape",
			"description":"Octal escaped character in the form \\000. Value must be less than 255",
			"sample_expression":"\\251",
			"sample_result":"All Rights Reserved [©]2025"
		},
		"\\xFF":{
			"name":"Hexadecimal Escape",
			"description":"Hexadecimal escaped character in the form \\xFF",
			"sample_expression":"\\xA9",
			"sample_result":"All Rights Reserved [©]2025"
		},
		"\\uFFFF":{
			"name":"Unicode Escape",
			"description":"Unicode escaped character in the form \uFFFF",
			"sample_expression":"\u00A9",
			"sample_result":"All Rights Reserved [©]2025"
		},
		"\\u{FFFF}":{
			"name":"Extended Unicode Escape",
			"description":"Unicode escaped character in the form \\u{FFFF}. Supports a full range of unicode point escapes with any number of hex digits.",
			"sample_expression":"\\u{00A9}",
			"sample_result":"All Rights Reserved [©]2025"
		},
		"\\c":{
			"name":"Control Character Escape",
			"description":"Escaped control character in the form \\cZ. This can range from \\cA (SOH, char code 1) to \\cZ (SUB, char code 26).",
			"sample_expression":"\\cI",
			"sample_result":"[    ]\\cI matches TAB (char code 9)."
		},
		"\\n":{
			"name":"Line Feed",
			"description":"Matches a LINE FEED character (char code 10).",
			"sample_expression":"",
			"sample_result":""
		},
		"\\v":{
			"name":"Vertical Tabe",
			"description":"Matches a VERTICAL TAB character (char code 11).",
			"sample_expression":"",
			"sample_result":""
		}
	},
	"General Tokens":{
		"\\0": {
			"name": "Null Character",
			"description": "Null character (Unicode character U+0000). Used in string termination in some programming languages.",
			"sample_expression": "A\\0B",
			"sample_result": "[A\\x00B]"
		},
		"\\n": {
			"name": "Newline Character",
			"description": "Match newline character (Unicode character U+000A). Represents a line break.",
			"sample_expression": "Regex: 'Line1\\nLine2' - Text: 'Line1\\nLine2'",
			"sample_result": "[Line1\\nLine2]"
		},
		"\\r": {
			"name": "Carriage Return Character",
			"description": "Match carriage return character (Unicode character U+000D). Often used in combination with \\n for line breaks on Windows systems.",
			"sample_expression": "Regex: 'Line1\\rLine2' - Text: 'Line1\\rLine2'",
			"sample_result": "[Line1\\rLine2]"
		},
		"\\t": {
			"name": "Tab Character",
			"description": "Match tab character (Unicode character U+0009). Represents horizontal tabulation.",
			"sample_expression": "Regex: 'Col1\\tCol2' - Text: 'Col1\\tCol2'",
			"sample_result": "[Col1\\tCol2]"
		}
	},
	"Meta Sequences":{
		".":{
			"name":"",
			"description":"Matches any character except a newline",
			"sample_expression":"",
			"sample_result":""
		},
		"a|b":{
			"name":"",
			"description":"Acts as an OR operator between expressions",
			"sample_expression":"",
			"sample_result":""
		},
		"\\s": {
			"name": "Whitespace Character",
			"description": "Matches any whitespace character [ \\t\n\\r\\x0c].",
			"sample_expression": "apple orange\tbanana\ncarrot",
			"sample_result": "apple [ ]orange[\t]banana[\n]carrot"
		},
		"\\S": {
			"name": "Non-Whitespace Character",
			"description": "Matches any non-whitespace character [^ \\t\\n\\r\\x0c].",
			"sample_expression": "apple orange\tbanana\ncarrot",
			"sample_result": "[apple] [orange][\t]banana[\n]carrot"
		},
		"\\d": {
			"name": "Digit Character",
			"description": "Matches any digit character [0-9].",
			"sample_expression": "apple 123 orange 456",
			"sample_result": "apple [123] orange [456]"
		},
		"\\D": {
			"name": "Non-Digit Character",
			"description": "Matches any non-digit character [^0-9].",
			"sample_expression": "apple 123 orange 456",
			"sample_result": "[apple] [ ]123 [orange] [ ]456"
		},
		"\\w": {
			"name": "Word Character",
			"description": "Matches any word character [a-zA-Z0-9_].",
			"sample_expression": "apple123 _banana",
			"sample_result": "[apple123] [_]banana"
		},
		"\\W": {
			"name": "Non-Word Character",
			"description": "Matches any non-word character [^a-zA-Z0-9_].",
			"sample_expression": "apple123 _banana!",
			"sample_result": "[ ]apple123 [_]banana[!]"
		},
		"\\X": {
			"name": "Unicode Grapheme Cluster",
			"description": "Matches a single Unicode grapheme cluster (including combined characters and emojis).",
			"sample_expression": "ÀB🇺🇸C",
			"sample_result": "[À][B][🇺🇸][C]"
		},
		"\\C": {
			"name": "Single Data Unit",
			"description": "Matches a single data unit (byte) in the string, ignoring Unicode semantics (rarely used).",
			"sample_expression": "abc",
			"sample_result": "[a][b][c]"
		},
		"\\R": {
			"name": "Unicode Newline Sequence",
			"description": "Matches any Unicode newline sequence (\\n, \\r, \\r\\n, \\x85, \\u2028, \\u2029).",
			"sample_expression": "Hello\r\nWorld",
			"sample_result": "Hello[\r\n]World"
		},
		"\\N": {
			"name": "Non-Newline Character",
			"description": "Matches any character except a newline.",
			"sample_expression": "Hello\nWorld",
			"sample_result": "[H][e][l][l][o]\n[W][o][r][l][d]"
		},
		"\\x0b": {
			"name": "Vertical Tab (Vertical Whitespace)",
			"description": "Matches the vertical tab character (\\x0b).",
			"sample_expression": "Hello\\x0bWorld",
			"sample_result": "Hello[\\x0b]World"
		},
		"\\V": {
			"name": "Non-Vertical Whitespace",
			"description": "Matches any character except vertical whitespace (\\x0b).",
			"sample_expression": "Hello\\x0bWorld",
			"sample_result": "[H][e][l][l][o]\\x0b[W][o][r][l][d]"
		},
		"\\h": {
			"name": "Horizontal Whitespace",
			"description": "Matches any horizontal whitespace character (spaces, tabs).",
			"sample_expression": "Hello\tWorld",
			"sample_result": "Hello[\t]World"
		},
		"\\H": {
			"name": "Non-Horizontal Whitespace",
			"description": "Matches any character except horizontal whitespace.",
			"sample_expression": "Hello\tWorld",
			"sample_result": "[H][e][l][l][o]\t[W][o][r][l][d]"        
		},
		"\\K":{
			"name": "Reset Match",
			"description":"Used to drop everything matched before it, effectively resetting the match start.",
			"sample_expression":"\\d+\\K\\w+",
			"sample_result":"123[ABC]"
		},
		"\\#": {
			"name": "Backreference to First Capturing Group",
			"description": "Matches the exact text captured in the first capturing group.",
			"sample_expression": "(\\w+)\\s\\1 would match a repeated word",
			"sample_result": "[apple] [apple] banana"
		},
		"\\pX": {
			"name": "Unicode Property Match",
			"description": "Matches a character belonging to a specific Unicode property (e.g., \\p{Lu} for uppercase letters).",
			"sample_expression": "\\p{Nd} for digits",
			"sample_result": "Hello [1][2][3]"
		},
		"\\p{...}": {
			"name": "Unicode Property Match",
			"description": "Matches any character belonging to the specified Unicode property or script category.",
			"sample_expression": "\\p{L} matches any letter",
			"sample_result": "[H][e][l][l][o] 你好 123"
		},
		"\\PX": {
			"name": "Negation of Unicode Property",
			"description": "Matches any character that does not belong to the specified Unicode property.",
			"sample_expression": "\\P{L}, it would match non-letter characters.",
			"sample_result": "Hello [你][好] 123"
		},
		"\\P{...}": {
			"name": "Negation of Unicode Property Match",
			"description": "Matches any character that does not belong to the specified Unicode property or script category.",
			"sample_expression": "\\P{L} matches anything that isn't a letter.",
			"sample_result": "Hello 你好 [1][2][3]"
		},
		"\\Q...\\E": {
			"name": "Literal Match",
			"description": "Quotes a sequence of characters, treating them as literal text instead of interpreting them as regex metacharacters.",
			"sample_expression": "\\Q(2+2)*3?\\E matches the exact string '(2+2)*3?'",
			"sample_result": "Find this: [(2+2)*3?]"
		},
		"\\k{name}": {
			"name": "Named Backreference",
			"description": "Matches the text captured by a named capturing group.",
			"sample_expression": "(?<word>\\w+) captures a word. \\k{name}) references the previously captured word.",
			"sample_result": "[word] [word]"
		},
		"\\k<name>": {
			"name": "Named Backreference (Angle Brackets)",
			"description": "Matches the text captured by a named capturing group, using angle brackets syntax.",
			"sample_expression": "?<word>\\w+)\\s\\k<word> matches repeated words",
			"sample_result": "[apple] [apple]"
		},
		"\\k'name'": {
			"name": "Named Backreference (Single Quotes)",
			"description": "Matches the text captured by a named capturing group, using single quotes syntax.",
			"sample_expression": "(?<'word'>\\w+) captures a word. \\k'word' references the previously captured word.",
			"sample_result": "[banana] [banana]"
		},
		"\\gn": {
			"name": "Backreference to nth Capturing Group",
			"description": "Matches the same text as the nth capturing group.",
			"sample_expression": "(cat) dog \\g1",
			"sample_result": "[cat] dog [cat]"
		},
		"\\g{n}": {
			"name": "Backreference to nth Capturing Group (Alternative Syntax)",
			"description": "Matches the same text as the nth capturing group using curly brace notation.",
			"sample_expression": "(apple) banana \\g{1}",
			"sample_result": "[apple] orange [apple]"
		},
		"\\g{-n}": {
			"name": "Relative Backreference",
			"description": "Matches text captured by the nth previous capturing group.",
			"sample_expression": "car bike car",
			"sample_result": "[car] bike [car]"
		},
		"\\g<n>": {
			"name": "Named Backreference (Angle Brackets)",
			"description": "Matches the text captured by the nth capturing group using angle bracket syntax.",
			"sample_expression": "hello world hello",
			"sample_result": "[hello] world [hello]"
		},
		"\\g<+n>": {
			"name": "Forward Reference",
			"description": "Matches the text of an upcoming capture group.",
			"sample_expression": "123 456 123",
			"sample_result": "[123] 456 [123]"
		},
		"\\g'n'": {
			"name": "Backreference (Single Quotes)",
			"description": "Matches the text captured by the nth capturing group using single quotes.",
			"sample_expression": "yes no yes",
			"sample_result": "[yes] no [yes]"
		},
		"\\g'+n'": {
			"name": "Relative Forward Reference",
			"description": "Matches text in an upcoming capture group.",
			"sample_expression": "A B A",
			"sample_result": "[A] B [A]"
		},
		"\\g{letter}": {
			"name": "Named Backreference (Curly Braces)",
			"description": "Matches the same text captured by the named group 'letter'.",
			"sample_expression": "(?P<letter>red) blue \\g{letter} first captures 'red' in (?P<letter>red), and \\g{letter} ensures that 'red' appears again",
			"sample_result": "[red] blue [red]"
		},
		"\\g<letter>": {
			"name": "Named Backreference (Angle Brackets)",
			"description": "Matches the same text captured by the named group 'letter'.",
			"sample_expression": "(?P<letter>dog) cat \\g<letter> captures 'dog' and ensures it appears again.",
			"sample_result": "[dog] cat [dog]"
		},
		"\\g'letter'": {
			"name": "Named Backreference (Single Quotes)",
			"description": "Matches the same text captured by the named group 'letter'.",
			"sample_expression": "(?P<letter>123) abc \\g'letter' captures '123' and ensures it appears again.",
			"sample_result": "[123] abc [123]"
		},
		"\\g{word}": {
			"name": "Named Backreference in a Sentence",
			"description": "Matches a previously captured word and ensures repetition in a sentence.",
			"sample_expression": "(?P<word>quick) fox jumps over the \\g{word} fox",
			"sample_result": "The [quick] fox jumps over the [quick] fox."
		},
		"\\xYY": {
			"name": "Hex Character YY",
			"description": "Matches a character represented by the hexadecimal value YY.",
			"sample_expression": "\\x41 (\\x41 represents the ASCII character 'A')",
			"sample_result": "[A]pple"
		},
		"\\x{YYYY}": {
			"name": "Unicode Hex Character YYYY",
			"description": "Matches a Unicode character represented by the hexadecimal value YYYY.",
			"sample_expression": "\\x{1F60A} (\\x{1F60A} represents the Unicode character 😊)",
			"sample_result": "Hello there [😊]!"
		},
		"\\ddd": {
			"name": "Octal Character",
			"description": "Matches a character represented by the octal value ddd.",
			"sample_expression": "\\101 (\\101 (octal) corresponds to ASCII 'A')",
			"sample_result": "[A]pple"
		},
		"\\cY": {
			"name": "Control Character Y",
			"description": "Matches the control character represented by Ctrl + Y.",
			"sample_expression": "\\cJ (\\cJ corresponds to Ctrl + J, which is a newline (\\n).)",
			"sample_result": "Hello[\\n]World"
		},
		"[\\b]": {
			"name": "Backspace Character",
			"description": "Matches a backspace character (ASCII 8). Only the backspace character when in a character class.",
			"sample_expression": "abc\\bdef",
			"sample_result": "abc[\\b]def"
		},
		"\\": {
			"name": "Escape Character",
			"description": "Escapes special characters to treat them as literals.",
			"sample_expression": "\\.",
			"sample_result": "File name: report[.]txt"
		}
	},
