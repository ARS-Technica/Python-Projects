"""
The goal of this project is to better familarize myself
with both Python's Tkinter and Regular Expression libraries.

Once finished, this project will allow users to text regular
expressions on a test bed of sample text while simultaneously
offering a cheatsheet of common regex expressions and 
storage for a rolodex of their the most useful regex snippets.
"""

# Revising how Treeview widget panel toggles on and off


# TODO: Move treeview_visible into a function
# TODO: Rearrange buttons on interface
# TODO: Cheetsheet in extenable panel below interface 
# TODO: Create export options
# TODO: Create "View" Menu with laout options
# TODO: Place Regex String beneath text windows    
# TODO: Make search Apply to larger text widget for integration into Text Editor


# Syntax Highlighting for Regex Input
# Add line numbers to match results.
# Save and Load Regular Expressions 
# Menu Options: Add "Save Regex" and "Load Regex" options in the File menu.
# Search History 
# Resizable Widgets
    # Allow the regex_input, test_string_input, and match_result widgets to resize dynamically with the window.
# Regex Validation
    # Provide real-time feedback if the entered regex is invalid, instead of waiting for the "Match" button.
    # Use re.compile() to check the validity of the regex whenever it is edited.
# Refactor into Classes
    # RegexEditor: Main application class.
    # RegexTester: Handles regex matching logic.
    # TreeviewManager: Manages the Treeview widgets.


import tkinter as tk
from tkinter import ttk
import re

import tkinter.filedialog as filedialog # To export search results as an .rtf
from tkinter import simpledialog
from tkinter import messagebox


# Table of Contents:
    # User Interface
    # Matching Functions
    # Treeview Functions
    # Functions for Styling Widgets


# Example data for the Treeview
categories = {
    'Category 0': {'Key1': 'Value1', 'Key2': 'Value2', 'Key3': 'Value3', 'Key4': 'Value4', 'Key5': 'Value5', 'Key6': 'Value6', 'Key7': 'Value7', 'Key8': 'Value8', 'Key9': 'Value9', 'Key10': 'Value10', 'Key11': 'Value11', 'Key12': 'Value12', 'Key13': 'Value13', 'Key14': 'Value14', 'Key15': 'Value15', 'Key16': 'Value16', 'Key17': 'Value17', 'Key18': 'Value18', 'Key19': 'Value19', 'Key20': 'Value20', 'Key21': 'Value21', 'Key22': 'Value22', 'Key23': 'Value23', 'Key24': 'Value24', 'Key25': 'Value25'}, 
    'Category 1': {'Key26': 'Value26', 'Key27': 'Value27', 'Key28': 'Value28', 'Key29': 'Value29', 'Key30': 'Value30', 'Key31': 'Value31', 'Key32': 'Value32', 'Key33': 'Value33', 'Key34': 'Value34', 'Key35': 'Value35', 'Key36': 'Value36', 'Key37': 'Value37', 'Key38': 'Value38', 'Key39': 'Value39', 'Key40': 'Value40', 'Key41': 'Value41', 'Key42': 'Value42', 'Key43': 'Value43', 'Key44': 'Value44', 'Key45': 'Value45', 'Key46': 'Value46', 'Key47': 'Value47', 'Key48': 'Value48', 'Key49': 'Value49', 'Key50': 'Value50'}, 
    'Category 2': {'Key51': 'Value51', 'Key52': 'Value52', 'Key53': 'Value53', 'Key54': 'Value54', 'Key55': 'Value55', 'Key56': 'Value56', 'Key57': 'Value57', 'Key58': 'Value58', 'Key59': 'Value59', 'Key60': 'Value60', 'Key61': 'Value61', 'Key62': 'Value62', 'Key63': 'Value63', 'Key64': 'Value64', 'Key65': 'Value65', 'Key66': 'Value66', 'Key67': 'Value67', 'Key68': 'Value68', 'Key69': 'Value69', 'Key70': 'Value70', 'Key71': 'Value71', 'Key72': 'Value72', 'Key73': 'Value73', 'Key74': 'Value74', 'Key75': 'Value75'}, 
    'Category 3': {'Key76': 'Value76', 'Key77': 'Value77', 'Key78': 'Value78', 'Key79': 'Value79', 'Key80': 'Value80', 'Key81': 'Value81', 'Key82': 'Value82', 'Key83': 'Value83', 'Key84': 'Value84', 'Key85': 'Value85', 'Key86': 'Value86', 'Key87': 'Value87', 'Key88': 'Value88', 'Key89': 'Value89', 'Key90': 'Value90', 'Key91': 'Value91', 'Key92': 'Value92', 'Key93': 'Value93', 'Key94': 'Value94', 'Key95': 'Value95', 'Key96': 'Value96', 'Key97': 'Value97', 'Key98': 'Value98', 'Key99': 'Value99', 'Key100': 'Value100'}, 
    'Category 4': {'Key101': 'Value101', 'Key102': 'Value102', 'Key103': 'Value103', 'Key104': 'Value104', 'Key105': 'Value105', 'Key106': 'Value106', 'Key107': 'Value107', 'Key108': 'Value108', 'Key109': 'Value109', 'Key110': 'Value110', 'Key111': 'Value111', 'Key112': 'Value112', 'Key113': 'Value113', 'Key114': 'Value114', 'Key115': 'Value115', 'Key116': 'Value116', 'Key117': 'Value117', 'Key118': 'Value118', 'Key119': 'Value119', 'Key120': 'Value120', 'Key121': 'Value121', 'Key122': 'Value122', 'Key123': 'Value123', 'Key124': 'Value124', 'Key125': 'Value125'}, 
    'Category 5': {'Key126': 'Value126', 'Key127': 'Value127', 'Key128': 'Value128', 'Key129': 'Value129', 'Key130': 'Value130', 'Key131': 'Value131', 'Key132': 'Value132', 'Key133': 'Value133', 'Key134': 'Value134', 'Key135': 'Value135', 'Key136': 'Value136', 'Key137': 'Value137', 'Key138': 'Value138', 'Key139': 'Value139', 'Key140': 'Value140', 'Key141': 'Value141', 'Key142': 'Value142', 'Key143': 'Value143', 'Key144': 'Value144', 'Key145': 'Value145', 'Key146': 'Value146', 'Key147': 'Value147', 'Key148': 'Value148', 'Key149': 'Value149', 'Key150': 'Value150'}, 
    'Category 6': {'Key151': 'Value151', 'Key152': 'Value152', 'Key153': 'Value153', 'Key154': 'Value154', 'Key155': 'Value155', 'Key156': 'Value156', 'Key157': 'Value157', 'Key158': 'Value158', 'Key159': 'Value159', 'Key160': 'Value160', 'Key161': 'Value161', 'Key162': 'Value162', 'Key163': 'Value163', 'Key164': 'Value164', 'Key165': 'Value165', 'Key166': 'Value166', 'Key167': 'Value167', 'Key168': 'Value168', 'Key169': 'Value169', 'Key170': 'Value170', 'Key171': 'Value171', 'Key172': 'Value172', 'Key173': 'Value173', 'Key174': 'Value174', 'Key175': 'Value175'}, 
    'Category 7': {'Key176': 'Value176', 'Key177': 'Value177', 'Key178': 'Value178', 'Key179': 'Value179', 'Key180': 'Value180', 'Key181': 'Value181', 'Key182': 'Value182', 'Key183': 'Value183', 'Key184': 'Value184', 'Key185': 'Value185', 'Key186': 'Value186', 'Key187': 'Value187', 'Key188': 'Value188', 'Key189': 'Value189', 'Key190': 'Value190', 'Key191': 'Value191', 'Key192': 'Value192', 'Key193': 'Value193', 'Key194': 'Value194', 'Key195': 'Value195', 'Key196': 'Value196', 'Key197': 'Value197', 'Key198': 'Value198', 'Key199': 'Value199', 'Key200': 'Value200'}, 
    'Category 8': {'Key201': 'Value201', 'Key202': 'Value202', 'Key203': 'Value203', 'Key204': 'Value204', 'Key205': 'Value205', 'Key206': 'Value206', 'Key207': 'Value207', 'Key208': 'Value208', 'Key209': 'Value209', 'Key210': 'Value210', 'Key211': 'Value211', 'Key212': 'Value212', 'Key213': 'Value213', 'Key214': 'Value214', 'Key215': 'Value215', 'Key216': 'Value216', 'Key217': 'Value217', 'Key218': 'Value218', 'Key219': 'Value219', 'Key220': 'Value220', 'Key221': 'Value221', 'Key222': 'Value222', 'Key223': 'Value223', 'Key224': 'Value224', 'Key225': 'Value225'}, 
    'Category 9': {'Key226': 'Value226', 'Key227': 'Value227', 'Key228': 'Value228', 'Key229': 'Value229', 'Key230': 'Value230', 'Key231': 'Value231', 'Key232': 'Value232', 'Key233': 'Value233', 'Key234': 'Value234', 'Key235': 'Value235', 'Key236': 'Value236', 'Key237': 'Value237', 'Key238': 'Value238', 'Key239': 'Value239', 'Key240': 'Value240', 'Key241': 'Value241', 'Key242': 'Value242', 'Key243': 'Value243', 'Key244': 'Value244', 'Key245': 'Value245', 'Key246': 'Value246', 'Key247': 'Value247', 'Key248': 'Value248', 'Key249': 'Value249', 'Key250': 'Value250'}, 
    'Category 10': {'Key251': 'Value251', 'Key252': 'Value252', 'Key253': 'Value253', 'Key254': 'Value254', 'Key255': 'Value255', 'Key256': 'Value256', 'Key257': 'Value257', 'Key258': 'Value258', 'Key259': 'Value259', 'Key260': 'Value260', 'Key261': 'Value261', 'Key262': 'Value262', 'Key263': 'Value263', 'Key264': 'Value264', 'Key265': 'Value265', 'Key266': 'Value266', 'Key267': 'Value267', 'Key268': 'Value268', 'Key269': 'Value269', 'Key270': 'Value270', 'Key271': 'Value271', 'Key272': 'Value272', 'Key273': 'Value273', 'Key274': 'Value274', 'Key275': 'Value275'},
    'Category 11': {'Key251': 'Value251', 'Key252': 'Value252', 'Key253': 'Value253', 'Key254': 'Value254', 'Key255': 'Value255', 'Key256': 'Value256', 'Key257': 'Value257', 'Key258': 'Value258', 'Key259': 'Value259', 'Key260': 'Value260', 'Key261': 'Value261', 'Key262': 'Value262', 'Key263': 'Value263', 'Key264': 'Value264', 'Key265': 'Value265', 'Key266': 'Value266', 'Key267': 'Value267', 'Key268': 'Value268', 'Key269': 'Value269', 'Key270': 'Value270', 'Key271': 'Value271', 'Key272': 'Value272', 'Key273': 'Value273', 'Key274': 'Value274', 'Key275': 'Value275'},
    'Category 12': {'Key251': 'Value251', 'Key252': 'Value252', 'Key253': 'Value253', 'Key254': 'Value254', 'Key255': 'Value255', 'Key256': 'Value256', 'Key257': 'Value257', 'Key258': 'Value258', 'Key259': 'Value259', 'Key260': 'Value260', 'Key261': 'Value261', 'Key262': 'Value262', 'Key263': 'Value263', 'Key264': 'Value264', 'Key265': 'Value265', 'Key266': 'Value266', 'Key267': 'Value267', 'Key268': 'Value268', 'Key269': 'Value269', 'Key270': 'Value270', 'Key271': 'Value271', 'Key272': 'Value272', 'Key273': 'Value273', 'Key274': 'Value274', 'Key275': 'Value275'},

}
 

# Global variable to track toggle state
treeview_visible = False
 

# User Interface --------------------------------------------------------------

def create_window():
    """Creates the main window for the application."""
    global root, treeview_frame

    root = tk.Tk()
    root.title("PyRex Regular Expression Editor")
    root.geometry("900x600")

    # Create menu, toolbar, and main widgets
    create_menu(root)
    create_toolbar(root)
    create_widgets(root)

    # Start the main event loop
    root.mainloop()


def create_menu(window):
    """Creates the main menu."""
    menu_bar = tk.Menu(window)

    # File menu
    file_menu = tk.Menu(menu_bar, tearoff=0)
    file_menu.add_command(label="Export to File", command=export_results)
    file_menu.add_separator()
    file_menu.add_command(label="Exit", command=window.destroy)

    # Search menu
    search_menu = tk.Menu(menu_bar, tearoff=0)

    # Toggle between Match Results being returned as Instances or Sentences
    global match_mode_var
    # Create variable for Match Results checkbutton
    # Global variable to track the match mode
    match_mode_var = tk.IntVar(value=0)  # 0 = "Instance", 1 = "Sentence"

    # Add mutually exclusive checkbuttons with toggle logic
    search_menu.add_checkbutton(
        label="Match Instances",
        variable=match_mode_var,
        onvalue=0,
        offvalue=1,
        command=lambda: toggle_search_mode(0)
    )
    search_menu.add_checkbutton(
        label="Match Sentences",
        variable=match_mode_var,
        onvalue=1,
        offvalue=0,
        command=lambda: toggle_search_mode(1)
    )

    # Add menus to the menu bar
    menu_bar.add_cascade(label="File", menu=file_menu)
    menu_bar.add_cascade(label="Search", menu=search_menu)

    window.config(menu=menu_bar)


def create_toolbar(window):
    """Creates a toolbar at the top of the window (for Treeview toggle button)"""
    toolbar = ttk.Frame(window, padding="5")
    toolbar.grid(row=0, column=0, sticky="ew")

    # Toggle button for the Treeview section
    toggle_button = ttk.Button(
        toolbar,
        text="Regular Expressions",
        command=toggle_treeview_visibility
    )
    toggle_button.pack(side="left", padx=5)


def create_widgets(window):
    """Creates the main UI components."""
    global main_frame, treeview_frame

    window.columnconfigure(0, weight=1)
    window.rowconfigure(1, weight=1)

    # Main Frame
    main_frame = ttk.Frame(window, padding="5")
    main_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

    main_frame.columnconfigure(0, weight=1)  # Match button
    main_frame.columnconfigure(1, weight=1)  # Clear Fields button
    main_frame.rowconfigure(1, weight=1)  # Regex and Test String section

    # Create collapsible Treeview Frame (initially hidden)
    treeview_frame = ttk.Frame(window, padding="5")
    treeview_frame.grid(row=2, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
    treeview_frame.columnconfigure(0, weight=1)
    treeview_frame.columnconfigure(1, weight=1)
    create_treeview_section(treeview_frame)
    treeview_frame.grid_remove()  # Start hidden

    # Add Regex Input, Test String, and Match Result Fields
    create_regex_input(main_frame)
    create_test_string_field(main_frame)
    create_match_results_field(main_frame)
    create_buttons(main_frame)


def create_regex_input(parent):
    global regex_input
    ttk.Label(parent, text="Regular Expression:").grid(row=0, column=0, sticky=tk.W)
    regex_input = tk.Text(parent, height=3, wrap="word")
    regex_input.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
    
    # regex_input.insert("end", "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}") # Find Email Addresses
    # regex_input.insert("end", "https?://[^\s]+") # Find URLs
    # regex_input.insert("end", "[A|B][a-z]+")  # Find Words Starting with 'A' or 'B'
    regex_input.insert("end", "[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}")  # Find Domains


def create_test_string_field(parent):
    global test_string_input

    # Test String
    ttk.Label(parent, text="Test String:").grid(row=2, column=0, sticky=tk.W)
    test_string_input = tk.Text(parent, height=10, wrap="word")
    test_string_input.grid(row=3, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

    test_string_input.insert("end",     
    """Alice's email is alice@example.com, and Bob's email is bob@example.org. Contact us at support@company.com or visit our website: https://www.example.com."""
    )


def create_match_results_field(parent):
    global match_result

    # Match Results
    ttk.Label(parent, text="Match Results:").grid(row=2, column=1, sticky=tk.W)
    match_result = tk.Text(parent, height=10, wrap="word", state="disabled")
    match_result.grid(row=3, column=1, sticky=(tk.W, tk.E, tk.N, tk.S))


def create_buttons(parent):
    ttk.Button(parent, text="Match", command=perform_match).grid(row=4, column=0, pady=10)
    ttk.Button(parent, text="Clear Fields", command=clear_fields).grid(row=4, column=1, pady=10)

'''
def create_buttons(parent):
    # Match Button
    match_button = ttk.Button(parent, text="Match", command=perform_match)
    match_button.grid(row=4, column=0, sticky=tk.W, padx=(0, 5), pady=10)

    # Clear Fields Button
    clear_button = ttk.Button(parent, text="Clear Fields", command=clear_fields)
    clear_button.grid(row=4, column=1, sticky=tk.W, padx=(5, 5), pady=10)

    # Show/Hide Treeview Panel Button
    toggle_button = ttk.Button(parent, text="Treeview", command=toggle_treeview_section)
    toggle_button.grid(row=4, column=1, sticky=tk.E, padx=(5, 0), pady=10)

    # Debug: Print grid information
    print(f"Button grid: {parent.grid_slaves()}")
'''

# /User Interface -------------------------------------------------------------


# Matching Functions ----------------------------------------------------------

def perform_match(*args):
    """Determines match mode dynamically and performs the appropriate matching."""
    global match_results_as_instances

    # Prevent Regex execution on empty input
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    if not regex:
        messagebox.showwarning("Input Error", "Regular Expression field cannot be empty.")
        return

    if not test_string:
        messagebox.showwarning("Input Error", "Test String field cannot be empty.")
        return

    # Check the current match mode directly from match_mode_var
    # match_mode (0 = Instances, 1 = Sentences)
    if match_mode_var.get() == 0:
        match_instances(*args)  # Perform instance-level matching
    else:
        match_sentences(*args)  # Perform sentence-level matching


def match_instances(*args):
    """Displays instances of matching search term in Match Result Window"""
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights
    test_string_input.tag_remove("highlight", "1.0", tk.END)

    try:
        # Step 1: Find sentences containing matches
        matches = re.finditer(regex, test_string)
        result = ""

        for match in matches:
            # Step 2: Highlight matches in Test String widget
            start_idx = f"1.0 + {match.start()} chars"
            end_idx = f"1.0 + {match.end()} chars"
            # Highlight the match
            test_string_input.tag_add("highlight", start_idx, end_idx)

            # Add match details to result
            result += f"{match.group()}\n\n"  # Add a blank line after each result

        if not result:
            result = "No matches found."

        # Apply highlighting style
        test_string_input.tag_config("highlight", background="yellow", foreground="black")

        # Update the Match Results widget
        update_match_result(result)

    except re.error as e:
        # Handle regex errors
        update_match_result(f"Invalid regular expression: {str(e)}")
        

def match_sentences(*args):
    """Displays sentences containing instances of matching search term in Match Result Window"""
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights in both widgets
    test_string_input.tag_remove("highlight", "1.0", tk.END)
    match_result.tag_remove("highlight", "1.0", tk.END)

    try:
        # Step 1: Find sentences containing matches
        matches = list(re.finditer(regex, test_string))
        sentences = re.split(r'(?<=[.!?])\s+', test_string)  # Split into sentences

        result_sentences = []  # To store unique sentences with matches
        for match in matches:
            for sentence in sentences:
                if match.group() in sentence and sentence not in result_sentences:
                    result_sentences.append(sentence)
                    break

        # Step 2: Display sentences in match_result
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)

        if result_sentences:
            # Display results
            for sentence in result_sentences:
                match_result.insert(tk.END, sentence + "\n\n")  # Add a blank line after each sentence

            # Highlight matches in match_result
            match_result_text = match_result.get("1.0", tk.END)
            for match in re.finditer(regex, match_result_text):
                start_idx = f"1.0 + {match.start()} chars"
                end_idx = f"1.0 + {match.end()} chars"
                match_result.tag_add("highlight", start_idx, end_idx)

            match_result.tag_config("highlight", background="yellow", foreground="black")
        else:
            result = "No matches found."

        match_result.config(state="disabled")

    except re.error as e:
        # Handle regex errors
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)
        match_result.insert(tk.END, f"Invalid regular expression: {str(e)}")

        match_result.config(state="disabled")


def clear_fields():
    regex_input.delete("1.0", tk.END)
    test_string_input.delete("1.0", tk.END)
    match_result.config(state="normal")
    match_result.delete("1.0", tk.END)
    match_result.config(state="disabled")


def export_results():
    # TODO: Add f-string with name of current open document to header
    # Add a dialog to get header text
    header = simpledialog.askstring(
        "Export Header", "Enter header for exported file:", initialvalue="Search Results:\n")
    if not header:
        header = "Search Results:\n"
    
    header = "\\b " + header + "\\b0"
        

    # Ensure match_result is not empty
    match_result_text = match_result.get("1.0", tk.END).strip()
    if not match_result_text:
        print("No results to export.")
        return

    # Prompt user to save the file
    file_path = filedialog.asksaveasfilename(
        defaultextension=".rtf",
        filetypes=[("Rich Text Format", "*.rtf"), ("All Files", "*.*")]
    )
    if not file_path:
        return  # User cancelled the save dialog

    try:
        # Begin writing the RTF content
        with open(file_path, "w") as file:
            # RTF header with color table for highlighting
            file.write("{\\rtf1\\ansi\\deff0\n")
            file.write("{\\colortbl;\\red255\\green255\\blue0;}\n")  # Define yellow color

            # Add header text with a blank line
            #file.write("Search results from file test.doc:\\line \\line \n")
            #file.write("\\b Search results from file test.doc:\\b0\\line \\line \n")
            file.write(header + "\\line \\line \n")

            # Retrieve text and highlighted regions
            full_text = match_result.get("1.0", tk.END)  # Get the full text
            highlight_ranges = match_result.tag_ranges("highlight")  # Get highlight ranges

            # Initialize absolute position tracker
            current_pos = 0

            for i in range(0, len(highlight_ranges), 2):
                # Get start and end indices of the highlight in absolute positions
                start = match_result.index(highlight_ranges[i])
                end = match_result.index(highlight_ranges[i + 1])

                start_line, start_char = map(int, start.split("."))
                end_line, end_char = map(int, end.split("."))

                # Calculate absolute indices in the text
                start_idx = sum(len(match_result.get(f"{line}.0", f"{line}.end")) + 1 for line in range(1, start_line)) + start_char
                end_idx = sum(len(match_result.get(f"{line}.0", f"{line}.end")) + 1 for line in range(1, end_line)) + end_char

                # Write normal text before the highlight
                if current_pos < start_idx:
                    normal_text = full_text[current_pos:start_idx]
                    file.write(normal_text.replace("\n", "\\line ") + "\n")

                # Write highlighted text
                highlighted_text = full_text[start_idx:end_idx]
                file.write("{\\highlight1 " + highlighted_text.replace("\n", "\\line ") + "}\n")

                # Update the current position
                current_pos = end_idx

            # Write any remaining text after the last highlight
            if current_pos < len(full_text):
                remaining_text = full_text[current_pos:]
                file.write(remaining_text.replace("\n", "\\line ") + "\n")

            # End the RTF content
            file.write("}")
            
        # Notify user of successful export
        print(f"Results exported to {file_path}")
        messagebox.showinfo("Export Successful", f"Results saved to {file_path}")

    except Exception as e:
        print(f"Error exporting results: {e}")
        messagebox.showerror("Export Error", f"Failed to save file: {str(e)}")


def toggle_search_mode(new_mode):
    """Toggles between match modes and re-runs the search if results are present."""
    # Update the match_mode_var to reflect the new mode
    match_mode_var.set(new_mode)

    def is_match_result_empty():
        """Checks if the match_result text widget is empty."""
        content = match_result.get("1.0", tk.END).strip()  # Get all text and remove surrounding whitespace
        return len(content) == 0  # True if empty, False otherwise

    # Check if match_result has content
    if not is_match_result_empty():
        # Re-run the search in the new mode
        perform_match()
    else:
        print(f"Search mode set to: {'Instances' if new_mode == 0 else 'Sentences'}")


def update_match_result(text):
    match_result.config(state='normal')
    match_result.delete("1.0", tk.END)
    match_result.insert(tk.END, text)
    match_result.config(state='disabled')

# /Matching Functions ---------------------------------------------------------



# Treeview Functions ---------------------------------------------------------

def create_treeview_section(parent):
    global treeview_frame, category_tree, key_value_tree, is_treeview_visible

    # Treeview section frame (initially visible)
    treeview_frame = ttk.Frame(parent, padding="5")
    treeview_frame.grid(row=5, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
    treeview_frame.columnconfigure(0, weight=1)
    treeview_frame.columnconfigure(1, weight=1)
    is_treeview_visible = True  # Track visibility state

    # Category Treeview
    category_tree = create_category_treeview(treeview_frame)
    category_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 5))
    category_tree.bind("<<TreeviewSelect>>", lambda event: on_category_select(event, key_value_tree))

    # Key-Value Treeview
    key_value_tree = create_key_value_treeview(treeview_frame)
    key_value_tree.grid(row=0, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(5, 0))


def create_category_treeview(parent):
    """Creates the Category Treeview with styles."""
    configure_treeview_style()
    tree = ttk.Treeview(parent, show="tree", selectmode="browse", style="Custom.Treeview") 
    # style="Custom.Treeview" ensures that the Treeview's alternate row styling is visible

    scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
    scrollbar.grid(row=0, column=1, sticky="ns")
    tree.configure(yscrollcommand=scrollbar.set)

    for category in categories.keys():
        tree.insert("", "end", text=category)

    return tree


def create_key_value_treeview(parent):
    """Creates the Key-Value Treeview with styles and alternating row colors."""
    tree = ttk.Treeview(parent, columns=("Key", "Value"), show="headings", style="Custom.Treeview")
    tree.heading("Key", text="Key")
    tree.heading("Value", text="Value")
    tree.column("Key", width=50, anchor="w")
    tree.column("Value", width=300, anchor="w")

    scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
    scrollbar.grid(row=0, column=2, sticky="ns")
    tree.configure(yscrollcommand=scrollbar.set)

    apply_row_styles(tree)
    configure_hover_effect(tree)

    # Bind double-click to append the key to the regex_input
    tree.bind("<Double-Button-1>", lambda event: on_key_double_click(event, tree))

    return tree


def display_key_value_pairs(category, key_value_tree):
    """Populates the Key-Value Treeview with keys and values from the selected category."""

    key_value_tree.delete(*key_value_tree.get_children())  # Clear existing data
    
    if category in categories:
        for key, value in categories[category].items():
            key_value_tree.insert("", "end", values=(key, value))  # Add both key and value


def on_category_select(event, key_value_tree):
    """Handles selection in the Category Treeview."""

    selected_item = category_tree.focus()

    if selected_item:
        category = category_tree.item(selected_item, "text")
        display_key_value_pairs(category, key_value_tree)
        apply_row_styles(key_value_tree)  # Apply styles to the rows
        

def on_key_double_click(event, tree):
    """Handles double-clicks on the Key-Value Treeview by appending the key to the regex_input field."""
    # Get the selected item
    selected_item = tree.focus()
    if not selected_item:
        return  # No item selected

    # Retrieve the key from the selected row
    selected_values = tree.item(selected_item, "values")
    if selected_values:
        key = selected_values[0]  # The key is in the first column

        # Append the key to the regex_input
        current_text = regex_input.get("1.0", tk.END).strip()  # Get current content
        new_text = current_text + key  # Append the key
        regex_input.delete("1.0", tk.END)  # Clear the current content
        regex_input.insert("1.0", new_text)  # Insert the updated content


def toggle_treeview_section():
    """Toggles the visibility of the Treeview panel."""
    global is_treeview_visible

    if is_treeview_visible:
        treeview_frame.grid_remove()  # Hide the Treeview frame
        is_treeview_visible = False
    else:
        treeview_frame.grid()  # Show the Treeview frame
        is_treeview_visible = True

    root.update()  # Ensure layout updates


def toggle_treeview_visibility():
    """Toggles the visibility of the Treeview frame."""
    global treeview_visible, treeview_frame

    treeview_visible = not treeview_visible

    if treeview_visible:
        treeview_frame.grid()  # Show the frame
    else:
        treeview_frame.grid_remove()  # Hide the frame

# /Treeview Functions ---------------------------------------------------------




# Treeview Styling Functions --------------------------------------------------

def apply_row_styles(tree):
    """Applies alternating row styles to the Treeview."""
    for i, child in enumerate(tree.get_children()):
        if i % 2 == 0:
            tree.tag_configure("evenrow", background="white")
            tree.item(child, tags=("evenrow",))
        else:
            tree.tag_configure("oddrow", background="#f2f2f2")
            tree.item(child, tags=("oddrow",))


def configure_hover_effect(tree):
    """Configures the hover effect for the Treeview rows."""
    def on_mouse_over(event):
        item_id = tree.identify_row(event.y)
        for child in tree.get_children():
            tree.tag_configure("hover", background="#d9d9d9")
            apply_row_styles(tree)
        if item_id:
            tree.item(item_id, tags=("hover",))

    def on_mouse_leave(event):
        apply_row_styles(tree)

    tree.bind("<Motion>", on_mouse_over)
    tree.bind("<Leave>", on_mouse_leave)


def configure_treeview_style():
    """Configures the Treeview widget style."""
    style = ttk.Style()
    style.configure("Custom.Treeview", rowheight=25)
    style.map(
        "Custom.Treeview",
        background=[("selected", "#cce5ff")],
        foreground=[("selected", "black")],
    )


def on_double_click(event):
    """Handles the double-click event on a Treeview row."""
    item_id = event.widget.focus()
    item = event.widget.item(item_id)
    item_text = item["text"]  # Get the text from the first column ("Item")
    if item_text:
        regex_entry.delete(0, tk.END)  # Clear the current text
        regex_entry.insert(0, item_text)  # Insert the "Item" text

# Treeview Styling Functions -----------------------------------------------


if __name__ == "__main__":
    create_window()

