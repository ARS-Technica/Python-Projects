# Working
# Adding regular expressions to Treeview Widget

# Next: Add Examples to each regular expression.  Add widget to view examples.


import tkinter as tk
from tkinter import ttk
import re

import tkinter.filedialog as filedialog # To export search results as an .rtf
from tkinter import simpledialog
from tkinter import messagebox


# Table of Contents:
    # User Interface
    # Matching Functions
    # Treeview Functions
    # Functions for Styling Widgets


# Example data for the Treeview

categories = {
    "All Tokens": { }, "Common Tokens": { }, "General Tokens": { }, "Anchors": { }, "Meta Sequences": { },         
    "Quantifiers": { }, "Group Constructs": { }, "Character Classes": { }, "Flags/Modifiers": { }, 
    "Category 9": { }, "Substitution": { }, 
}


categories = {
    "All Tokens": { "",    
        }, 
    "Common Tokens": {
        "[abc]": "Match a single character present in the set",
        "[^abc]": "Match a single character NOT present in the set",
        "[a-z]": "Match a single character in the range a-z",
        "[^a-z]": "Match a single character NOT in the range a-z",
        "[a-zA-Z]": "Match a single character in the range a-z or A-Z",
        ".": "Match any character except line terminators",
        "a|b": "Match either a or b",
        "\s": "Match any whitespace character",
        "\S": "Match any non-whitespace character",
        "\d": "Match any digit character",
        "\D": "Match any non-digit character",
        "\w": "Match any word character",
        "\W": "Match any non-word character",
        "(?:...)": "Non-capturing group",
        "(...)": "Capturing group",
        "a?": "Match zero or one of a",
        "a*": "Match zero or more of a",
        "a+": "Match one or more of a",
        "a{3}": "Match exactly 3 of a",
        "a{3,}": "Match 3 or more of a",
        "a{3,6}": "Match between 3 and 6 of a",
        "^": "Start of string or line",
        "$": "End of string or line",
        "\b": "A word boundary",
        "\B": "Non-word boundry",
    },    
    "General Tokens": {
        "\0": "Null character",
        "\n": "Match newline character",
        "\r": "Match carriage return character"
        "\t": "Match tab character",
        }, 
    "Anchors": {
        "\G": "Start of match",
        "^": "Start of string or line",
        "$": "End of string or line",
        "\A": "Start of string",
        "\z": "Absolute end of string",        
        "\Z": "End of string",
        "\b": "Word boundary",
        "\B": "Non-word boundary",
        }, 
    "Meta Sequences": {
        ".": "Matches any character except a newline",
        "a|b": "Acts as an OR operator between expressions",
        "\s": "Match any whitespace character [ \t\n\r\f]",
        "\S": "Match any non-whitespace character [^ \t\n\r\f]",
        "\d": "Match any digit character [0-9]",
        "\D": "Match any non-digit character [^0-9]",
        "\w": "Match any word character [a-zA-Z0-9_]",
        "\W": "Match any non-word character [^a-zA-Z0-9_]",
        "\X": "Any Unicode sequences, linebreaks included",
        "\C": "Match one data unit",
        "\R": "Unicode newlines",
        "\N": "Match anything but a newline",
        "\v": "Vertical whitespace character",
        "\V": "Negation of \v",
        "\h": "Horizontal whitespace character",
        "\H": "Negation of \h",
        "\K": "Reset match",
        "\#": "Match subpattern number",
        "\pX": "Unicode property X",
        "\p{...}": "Unicode property or script category",
        "\PX": "Negation of \PX",
        "\P{...}": "Negation of \P",
        "\Q...\E": "Quote; Treat as literals",
        "\k{name}": "Match subpatter 'name",
        "\k<name>": "Match subpattern 'name",
        "\k'name'": "Match subpattern 'name",
        "\gn": "Match nth subpattern",
        "\g{n}": "Match nth subpattern",
        "\g{-n}": "Match text in the relative previous subpattern matched",
        "\g<n>": "Match expression defined in the nth capture group",
        "\g<+n>": "Match expression defined in the nth capture group",
        "\g'n'": "Match expression defined in the nth capture group",
        "\g'+n'": "Match expression defined in the nth relative upcoming subpattern",
        "\g{letter}": "Matches the same text capture group called `letter` matched and captured",       
        "\g<letter>": "Match expression defined in the capture group called 'letter'",     
        "\g'letter'": "Match expression defined in the capture group called 'letter'",        
        "\xYY": "Hex character YY",
        "x{YYYY}": "Hex character YYYY",
        "\ddd": "Octal character ddd",
        "\cY": "Control character Y",
        "[\b]": "Backspace character",
        "\\": "Makes any character literal",
        }, 
    "Quantifiers": {
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        }, 
    "Group Constructs": {
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        }, 
    "Character Classes": {
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        }, 
    "Flags/Modifiers": {
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        }, 
    "Category 9": {
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        }, 
    "Substitution": {
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        }, 
}


saved_expressions = {
    "Category Alpha": {"Key1": "Value1", "Key2": "Value2", "Key3": "Value3", "Key4": "Value4", "Key5": "Value5", "Key6": "Value6", "Key7": "Value7", "Key8": "Value8", "Key9": "Value9", "Key10": "Value10", "Key11": "Value11", "Key12": "Value12", "Key13": "Value13", "Key14": "Value14", "Key15": "Value15", "Key16": "Value16", "Key17": "Value17", "Key18": "Value18", "Key19": "Value19", "Key20": "Value20", "Key21": "Value21", "Key22": "Value22", "Key23": "Value23", "Key24": "Value24", "Key25": "Value25"},
    "Category Bravo": {"Key26": "Value26", "Key27": "Value27", "Key28": "Value28", "Key29": "Value29", "Key30": "Value30", "Key31": "Value31", "Key32": "Value32", "Key33": "Value33", "Key34": "Value34", "Key35": "Value35", "Key36": "Value36", "Key37": "Value37", "Key38": "Value38", "Key39": "Value39", "Key40": "Value40", "Key41": "Value41", "Key42": "Value42", "Key43": "Value43", "Key44": "Value44", "Key45": "Value45", "Key46": "Value46", "Key47": "Value47", "Key48": "Value48", "Key49": "Value49", "Key50": "Value50"}, 
    "Category Delta": {"Key51": "Value51", "Key52": "Value52", "Key53": "Value53", "Key54": "Value54", "Key55": "Value55", "Key56": "Value56", "Key57": "Value57", "Key58": "Value58", "Key59": "Value59", "Key60": "Value60", "Key61": "Value61", "Key62": "Value62", "Key63": "Value63", "Key64": "Value64", "Key65": "Value65", "Key66": "Value66", "Key67": "Value67", "Key68": "Value68", "Key69": "Value69", "Key70": "Value70", "Key71": "Value71", "Key72": "Value72", "Key73": "Value73", "Key74": "Value74", "Key75": "Value75"}, 
    "Category Epsilon": {"Key76": "Value76", "Key77": "Value77", "Key78": "Value78", "Key79": "Value79", "Key80": "Value80", "Key81": "Value81", "Key82": "Value82", "Key83": "Value83", "Key84": "Value84", "Key85": "Value85", "Key86": "Value86", "Key87": "Value87", "Key88": "Value88", "Key89": "Value89", "Key90": "Value90", "Key91": "Value91", "Key92": "Value92", "Key93": "Value93", "Key94": "Value94", "Key95": "Value95", "Key96": "Value96", "Key97": "Value97", "Key98": "Value98", "Key99": "Value99", "Key100": "Value100"}, 
}
 
 
# Global variable to track toggle state
treeview_visible = False
current_data = categories  # Default to "categories"


# User Interface --------------------------------------------------------------

def create_window():
    """Creates the main window for the application with dynamic initial height."""
    global root, treeview_frame

    root = tk.Tk()
    root.title("PyRex Regular Expression Editor")
    root.geometry("900x1")  # Temporary small height to calculate actual needed height

    # Create menu, toolbar, and main widgets
    create_menu(root)
    create_toolbar(root)
    create_widgets(root)

    # Update the window to compute widget sizes
    root.update_idletasks()

    # Dynamically adjust the initial window size based on the widgets' required size
    initial_height = root.winfo_reqheight()  # Required height after widgets are placed
    root.geometry(f"900x{initial_height}")  # Set the correct initial height

    # Start the main event loop
    root.mainloop()


def create_menu(window):
    """Creates the main menu."""
    menu_bar = tk.Menu(window)

    # File menu
    file_menu = tk.Menu(menu_bar, tearoff=0)
    #file_menu.add_command(label="Export to File", command=export_results)
    file_menu.add_command(label="Save Expression", command=open_save_expression_popup)
    file_menu.add_separator()
    file_menu.add_command(label="Exit", command=window.destroy)

    # Search menu
    search_menu = tk.Menu(menu_bar, tearoff=0)

    # Toggle between Match Results being returned as Instances or Sentences
    global match_mode_var
    # Create variable for Match Results checkbutton
    # Global variable to track the match mode
    match_mode_var = tk.IntVar(value=0)  # 0 = "Instance", 1 = "Sentence"

    # Add mutually exclusive checkbuttons with toggle logic
    search_menu.add_checkbutton(
        label="Match Instances",
        variable=match_mode_var,
        onvalue=0,
        offvalue=1,
        command=lambda: toggle_search_mode(0)
    )
    search_menu.add_checkbutton(
        label="Match Sentences",
        variable=match_mode_var,
        onvalue=1,
        offvalue=0,
        command=lambda: toggle_search_mode(1)
    )

    # View menu
    view_menu = tk.Menu(menu_bar, tearoff=0)

    # Toggle between the Treeview Panel with one of two datasets
    view_menu.add_command(
        label="Regular Expression Cheatsheet",
        command=lambda: toggle_treeview_with_data(categories)
    )
    view_menu.add_command(
        label="Saved Expressions",
        command=lambda: toggle_treeview_with_data(saved_expressions)
    )   

    # Add menus to the menu bar
    menu_bar.add_cascade(label="File", menu=file_menu)
    menu_bar.add_cascade(label="Search", menu=search_menu)
    menu_bar.add_cascade(label="View", menu=view_menu)

    window.config(menu=menu_bar)


def create_widgets(window):
    """Creates the main UI components by delegating to helper functions."""
    global main_frame, treeview_frame

    # Configures the grid layout of the main window.
    #configure_window_grid(window)
    window.columnconfigure(0, weight=1)  	# Single column
    window.rowconfigure(1, weight=1)    	# Main frame (static widgets)
    window.rowconfigure(2, weight=0)    	# Treeview frame (toggling widget)

    # Create Toolbar
    create_toolbar(window)

    # Main Frame (Fixed Widgets)
    main_frame = create_main_frame(window)

    # Add Widgets to Main Frame
    create_regex_input(main_frame)    
    create_test_string_field(main_frame)
    create_match_results_field(main_frame)
    create_buttons(main_frame)

    # Create Collapsible Treeview Panel
    treeview_frame = create_treeview_panel(window)


def create_toolbar(window):
    """Creates a toolbar at the top of the window (for Treeview toggle buttons)"""
    toolbar = ttk.Frame(window, padding="5")
    toolbar.grid(row=0, column=0, sticky="ew")

    # Button to toggle RegEx CheatSheet
    ttk.Button(
        toolbar,
        text="RegEx CheatSheet",
        command=lambda: toggle_treeview_with_data(categories)
    ).pack(side="left", padx=5)

    # Button to toggle Saved Expressions
    ttk.Button(
        toolbar,
        text="Saved Expressions",
        command=lambda: toggle_treeview_with_data(saved_expressions)
    ).pack(side="left", padx=5)


def create_main_frame(window):
    """Creates the main frame and configures its layout."""
    main_frame = ttk.Frame(window, padding="5")  # Add padding to the main frame
    main_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=10, pady=0)  # Add padding to the grid

    # Configure main_frame grid
    main_frame.columnconfigure(0, weight=1)
    main_frame.columnconfigure(1, weight=1)
    main_frame.rowconfigure(0, weight=0)  # Regular Expression label (fixed)
    main_frame.rowconfigure(1, weight=0)  # Regular Expression input (fixed)
    main_frame.rowconfigure(2, weight=0)  # Test String/Match Results labels (fixed)
    main_frame.rowconfigure(3, weight=0)  # Test String/Match Results widgets (expandable)
    main_frame.rowconfigure(4, weight=0)  # Buttons row (fixed)

    return main_frame


def create_regex_input(parent):
    """Adds a regular expression input field to the given parent frame."""
    global regex_input

    ttk.Label(parent, text="Regular Expression:").grid(row=0, column=0, columnspan=2, sticky=tk.W, pady=(5, 2))
    regex_input = tk.Text(parent, height=3, wrap="word")
    regex_input.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(2, 5))
    
    # regex_input.insert("end", "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}") # Find Email Addresses
    # regex_input.insert("end", "https?://[^\s]+") # Find URLs
    # regex_input.insert("end", "[A|B][a-z]+")  # Find Words Starting with 'A' or 'B'
    regex_input.insert("end", "[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}")  # Find Domains


def create_test_string_field(parent):
    """Adds test string text field to the left column of the given parent frame."""
    global test_string_input

    # Test String
    ttk.Label(parent, text="Test String:").grid(row=2, column=0, sticky=tk.W, pady=(5, 2))
    test_string_input = tk.Text(parent, height=10, wrap="word")
    test_string_input.grid(row=3, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 5))

    test_string_input.insert("end",     
    """Alice's email is alice@example.com, and Bob's email is bob@example.org. Contact us at support@company.com or visit our website: https://www.example.com."""
    )


def create_match_results_field(parent):
    """Adds match results text field to the right column of the given parent frame."""
    global match_result

    # Match Results
    ttk.Label(parent, text="Match Results:").grid(row=2, column=1, sticky=tk.W, pady=(5, 2))
    match_result = tk.Text(parent, height=10, wrap="word", state="disabled")
    match_result.grid(row=3, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(5, 0))


def create_buttons(parent):
    """Adds buttons to the given parent frame."""
    button_frame = ttk.Frame(parent)
    button_frame.grid(row=4, column=0, columnspan=2, sticky=tk.EW)
    button_frame.columnconfigure(0, weight=1)
    button_frame.columnconfigure(1, weight=1)

    ttk.Button(button_frame, text="Clear Fields", command=clear_fields).grid(row=0, column=0, pady=5, sticky=tk.W)
    ttk.Button(button_frame, text="Match", command=perform_match).grid(row=0, column=1, pady=5, sticky=tk.E)


def create_treeview_panel(window):
    global treeview_frame
    treeview_frame = ttk.Frame(window, padding="5")  # Add padding to the main frame
    treeview_frame.grid(row=2, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=10, pady=0)  # Add padding to the grid
    treeview_frame.columnconfigure(0, weight=1)
    treeview_frame.columnconfigure(1, weight=1)

    # Create Treeview and add it to the first row
    create_treeview_section(treeview_frame, 0)

    # Add a spacer row using a Frame with a fixed height
    spacer = ttk.Frame(treeview_frame, height=10)
    spacer.grid(row=1, column=0, columnspan=2, sticky="nsew")

    treeview_frame.rowconfigure(0, weight=1)  # Make the Treeview row expandable
    treeview_frame.rowconfigure(1, weight=0)  # Make the spacer row fixed height

    treeview_frame.grid_remove()  # Start hidden
    return treeview_frame

# /User Interface -------------------------------------------------------------


# Save RegEx Pop-Up Interface ------------------------------------------------


def open_save_expression_popup():
    """
    Opens a popup window for saving a regular expression.
    """
    popup = tk.Toplevel(root)
    popup.title("Save Regular Expression")
    popup.geometry("500x275")
    popup.resizable(False, False)  # Prevent resizing
    popup.transient(root)  # Set the popup as a child of the main window

    # Frames for layout
    category_frame = ttk.Frame(popup, padding="10")
    category_frame.grid(row=0, column=0, sticky="nsew")
    regex_frame = ttk.Frame(popup, padding="10")
    regex_frame.grid(row=1, column=0, sticky="nsew")
    description_frame = ttk.Frame(popup, padding="10")
    description_frame.grid(row=2, column=0, sticky="nsew")
    button_frame = ttk.Frame(popup, padding="10")
    button_frame.grid(row=3, column=0, sticky="ew")

    # Configure column weights for proper layout
    popup.columnconfigure(0, weight=1)
    category_frame.columnconfigure(1, weight=1)
    regex_frame.columnconfigure(0, weight=1)
    description_frame.columnconfigure(0, weight=1)
    button_frame.columnconfigure(0, weight=1)
    button_frame.columnconfigure(1, weight=1)

    # Category Section
    ttk.Label(category_frame, text="Category:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    category_combobox = ttk.Combobox(category_frame, values=list(saved_expressions.keys()), state="readonly", width=30)
    category_combobox.grid(row=0, column=1, sticky=tk.W, padx=(5, 0))
    add_category_button = ttk.Button(category_frame, text="Add Category", command=lambda: add_new_category(category_combobox))
    add_category_button.grid(row=0, column=2, padx=(5, 0))

    # Regular Expression Display
    ttk.Label(regex_frame, text="Regular Expression:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    regex_display = tk.Text(regex_frame, height=3, wrap="word", width=60, state="disabled")
    regex_display.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), padx=(0, 0))

    # Populate the Regular Expression field
    regex_content = regex_input.get("1.0", tk.END).strip()
    if regex_content:  # Ensure regex_input has content
        regex_display.configure(state="normal")  # Temporarily make it editable
        regex_display.insert("1.0", regex_content)  # Insert the regex
        regex_display.configure(state="disabled")  # Disable editing again

    # Description Field
    ttk.Label(description_frame, text="Description:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    description_field = tk.Text(description_frame, height=3, wrap="word", width=60)
    description_field.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), padx=(0, 0))

    # Save and Cancel Buttons
    save_button = ttk.Button(
        button_frame,
        text="Save",
        command=lambda: save_expression(category_combobox, regex_display, description_field, popup)
    )
    save_button.grid(row=0, column=0, sticky=tk.E, padx=5)

    cancel_button = ttk.Button(button_frame, text="Cancel", command=popup.destroy)
    cancel_button.grid(row=0, column=1, sticky=tk.W, padx=5)


def add_new_category(category_combobox):
    """
    Prompts the user to add a new category to the saved_expressions dictionary.
    """
    
    new_category = simpledialog.askstring("New Category", "Enter the name of the new category:")
    
    if new_category and new_category.strip():
        new_category = new_category.strip()
        if new_category not in saved_expressions:
            saved_expressions[new_category] = {}  # Add new category to the dictionary
            category_combobox["values"] = list(saved_expressions.keys())  # Refresh combobox
            category_combobox.set(new_category)  # Auto-select the new category
        else:
            messagebox.showinfo("Info", f"The category '{new_category}' already exists.")
		   

def save_expression(category_combobox, regex_display, description_field, popup):
    """
    Saves the current regular expression and description to the selected category
    in the `saved_expressions` nested dictionary.
    """
    # Get the selected category
    category = category_combobox.get().strip()
    if not category:
        messagebox.showerror("Error", "Category cannot be empty.")
        return

    # Get the regex from regex_display
    regex = regex_display.get("1.0", tk.END).strip()
    if not regex:
        messagebox.showerror("Error", "Regular Expression cannot be empty.")
        return

    # Get the description
    description = description_field.get("1.0", tk.END).strip()
    if not description:
        messagebox.showerror("Error", "Description cannot be empty.")
        return

    # Add the expression to the saved_expressions dictionary
    is_new_category = False
    if category not in saved_expressions:
        saved_expressions[category] = {}
        is_new_category = True

    saved_expressions[category][regex] = description

    # Notify the user
    messagebox.showinfo("Success", f"Expression saved to category '{category}'.")

    # Highlight the saved expression and category if Treeview Panel is open
    if treeview_visible and toggle_treeview_with_data._last_data_id == id(saved_expressions):
        if is_new_category:
            # Refresh the entire Treeview for new category
            populate_treeview(saved_expressions)
        else:
            # Update only the right-side Treeview for the current category
            if category in saved_expressions:
                display_key_value_pairs(saved_expressions[category], key_value_tree)

        # Highlight the category in category_tree
        for child in category_tree.get_children():
            item_text = category_tree.item(child, "text")
            if item_text == category:  # Match the saved category
                category_tree.selection_set(child)  # Highlight the saved category
                category_tree.see(child)  # Scroll to the saved category
                break

        # Highlight the newly saved expression in key_value_tree
        for child in key_value_tree.get_children():
            item = key_value_tree.item(child)
            if item["values"] and item["values"][0] == regex:  # Match the saved regex
                key_value_tree.selection_set(child)  # Highlight the saved expression
                key_value_tree.see(child)  # Scroll to the saved expression
                break

    # Close the popup
    popup.destroy()

# /Save RegEx Pop-Up Interface ------------------------------------------------


# Matching Functions ----------------------------------------------------------

def perform_match(*args):
    """Determines match mode dynamically and performs the appropriate matching."""
    global match_results_as_instances

    # Prevent Regex execution on empty input
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    if not regex:
        messagebox.showwarning("Input Error", "Regular Expression field cannot be empty.")
        return

    if not test_string:
        messagebox.showwarning("Input Error", "Test String field cannot be empty.")
        return

    # Check the current match mode directly from match_mode_var
    # match_mode (0 = Instances, 1 = Sentences)
    if match_mode_var.get() == 0:
        match_instances(*args)  # Perform instance-level matching
    else:
        match_sentences(*args)  # Perform sentence-level matching


def match_instances(*args):
    """Displays instances of matching search term in Match Result Window"""
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights
    test_string_input.tag_remove("highlight", "1.0", tk.END)

    try:
        # Step 1: Find sentences containing matches
        matches = re.finditer(regex, test_string)
        result = ""

        for match in matches:
            # Step 2: Highlight matches in Test String widget
            start_idx = f"1.0 + {match.start()} chars"
            end_idx = f"1.0 + {match.end()} chars"
            # Highlight the match
            test_string_input.tag_add("highlight", start_idx, end_idx)

            # Add match details to result
            result += f"{match.group()}\n\n"  # Add a blank line after each result

        if not result:
            result = "No matches found."

        # Apply highlighting style
        test_string_input.tag_config("highlight", background="yellow", foreground="black")

        # Update the Match Results widget
        update_match_result(result)

    except re.error as e:
        # Handle regex errors
        update_match_result(f"Invalid regular expression: {str(e)}")

        
def match_sentences(*args):
    """Displays sentences containing instances of matching search term in Match Result Window"""
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights in both widgets
    test_string_input.tag_remove("highlight", "1.0", tk.END)
    match_result.tag_remove("highlight", "1.0", tk.END)

    try:
        # Step 1: Find sentences containing matches
        matches = list(re.finditer(regex, test_string))
        sentences = re.split(r'(?<=[.!?])\s+', test_string)  # Split into sentences

        result_sentences = []  # To store unique sentences with matches
        for match in matches:
            for sentence in sentences:
                if match.group() in sentence and sentence not in result_sentences:
                    result_sentences.append(sentence)
                    break

        # Step 2: Display sentences in match_result
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)

        if result_sentences:
            # Display results
            for sentence in result_sentences:
                match_result.insert(tk.END, sentence + "\n\n")  # Add a blank line after each sentence

            # Highlight matches in match_result
            match_result_text = match_result.get("1.0", tk.END)
            for match in re.finditer(regex, match_result_text):
                start_idx = f"1.0 + {match.start()} chars"
                end_idx = f"1.0 + {match.end()} chars"
                match_result.tag_add("highlight", start_idx, end_idx)

            match_result.tag_config("highlight", background="yellow", foreground="black")
        else:
            result = "No matches found."

        match_result.config(state="disabled")

    except re.error as e:
        # Handle regex errors
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)
        match_result.insert(tk.END, f"Invalid regular expression: {str(e)}")

        match_result.config(state="disabled")


def clear_fields():
    #regex_input.delete("1.0", tk.END)
    test_string_input.delete("1.0", tk.END)
    match_result.config(state="normal")
    match_result.delete("1.0", tk.END)
    match_result.config(state="disabled")


def export_results():
    # TODO: Add f-string with name of current open document to header
    # Add a dialog to get header text
    header = simpledialog.askstring(
        "Export Header", "Enter header for exported file:", initialvalue="Search Results:\n")
    if not header:
        header = "Search Results:\n"
    
    header = "\\b " + header + "\\b0"
        

    # Ensure match_result is not empty
    match_result_text = match_result.get("1.0", tk.END).strip()
    if not match_result_text:
        print("No results to export.")
        return

    # Prompt user to save the file
    file_path = filedialog.asksaveasfilename(
        defaultextension=".rtf",
        filetypes=[("Rich Text Format", "*.rtf"), ("All Files", "*.*")]
    )
    if not file_path:
        return  # User cancelled the save dialog

    try:
        # Begin writing the RTF content
        with open(file_path, "w") as file:
            # RTF header with color table for highlighting
            file.write("{\\rtf1\\ansi\\deff0\n")
            file.write("{\\colortbl;\\red255\\green255\\blue0;}\n")  # Define yellow color

            # Add header text with a blank line
            #file.write("Search results from file test.doc:\\line \\line \n")
            #file.write("\\b Search results from file test.doc:\\b0\\line \\line \n")
            file.write(header + "\\line \\line \n")

            # Retrieve text and highlighted regions
            full_text = match_result.get("1.0", tk.END)  # Get the full text
            highlight_ranges = match_result.tag_ranges("highlight")  # Get highlight ranges

            # Initialize absolute position tracker
            current_pos = 0

            for i in range(0, len(highlight_ranges), 2):
                # Get start and end indices of the highlight in absolute positions
                start = match_result.index(highlight_ranges[i])
                end = match_result.index(highlight_ranges[i + 1])

                start_line, start_char = map(int, start.split("."))
                end_line, end_char = map(int, end.split("."))

                # Calculate absolute indices in the text
                start_idx = sum(len(match_result.get(f"{line}.0", f"{line}.end")) + 1 for line in range(1, start_line)) + start_char
                end_idx = sum(len(match_result.get(f"{line}.0", f"{line}.end")) + 1 for line in range(1, end_line)) + end_char

                # Write normal text before the highlight
                if current_pos < start_idx:
                    normal_text = full_text[current_pos:start_idx]
                    file.write(normal_text.replace("\n", "\\line ") + "\n")

                # Write highlighted text
                highlighted_text = full_text[start_idx:end_idx]
                file.write("{\\highlight1 " + highlighted_text.replace("\n", "\\line ") + "}\n")

                # Update the current position
                current_pos = end_idx

            # Write any remaining text after the last highlight
            if current_pos < len(full_text):
                remaining_text = full_text[current_pos:]
                file.write(remaining_text.replace("\n", "\\line ") + "\n")

            # End the RTF content
            file.write("}")
            
        # Notify user of successful export
        print(f"Results exported to {file_path}")
        messagebox.showinfo("Export Successful", f"Results saved to {file_path}")

    except Exception as e:
        print(f"Error exporting results: {e}")
        messagebox.showerror("Export Error", f"Failed to save file: {str(e)}")


def toggle_search_mode(new_mode):
    """Toggles between match modes and re-runs the search if results are present."""
    # Update the match_mode_var to reflect the new mode
    match_mode_var.set(new_mode)

    def is_match_result_empty():
        """Checks if the match_result text widget is empty."""
        content = match_result.get("1.0", tk.END).strip()  # Get all text and remove surrounding whitespace
        return len(content) == 0  # True if empty, False otherwise

    # Check if match_result has content
    if not is_match_result_empty():
        # Re-run the search in the new mode
        perform_match()
    else:
        print(f"Search mode set to: {'Instances' if new_mode == 0 else 'Sentences'}")


def update_match_result(text):
    match_result.config(state='normal')
    match_result.delete("1.0", tk.END)
    match_result.insert(tk.END, text)
    match_result.config(state='disabled')

# /Matching Functions ---------------------------------------------------------


# Treeview Functions ---------------------------------------------------------

def create_treeview_section(parent, row):
    """
    Creates the Treeview section with two widgets: category_tree and key_value_tree.
    """

    global category_tree, key_value_tree

    # Removed code for creating "Tree" that causes Treeview to span two columns

    # Adjust column weights to control widths of the Treeview widgets
    parent.columnconfigure(0, weight=1)  # Left column: Narrower
    parent.columnconfigure(1, weight=4)  # Right column: Wider
    # These two lines of code can be set to weights of 2/2, 1/3, 1/4 or deleted altogether

    # Category Treeview (Left)
    category_tree = create_category_treeview(parent, row)
    category_tree.grid(row=row, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 5))

    # Key-Value Treeview (Right)
    key_value_tree = create_key_value_treeview(parent)
    key_value_tree.grid(row=row, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(5, 0))

    # No need to bind <<TreeviewSelect>> here; populate_treeview handles this dynamically

    # Add some space beneath the Treeview widgets
    parent.grid_rowconfigure(1, weight=1, pad=10)  # Add 10px padding
    
    return parent # If not creating a new "tree" Treeview, return parent


def create_category_treeview(parent, row):
    """Creates the Category Treeview with styles."""
    configure_treeview_style()

    tree = ttk.Treeview(parent, show="tree", selectmode="browse", style="Custom.Treeview") 
    # style="Custom.Treeview" ensures that the Treeview's alternate row styling is visible

    scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
    scrollbar.grid(row=0, column=1, sticky="ns")
    tree.configure(yscrollcommand=scrollbar.set)

    for category in categories.keys():
        tree.insert("", "end", text=category)

    return tree


def create_key_value_treeview(parent):
    """Creates the Key-Value Treeview with styles and alternating row colors."""
    tree = ttk.Treeview(parent, columns=("Key", "Value"), show="headings", style="Custom.Treeview")
    # !Remember: Excluding style="Custom.Treeview" from line above removes alternating row style!

    tree.heading("Key", text="Key")
    tree.heading("Value", text="Value")
    tree.column("Key", width=50, anchor="w")
    tree.column("Value", width=300, anchor="w")

    scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
    scrollbar.grid(row=0, column=2, sticky="ns")
    tree.configure(yscrollcommand=scrollbar.set)

    apply_row_styles(tree)
    configure_hover_effect(tree)

    # Bind double-click to append the key to the regex_input
    tree.bind("<Double-Button-1>", lambda event: on_key_double_click(event, tree))

    return tree


def display_key_value_pairs(category_data, key_value_tree):
    """
    Populates the key_value_tree with the key-value pairs of the selected category
    and applies to row styles immediately.
    """
    # Clear existing data in the right Treeview
    key_value_tree.delete(*key_value_tree.get_children())

    # Insert new key-value pairs
    for key, value in category_data.items():
        key_value_tree.insert("", "end", values=(key, value))

    # Apply row styles immediately after updating the data
    apply_row_styles(key_value_tree)
    
     
def on_key_double_click(event, tree):
    """Handles double-clicks on the Key-Value Treeview by appending the key to the regex_input field."""
    # Get the selected item
    selected_item = tree.focus()
    if not selected_item:
        return  # No item selected

    # Retrieve the key from the selected row
    selected_values = tree.item(selected_item, "values")
    if selected_values:
        key = selected_values[0]  # The key is in the first column

        # Append the key to the regex_input
        current_text = regex_input.get("1.0", tk.END).strip()  # Get current content
        new_text = current_text + key  # Append the key
        regex_input.delete("1.0", tk.END)  # Clear the current content
        regex_input.insert("1.0", new_text)  # Insert the updated content


def populate_treeview(data):
    """
    Populates the category_tree with the given data.
    Clears the key_value_tree to start fresh.
    """
    # Clear the left and right Treeview widgets
    category_tree.delete(*category_tree.get_children())
    key_value_tree.delete(*key_value_tree.get_children())

    # Populate the left Treeview
    for key in data.keys():
        category_tree.insert("", "end", text=key)

    # Set up selection binding for the left Treeview
    # Replaces category_tree.bind lambda in the on_category_select function
    def on_select(event):
        selected_item = category_tree.focus()
        if selected_item:
            category = category_tree.item(selected_item, "text")
            display_key_value_pairs(data.get(category, {}), key_value_tree)

    category_tree.bind("<<TreeviewSelect>>", on_select)


def toggle_treeview_with_data(data):
    """
    Toggles the Treeview Panel on/off or repopulates it if the data changes.
    Efficiently checks if the requested data is the same as the current dataset.
    """
    # Use an attribute to store the last dataset id
    if not hasattr(toggle_treeview_with_data, "_last_data_id"):
        toggle_treeview_with_data._last_data_id = None

    global treeview_visible, treeview_frame

    # Compare the id of the current dataset with the requested dataset
    if treeview_visible and toggle_treeview_with_data._last_data_id == id(data):
        # If the panel is already displaying the requested data, toggle it off
        treeview_frame.grid_remove()
        treeview_visible = False
    else:
        # Show the Treeview Panel and populate with new data
        treeview_frame.grid(row=2, column=0, sticky="nsew")
        populate_treeview(data)
        toggle_treeview_with_data._last_data_id = id(data)
        treeview_visible = True

    # Adjust window size dynamically
    root.update_idletasks()
    new_height = root.winfo_reqheight() # + (100 if treeview_visible else 0) # Too much space!
    root.geometry(f"{root.winfo_width()}x{new_height}")

# /Treeview Functions ---------------------------------------------------------


# Treeview Styling Functions -----------------------------------------------

def apply_row_styles(tree):
    """Applies alternating row styles to the Treeview."""
    for i, child in enumerate(tree.get_children()):
        if i % 2 == 0:
            tree.tag_configure("evenrow", background="white")
            tree.item(child, tags=("evenrow",))
        else:
            tree.tag_configure("oddrow", background="#f2f2f2")
            tree.item(child, tags=("oddrow",))


def configure_hover_effect(tree):
    """Configures the hover effect for the Treeview rows."""
    def on_mouse_over(event):
        item_id = tree.identify_row(event.y)
        for child in tree.get_children():
            tree.tag_configure("hover", background="#d9d9d9")
            apply_row_styles(tree)
        if item_id:
            tree.item(item_id, tags=("hover",))

    def on_mouse_leave(event):
        apply_row_styles(tree)

    tree.bind("<Motion>", on_mouse_over)
    tree.bind("<Leave>", on_mouse_leave)


def configure_treeview_style():
    """Configures the Treeview widget style."""
    style = ttk.Style()
    style.configure("Custom.Treeview", rowheight=25)
    style.map(
        "Custom.Treeview",
        background=[("selected", "#cce5ff")],
        foreground=[("selected", "black")],
    )


def on_double_click(event):
    """Handles the double-click event on a Treeview row."""
    item_id = event.widget.focus()
    item = event.widget.item(item_id)
    item_text = item["text"]  # Get the text from the first column ("Item")
    if item_text:
        regex_input.delete(0, tk.END)  # Clear the current text
        regex_input.insert(0, item_text)  # Insert the "Item" text

# /Treeview Styling Functions -----------------------------------------------


if __name__ == "__main__":
    # Run the application
    create_window()

  


#%%

 
# TODO: Cheetsheet in extenable panel below interface 
# TODO: Create export options
# TODO: Place Regex String beneath text windows    
# TODO: Make search Apply to larger text widget for integration into Text Editor


# Syntax Highlighting for Regex Input

# Add line numbers to match results

# Save and Load Regular Expressions 

# Menu Options: Add "Save Regex" and "Load Regex" options in the File menu.

# Search History 

# Resizable Widgets
    # Allow the regex_input, test_string_input, and match_result widgets to resize dynamically with the window.
    
# Regex Validation
    # Provide real-time feedback if the entered regex is invalid, instead of waiting for the "Match" button.
    # Use re.compile() to check the validity of the regex whenever it is edited.
    
# Refactor into Classes
    # RegexEditor: Main application class.
    # RegexTester: Handles regex matching logic.
    # TreeviewManager: Manages the Treeview widgets.

# Improve Modularity and Code Structure 
    # Separate GUI and Logic Layers: regex matching, data handling, etc
        # gui.py: All GUI-related functions.
        # core.py: Regex logic, data handling, and utility functions.
        # main.py: Initializes and connects GUI with the core logic.
        # Group Similar Functions into Classes or Namespaces:

# Use classes to encapsulate related functionality. For instance:
    # TreeviewManager class to handle all Treeview-related functions (creation, population, styling, events).
    # RegexProcessor class for regex matching and handling user input/output.

# Add Search/Filter for Treeviews:
    # Add a search bar above the left Treeview (category_tree) so users can quickly find a category by name.
    # Add a filter option for the right Treeview (key_value_tree) to limit the visible key-value pairs based on user input.

# Real-Time Regex Matching: regex in real-time as the user types in the regex_input field

# Regex History: Maintain a history of previously entered regex patterns.

# Regex Validation: Add a visual indicator (like a red border or icon) to show whether the entered regex is valid or has syntax errors.

# Regex Syntax Highlighting: Add syntax highlighting for the regex_input field to improve readability

# File Input and Output Load Test String from File
    # Allow users to load a test string from a text file instead of typing it manually.
 
# Allow users to save frequently used regex patterns to a file and reload them later.

# Add keyboard shortcuts for common actions like toggling the Treeview Panel (Ctrl+T), matching (Ctrl+M), and clearing fields (Ctrl+L).

# Resizable Widgets: Allow users to resize the text fields (test_string_input, regex_input, and match_result) dynamically by dragging their edges.

# Help Section: Add a "Help" menu or button to provide guidance on how to use the application, write regex, and interpret results.

# Include links to external regex resources (e.g., cheat sheets or tutorials).

# Group Highlighting: Highlight matched groups (e.g., group 1, group 2, etc.) with different colors in the match_result field.

# Dark Mode

# Custom Styles: Allow users to customize fonts, colors, and sizes of the widgets via a settings menu.

# Improve Large Dataset Handling: If you anticipate loading large dictionaries into the Treeview, consider lazy-loading (populating Treeview items only when a category is expanded).

# Database Integration: Store categories and saved_expressions in a database (like SQLite) for more efficient management and querying.

# Use libraries like pyregex or regex for additional regex features, such as fuzzy matching or Unicode property support.

# Export Results Enhancements: Allow exporting match results to formats like JSON, CSV, or plain text (in addition to .rtf).

