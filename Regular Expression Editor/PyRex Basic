"""
The goal of this project is to better familarize myself
with both Python's Tkinter and Regular Expression libraries.

Once finished, this project will allow users to text regular
expressions on a test bed of sample text while simultaneously
offering a cheatsheet of common regex expressions and 
storage for a rolodex of their the most useful regex snippets.
"""

# Modified perform_match and create_match_result to hide the match_result text widget when not in use


import tkinter as tk
from tkinter import ttk
import re

def create_widgets(root):
    # Configure root to make the application responsive
    root.columnconfigure(0, weight=1)
    root.rowconfigure(0, weight=1)

    # Create main frame
    main_frame = ttk.Frame(root, padding="5")  # Reduce padding
    main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

    # Configure main frame to allow expansion
    main_frame.columnconfigure(0, weight=1)
    main_frame.columnconfigure(1, weight=1)
    main_frame.rowconfigure(1, weight=1)  # Regex input
    main_frame.rowconfigure(3, weight=2)  # Test string input
    main_frame.rowconfigure(5, weight=3)  # Match result

    # Create and place widgets
    create_regex_input(main_frame)
    create_test_string_input(main_frame)
    create_match_result(main_frame)
    create_buttons(main_frame)

def create_regex_input(parent):
    global regex_input
    ttk.Label(parent, text="Regular Expression:").grid(row=0, column=0, sticky=tk.W)
    regex_input = tk.Text(parent, height=3, wrap='word')
    regex_input.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
    # regex_input.insert("end", "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}") # Find Email Addresses
    # regex_input.insert("end", "https?://[^\s]+") # Find URLs
    # regex_input.insert("end", "[A|B][a-z]+")  # Find Words Starting with 'A' or 'B'
    regex_input.insert("end", "[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}")  # Find Domains

def create_test_string_input(parent):
    global test_string_input
    ttk.Label(parent, text="Test String:").grid(row=2, column=0, sticky=tk.W, pady=(5, 0))
    test_string_input = tk.Text(parent, height=5, wrap='word')
    test_string_input.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
    test_string_input.insert("end",     
    """Alice's email is alice@example.com, and Bob's email is bob@example.org. Contact us at support@company.com or visit our website: https://www.example.com."""
    )

def create_match_result(parent):
    global match_result
    ttk.Label(parent, text="Match Result:").grid(row=4, column=0, sticky=tk.W, pady=(10, 0))
    match_result = tk.Text(parent, height=10, wrap='word', state='disabled')
    match_result.grid(row=5, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
    match_result.grid_remove()  # Hide initially

def create_buttons(parent):
    ttk.Button(parent, text="Match", command=perform_match).grid(row=6, column=0, pady=5, sticky=tk.E)
    ttk.Button(parent, text="Clear", command=clear_fields).grid(row=6, column=1, pady=5, sticky=tk.W)

def perform_match(*args):
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights in both widgets
    test_string_input.tag_remove("highlight", "1.0", tk.END)
    match_result.tag_remove("highlight", "1.0", tk.END)

    try:
        # Step 1: Find sentences containing matches
        matches = list(re.finditer(regex, test_string))
        sentences = re.split(r'(?<=[.!?])\s+', test_string)  # Split into sentences

        result_sentences = []  # To store unique sentences with matches
        for match in matches:
            for sentence in sentences:
                if match.group() in sentence and sentence not in result_sentences:
                    result_sentences.append(sentence)
                    break

        # Step 2: Display sentences in match_result
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)

        if result_sentences:
            # Show label and widget, then display results
            match_result_label.grid()
            match_result.grid()
            for sentence in result_sentences:
                match_result.insert(tk.END, sentence + "\n")

            # Highlight matches in match_result
            match_result_text = match_result.get("1.0", tk.END)
            for match in re.finditer(regex, match_result_text):
                start_idx = f"1.0 + {match.start()} chars"
                end_idx = f"1.0 + {match.end()} chars"
                match_result.tag_add("highlight", start_idx, end_idx)

            match_result.tag_config("highlight", background="yellow", foreground="black")
        else:
            # Hide label and widget if no matches are found
            match_result_label.grid_remove()
            match_result.grid_remove()

        match_result.config(state="disabled")

    except re.error as e:
        # Handle regex errors
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)
        match_result.insert(tk.END, f"Invalid regular expression: {str(e)}")
        match_result_label.grid()
        match_result.grid()
        match_result.config(state="disabled")


"""
def perform_match(*args):
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights in both widgets
    test_string_input.tag_remove("highlight", "1.0", tk.END)
    match_result.tag_remove("highlight", "1.0", tk.END)

    try:
        # Step 1: Find sentences containing matches
        matches = list(re.finditer(regex, test_string))
        sentences = re.split(r'(?<=[.!?])\s+', test_string)  # Split into sentences

        result_sentences = []  # To store unique sentences with matches
        for match in matches:
            for sentence in sentences:
                if match.group() in sentence and sentence not in result_sentences:
                    result_sentences.append(sentence)
                    break

        # Step 2: Display sentences in match_result
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)

        if result_sentences:
            # Show match_result widget and display results
            match_result.grid()
            for sentence in result_sentences:
                match_result.insert(tk.END, sentence + "\n")

            # Highlight matches in match_result
            match_result_text = match_result.get("1.0", tk.END)
            for match in re.finditer(regex, match_result_text):
                start_idx = f"1.0 + {match.start()} chars"
                end_idx = f"1.0 + {match.end()} chars"
                match_result.tag_add("highlight", start_idx, end_idx)

            match_result.tag_config("highlight", background="yellow", foreground="black")
        else:
            # Hide match_result if no matches are found
            match_result.grid_remove()

        match_result.config(state="disabled")

    except re.error as e:
        # Handle regex errors
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)
        match_result.insert(tk.END, f"Invalid regular expression: {str(e)}")
        match_result.grid()
        match_result.config(state="disabled")
"""

"""
def perform_match(*args):
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights in both widgets
    test_string_input.tag_remove("highlight", "1.0", tk.END)
    match_result.tag_remove("highlight", "1.0", tk.END)

    try:
        # Step 1: Find sentences containing matches
        matches = list(re.finditer(regex, test_string))
        sentences = re.split(r'(?<=[.!?])\s+', test_string)  # Split into sentences
        
        result_sentences = []  # To store unique sentences with matches
        for match in matches:
            for sentence in sentences:
                if match.group() in sentence and sentence not in result_sentences:
                    result_sentences.append(sentence)
                    break

        # Step 2: Display sentences in match_result
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)

        for sentence in result_sentences:
            match_result.insert(tk.END, sentence + "\n")

        if not result_sentences:
            match_result.insert(tk.END, "No matches found.")

        # Step 3: Highlight matches in match_result
        match_result_text = match_result.get("1.0", tk.END)
        for match in re.finditer(regex, match_result_text):
            start_idx = f"1.0 + {match.start()} chars"
            end_idx = f"1.0 + {match.end()} chars"
            match_result.tag_add("highlight", start_idx, end_idx)

        # Apply highlighting style to match_result
        match_result.tag_config("highlight", background="yellow", foreground="black")
        match_result.config(state="disabled")

    except re.error as e:
        # Handle regex errors
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)
        match_result.insert(tk.END, f"Invalid regular expression: {str(e)}")
        match_result.config(state="disabled")
"""

"""
def perform_match(*args):
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights in both widgets
    test_string_input.tag_remove("highlight", "1.0", tk.END)
    match_result.tag_remove("highlight", "1.0", tk.END)

    try:
        # Find matches in the test string
        matches = list(re.finditer(regex, test_string))
        sentences = re.split(r'(?<=[.!?])\s+', test_string)  # Split into sentences
        
        result_sentences = {}  # Dictionary to store unique sentences and their matches
        for match in matches:
            for sentence in sentences:
                if match.group() in sentence:
                    if sentence not in result_sentences:
                        result_sentences[sentence] = []
                    result_sentences[sentence].append(match.group())
                    break

        # Display sentences and highlight matches in match_result
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)

        for sentence, matches_in_sentence in result_sentences.items():
            # Insert the sentence into the match_result widget
            start_index = match_result.index(tk.END)
            match_result.insert(tk.END, sentence + "\n")

            # Highlight all matches in the sentence
            for match_text in matches_in_sentence:
                start_idx = sentence.find(match_text)
                while start_idx != -1:
                    # Calculate indices relative to the match_result widget
                    match_start = f"{start_index} + {start_idx}c"
                    match_end = f"{start_index} + {start_idx + len(match_text)}c"
                    match_result.tag_add("highlight", match_start, match_end)

                    # Find the next occurrence within the same sentence
                    start_idx = sentence.find(match_text, start_idx + 1)

        if not result_sentences:
            match_result.insert(tk.END, "No matches found.")

        # Apply highlighting style to match_result
        match_result.tag_config("highlight", background="yellow", foreground="black")
        match_result.config(state="disabled")

        # Highlight matches in the test_string_input widget
        for match in matches:
            start_idx = f"1.0 + {match.start()} chars"
            end_idx = f"1.0 + {match.end()} chars"
            test_string_input.tag_add("highlight", start_idx, end_idx)

        test_string_input.tag_config("highlight", background="yellow", foreground="black")

    except re.error as e:
        update_match_result(f"Invalid regular expression: {str(e)}")
"""

"""
# Displays sentence containing search term in Match Result Window
def perform_match(*args):
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights
    test_string_input.tag_remove("highlight", "1.0", tk.END)

    try:
        # Find matches
        matches = list(re.finditer(regex, test_string))
        sentences = re.split(r'(?<=[.!?])\s+', test_string)  # Split into sentences
        
        # Ensure each result is only displayed once
        result_sentences = set()  # To store unique sentences

        for match in matches:
            # Underline the match
            start_idx = f"1.0 + {match.start()} chars"
            end_idx = f"1.0 + {match.end()} chars"
            test_string_input.tag_add("highlight", start_idx, end_idx)

            # Find the sentence containing the match
            for sentence in sentences:
                if match.group() in sentence:
                    result_sentences.add(sentence.strip())
                    break

        # Prepare the result text (Use double new line to space out results)
        result = "\n\n".join(result_sentences) if result_sentences else "No matches found."

        # Apply underlining style to highlights
        test_string_input.tag_config("highlight", background="yellow", foreground="black")
        
        # Update the match result box with sentences containing matches
        update_match_result(result)

    except re.error as e:
        update_match_result(f"Invalid regular expression: {str(e)}")
"""

"""
def perform_match(*args):
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights
    test_string_input.tag_remove("highlight", "1.0", tk.END)

    try:
        # Find matches
        matches = list(re.finditer(regex, test_string))
        sentences = re.split(r'(?<=[.!?])\s+', test_string)  # Split into sentences
        
        result = ""
        for match in matches:
            # Highlight the match
            start_idx = f"1.0 + {match.start()} chars"
            end_idx = f"1.0 + {match.end()} chars"
            test_string_input.tag_add("highlight", start_idx, end_idx)

            # Find the sentence containing the match
            for sentence in sentences:
                if match.group() in sentence:
                    result += f"{sentence.strip()}\n"
                    break

        if not result:
            result = "No matches found."

        # Apply highlighting style
        test_string_input.tag_config("highlight", background="yellow", foreground="black")
        
        # Update the match result box with sentences containing matches
        update_match_result(result)
    except re.error as e:
        update_match_result(f"Invalid regular expression: {str(e)}")
"""
"""
# Displays matching search term and their indexes in Match Result Window
def perform_match(*args):
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights
    test_string_input.tag_remove("highlight", "1.0", tk.END)

    try:
        matches = re.finditer(regex, test_string)
        result = ""
        for match in matches:
            # Highlight the match
            start_idx = f"1.0 + {match.start()} chars"
            end_idx = f"1.0 + {match.end()} chars"
            test_string_input.tag_add("highlight", start_idx, end_idx)

            # Add match details to result
            result += f"Match found: {match.group()}\n"
            result += f"Start index: {match.start()}, End index: {match.end()}\n\n"

        if not result:
            result = "No matches found."

        # Apply highlighting style
        test_string_input.tag_config("highlight", background="yellow", foreground="black")
        
        # Update the match result box
        update_match_result(result)
    except re.error as e:
        update_match_result(f"Invalid regular expression: {str(e)}")
"""

def update_match_result(text):
    match_result.config(state='normal')
    match_result.delete("1.0", tk.END)
    match_result.insert(tk.END, text)
    match_result.config(state='disabled')

def clear_fields():
    regex_input.delete("1.0", tk.END)
    test_string_input.delete("1.0", tk.END)
    update_match_result("")

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Tkinter RegEx Editor")
    root.geometry("800x600")

    create_widgets(root)
    root.mainloop()

