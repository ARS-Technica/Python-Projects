"""
The goal of this project is to better familarize myself
with both Python's Tkinter and Regular Expression libraries.

Once finished, this project will allow users to text regular
expressions on a test bed of sample text while simultaneously
offering a cheatsheet of common regex expressions and 
storage for a rolodex of their the most useful regex snippets.
"""

# Calculating absolute positions from the start of the widget and ensure highlights align correctly.


# Next issue: Between the regex_input and the test_string_input, I want to add a group of buttons to help users generate regular expressions.

import tkinter as tk
from tkinter import ttk
import re

import tkinter.filedialog as filedialog # To export search results as an .rtf


def create_widgets(root):
    # Configure root to make the application responsive
    root.columnconfigure(0, weight=1)
    root.rowconfigure(0, weight=1)

    # Create main frame
    main_frame = ttk.Frame(root, padding="5")  # Reduce padding
    main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

    # Configure main frame to allow expansion
    main_frame.columnconfigure(0, weight=1)
    main_frame.columnconfigure(1, weight=1)
    main_frame.rowconfigure(1, weight=1)  # Regex input
    main_frame.rowconfigure(3, weight=2)  # Test string input
    main_frame.rowconfigure(5, weight=3)  # Match result

    # Create and place widgets
    create_regex_input(main_frame)
    create_test_string_input(main_frame)
    create_match_result(main_frame)
    create_buttons(main_frame)

def create_regex_input(parent):
    global regex_input
    ttk.Label(parent, text="Regular Expression:").grid(row=0, column=0, sticky=tk.W)
    regex_input = tk.Text(parent, height=3, wrap='word')
    regex_input.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
    # regex_input.insert("end", "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}") # Find Email Addresses
    # regex_input.insert("end", "https?://[^\s]+") # Find URLs
    # regex_input.insert("end", "[A|B][a-z]+")  # Find Words Starting with 'A' or 'B'
    regex_input.insert("end", "[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}")  # Find Domains

def create_test_string_input(parent):
    global test_string_input
    ttk.Label(parent, text="Test String:").grid(row=2, column=0, sticky=tk.W, pady=(5, 0))
    test_string_input = tk.Text(parent, height=5, wrap='word')
    test_string_input.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
    test_string_input.insert("end",     
    """Alice's email is alice@example.com, and Bob's email is bob@example.org. Contact us at support@company.com or visit our website: https://www.example.com."""
    )

def create_match_result(parent):
    global match_result, match_result_label
    match_result_label = ttk.Label(parent, text="Match Results:")
    match_result_label.grid(row=4, column=0, sticky=tk.W, pady=(10, 0))
    match_result_label.grid_remove()  # Hide the label initially

    match_result = tk.Text(parent, height=10, wrap='word', state='disabled')
    match_result.grid(row=5, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
    match_result.grid_remove()  # Hide the widget initially


def create_buttons(parent):
    ttk.Button(parent, text="Match", command=perform_match).grid(row=6, column=0, pady=10) # pady=5, sticky=tk.E)
    ttk.Button(parent, text="Clear Fields", command=clear_fields).grid(row=6, column=1, pady=10) #  pady=5, sticky=tk.W)
    ttk.Button(parent, text="Export", command=export_results).grid(row=7, column=0, columnspan=2, pady=10)


def adjust_window_size():
    root.update_idletasks()  # Ensure all layout changes are applied
    width = root.winfo_reqwidth()
    height = root.winfo_reqheight()
    root.geometry(f"{width}x{height}")
    print(f"Window size: {root.winfo_width()}x{root.winfo_height()}")


def export_results():
    # Ensure match_result is not empty
    match_result_text = match_result.get("1.0", tk.END).strip()
    if not match_result_text:
        print("No results to export.")
        return

    # Prompt user to save the file
    file_path = filedialog.asksaveasfilename(
        defaultextension=".rtf",
        filetypes=[("Rich Text Format", "*.rtf"), ("All Files", "*.*")]
    )
    if not file_path:
        return  # User cancelled the save dialog

    try:
        # Begin writing the RTF content
        with open(file_path, "w") as file:
            # RTF header with color table for highlighting
            file.write("{\\rtf1\\ansi\\deff0\n")
            file.write("{\\colortbl;\\red255\\green255\\blue0;}\n")  # Define yellow color

            # Add header text with a blank line
            #file.write("Search results from file test.doc:\\line \\line \n")
            file.write("\\b Search results from file test.doc:\\b0\\line \\line \n")

            # Retrieve text and highlighted regions
            full_text = match_result.get("1.0", tk.END)  # Get the full text
            highlight_ranges = match_result.tag_ranges("highlight")  # Get highlight ranges

            # Initialize absolute position tracker
            current_pos = 0

            for i in range(0, len(highlight_ranges), 2):
                # Get start and end indices of the highlight in absolute positions
                start = match_result.index(highlight_ranges[i])
                end = match_result.index(highlight_ranges[i + 1])

                start_line, start_char = map(int, start.split("."))
                end_line, end_char = map(int, end.split("."))

                # Calculate absolute indices in the text
                start_idx = sum(len(match_result.get(f"{line}.0", f"{line}.end")) + 1 for line in range(1, start_line)) + start_char
                end_idx = sum(len(match_result.get(f"{line}.0", f"{line}.end")) + 1 for line in range(1, end_line)) + end_char

                # Write normal text before the highlight
                if current_pos < start_idx:
                    normal_text = full_text[current_pos:start_idx]
                    file.write(normal_text.replace("\n", "\\line ") + "\n")

                # Write highlighted text
                highlighted_text = full_text[start_idx:end_idx]
                file.write("{\\highlight1 " + highlighted_text.replace("\n", "\\line ") + "}\n")

                # Update the current position
                current_pos = end_idx

            # Write any remaining text after the last highlight
            if current_pos < len(full_text):
                remaining_text = full_text[current_pos:]
                file.write(remaining_text.replace("\n", "\\line ") + "\n")

            # End the RTF content
            file.write("}")
        print(f"Results exported to {file_path}")
    except Exception as e:
        print(f"Error exporting results: {e}")



def perform_match(*args):
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights in both widgets
    test_string_input.tag_remove("highlight", "1.0", tk.END)
    match_result.tag_remove("highlight", "1.0", tk.END)

    try:
        # Step 1: Find sentences containing matches
        matches = list(re.finditer(regex, test_string))
        sentences = re.split(r'(?<=[.!?])\s+', test_string)  # Split into sentences

        result_sentences = []  # To store unique sentences with matches
        for match in matches:
            for sentence in sentences:
                if match.group() in sentence and sentence not in result_sentences:
                    result_sentences.append(sentence)
                    break

        # Step 2: Display sentences in match_result
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)

        if result_sentences:
            # Show label and widget, resize window, and display results
            match_result_label.grid()
            match_result.grid()
            for sentence in result_sentences:
                match_result.insert(tk.END, sentence + "\n\n")  # Add a blank line after each sentence

            # Highlight matches in match_result
            match_result_text = match_result.get("1.0", tk.END)
            for match in re.finditer(regex, match_result_text):
                start_idx = f"1.0 + {match.start()} chars"
                end_idx = f"1.0 + {match.end()} chars"
                match_result.tag_add("highlight", start_idx, end_idx)

            match_result.tag_config("highlight", background="yellow", foreground="black")
        else:
            # Hide label and widget if no matches are found
            match_result_label.grid_remove()
            match_result.grid_remove()

        # Dynamically adjust the window size
        adjust_window_size()

        match_result.config(state="disabled")

    except re.error as e:
        # Handle regex errors
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)
        match_result.insert(tk.END, f"Invalid regular expression: {str(e)}")
        match_result_label.grid()
        match_result.grid()

        # Dynamically adjust the window size
        adjust_window_size()

        match_result.config(state="disabled")



    except re.error as e:
        # Handle regex errors
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)
        match_result.insert(tk.END, f"Invalid regular expression: {str(e)}")
        match_result_label.grid()
        match_result.grid()

        # Dynamically adjust the window size
        adjust_window_size()

        match_result.config(state="disabled")
        #print(f"Window size: {root.winfo_width()}x{root.winfo_height()}")

def update_match_result(text):
    match_result.config(state='normal')
    match_result.delete("1.0", tk.END)
    match_result.insert(tk.END, text)
    match_result.config(state='disabled')

def clear_fields():
    # Clear the content of the input fields
    regex_input.delete("1.0", tk.END)
    test_string_input.delete("1.0", tk.END)
    #update_match_result("")

    # Clear and hide the match_result widget and its label
    match_result_label.grid_remove()
    match_result.grid_remove()

    # Resize the window to its original size
    adjust_window_size()


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Tkinter RegEx Editor")
    root.geometry("650x300")
    # Window size: 654x417
    
    create_widgets(root)
    root.mainloop()

    
