# Adding examples to each regular expression.
# Expanding regular expressions dictionary to include sample text and same results.

# Rearranging sample_text and sample_result asthetics 
# Moved sample_text and sample_result UNDER Treeview widgets
 

import tkinter as tk
from tkinter import ttk
import re

import tkinter.filedialog as filedialog # To export search results as an .rtf
from tkinter import simpledialog
from tkinter import messagebox


# Table of Contents:
    # User Interface
    # Matching Functions
    # Treeview Functions
    # Functions for Styling Widgets


# Example data for the Treeview

categories = {
	"All Tokens": {
        },
	"Common Tokens": {
    	"[abc]": {
    		"description": "Match a single character present in the set",
    		"sample_text": "a",
    		"sample_result": "b"},
    	"[^abc]": {
    		"description": "Match a single character NOT present in the set",
    		"sample_text": "c",
    		"sample_result": "d"},
    	"[a-z]": {
    		"description": "Match a single character in the range a-z",
    		"sample_text": "e",
    		"sample_result": "f"},
    	"[^a-z]": {
    		"description": "Match a single character NOT in the range a-z",
    		"sample_text": "",
    		"sample_result": ""},
    	"[a-zA-Z]": {
    		"description": "Match a single character in the range a-z or A-Z",
    		"sample_text": "",
    		"sample_result": ""},
    	".": {
    		"description": "Match any character except line terminators",
    		"sample_text": "",
    		"sample_result": ""},
    	"a|b": {
    		"description": "Match either a or b",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\s": {
    		"description": "Match any whitespace character",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\S": {
    		"description": "Match any non-whitespace character",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\d": {
    		"description": "Match any digit character",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\D": {
    		"description": "Match any non-digit character",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\w": {
    		"description": "Match any word character",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\W": {
    		"description": "Match any non-word character",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?:...)": {
    		"description": "Non-capturing group",
    		"sample_text": "",
    		"sample_result": ""},
    	"(...)": {
    		"description": "Capturing group",
    		"sample_text": "",
    		"sample_result": ""},
    	"a?": {
    		"description": "Match zero or one of a",
    		"sample_text": "",
    		"sample_result": ""},
    	"a*": {
    		"description": "Match zero or more of a",
    		"sample_text": "",
    		"sample_result": ""},
    	"a+": {
    		"description": "Match one or more of a",
    		"sample_text": "",
    		"sample_result": ""},
    	"a{3}": {
    		"description": "Match exactly 3 of a",
    		"sample_text": "",
    		"sample_result": ""},
    	"a{3,}": {
    		"description": "Match 3 or more of a",
    		"sample_text": "",
    		"sample_result": ""},
    	"a{3,6}": {
    		"description": "Match between 3 and 6 of a",
    		"sample_text": "",
    		"sample_result": ""},
    	"^": {
    		"description": "Start of string or line",
    		"sample_text": "",
    		"sample_result": ""},
    	"$": {
    		"description": "End of string or line",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\b": {
    		"description": "A word boundary",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\B": {
    		"description": "Non-word boundry",
    		"sample_text": "", "sample_result": ""}
        },
	"General Tokens": {
    	"\\0": {
    		"description": "Null character (unicode character U+2400)",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\n": {
    		"description": "Match newline character",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\r": {
    		"description": "Match carriage return character (unicode character U+2185)",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\t": {
    		"description": "Match tab character",
    		"sample_text": "", "sample_result": ""},
        },
	"Anchors": {
    	"\\G": {
    		"description": "Start of match",
    		"sample_text": "",
    		"sample_result": ""},
    	"^": {
    		"description": "Start of string or line",
    		"sample_text": "",
    		"sample_result": ""},
    	"$": {
    		"description": "End of string or line",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\A": {
    		"description": "Start of string",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\z": {
    		"description": "Absolute end of string",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\Z": {
    		"description": "End of string",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\b": {
    		"description": "Word boundary",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\B": {
    		"description": "Non-word boundary",
    		"sample_text": "", 
            "sample_result": ""},
        },
	"Meta Sequences": {
    	".": {
    		"description": "Matches any character except a newline",
    		"sample_text": "",
    		"sample_result": ""},
    	"a|b": {
    		"description": "Acts as an OR operator between expressions",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\s": {
    		"description": "Match any whitespace character [ \t\n\r\x0c]",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\S": {
    		"description": "Match any non-whitespace character [^ \t\n\r\x0c]",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\d": {
    		"description": "Match any digit character [0-9]",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\D": {
    		"description": "Match any non-digit character [^0-9]",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\w": {
    		"description": "Match any word character [a-zA-Z0-9_]",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\W": {
    		"description": "Match any non-word character [^a-zA-Z0-9_]",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\X": {
    		"description": "Any Unicode sequences, linebreaks included",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\C": {
    		"description": "Match one data unit",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\R": {
    		"description": "Unicode newlines",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\N": {
    		"description": "Match anything but a newline",
    		"sample_text": "",
    		"sample_result": ""},
    	"\x0b": {
    		"description": "Vertical whitespace character",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\V": {
    		"description": "Negation of \x0b",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\h": {
    		"description": "Horizontal whitespace character",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\H": {
    		"description": "Negation of \\h",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\K": {
    		"description": "Reset match",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\#": {
    		"description": "Match subpattern number",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\pX": {
    		"description": "Unicode property X",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\p{...}": {
    		"description": "Unicode property or script category",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\PX": {
    		"description": "Negation of \\PX",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\P{...}": {
    		"description": "Negation of \\P",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\Q...\\E": {
    		"description": "Quote; Treat as literals",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\k{name}": {
        	"description": "Match subpatter 'name'", 
            "sample_text": "", 
            "sample_result": ""},
    	"\\k<name>": {
        	"description": "Match subpattern 'name'", 
            "sample_text": "", 
            "sample_result": ""}, 
        "\\k'name'": {
            "description": "Match subpattern 'name'", 
            "sample_text": "", 
            "sample_result": ""},
    	"\\gn": {
    		"description": "Match nth subpattern",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\g{n}": {
    		"description": "Match nth subpattern",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\g{-n}": {
    		"description": "Match text in the relative previous subpattern matched",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\g<n>": {
    		"description": "Match expression defined in the nth capture group",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\g<+n>": {
    		"description": "Match expression defined in the nth capture group",
    		"sample_text": "",
    		"sample_result": ""}, 
        "\\g'n'": {
    		"description": "Match expression defined in the nth capture group",
    		"sample_text": "",
    		"sample_result": ""}, 
        "\\g'+n'": {
    		"description": "Match expression defined in the nth relative upcoming subpattern",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\g{letter}": {
    		"description": "Matches the same text capture group called `letter` matched and captured",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\g<letter>": {
        	"description": "Match expression defined in the capture group called 'letter'", 
            "sample_text": "", 
            "sample_result": ""}, 
        "\\g'letter'": {
            "description": "Match expression defined in the capture group called 'letter'", 
            "sample_text": "", 
            "sample_result": ""},
    	"\\xYY": {
    		"description": "Hex character YY",
    		"sample_text": "",
    		"sample_result": ""},
    	"x{YYYY}": {
    		"description": "Hex character YYYY",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\ddd": {
    		"description": "Octal character ddd",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\cY": {
    		"description": "Control character Y",
    		"sample_text": "",
    		"sample_result": ""},
    	"[\\b]": {
    		"description": "Backspace character",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\": {
    		"description": "Makes any character literal",
    		"sample_text": "", 
            "sample_result": ""}
        },
	"Quantifiers": {
    	"*": {
    		"description": "Matches 0 or more repetitions of the preceding element",
    		"sample_text": "",
    		"sample_result": ""},
    	"+": {
    		"description": "Matches 1 or more repetitions of the preceding element",
    		"sample_text": "",
    		"sample_result": ""},
    	"?": {
    		"description": "Matches 0 or 1 repetition of the preceding element",
    		"sample_text": "",
    		"sample_result": ""},
    	"{n}": {
    		"description": "Matches exactly n repetitions of the preceding element",
    		"sample_text": "",
    		"sample_result": ""},
    	"{n,}": {
    		"description": "Matches n or more repetitions of the preceding element",
    		"sample_text": "",
    		"sample_result": ""},
    	"{n,m}": {
    		"description": "Matches between n and m repetitions of the preceding element",
    		"sample_text": "",
    		"sample_result": ""},
    	"a*": {
    		"description": "Greedy qualifier (Matches as many characters as possible.)",
    		"sample_text": "",
    		"sample_result": ""},
    	"a*?": {
    		"description": "Lazy qualifier (Matches as few characters as possible.)",
    		"sample_text": "",
    		"sample_result": ""},
    	"a*+": {
        	"description": "Possessive qualifier (Matches as many characters as possible; backtracking can't reduce the number of characters matched.)", 
            "sample_text": "", 
            "sample_result": ""},
    	"*?": {
    		"description": "Lazy match 0 or more times",
    		"sample_text": "",
    		"sample_result": ""},
    	"+?": {
    		"description": "Lazy match 1 or more times",
    		"sample_text": "",
    		"sample_result": ""},
    	"??": {
    		"description": "Lazy match 0 or 1 time",
    		"sample_text": "", 
            "sample_result": ""}},
	"Group Constructs": {
    	"(?:...)": {
    		"description": "Match everything enclosed",
    		"sample_text": "",
    		"sample_result": ""},
    	"(...)": {
    		"description": "Capture everything enclosed",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?>...)": {
    		"description": "Atomic group (non-capturing)",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?|...)": {
    		"description": "Duplicate/reset subpattern group number",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?#...)": {
    		"description": "Comment group",
    		"sample_text": "",
    		"sample_result": ""}, 
        "(?'name'...)": {
    		"description": "Named capturing group",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?<name>...)": {
    		"description": "Named capturing group",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?P<name>...)": {
    		"description": "Named capturing group",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?imsxUJnxx)": {
    		"description": "Inline modifiers",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?imsxUJnxx:...)": {
    		"description": "Localized inline modifiers",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?(1)yes|no)": {
    		"description": "Conditional statement",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?(R)yes|no)": {
    		"description": "Conditional statement",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?(R#)yes|no)": {
    		"description": "Recursive conditional statement",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?(R&name)yes|no)": {
    		"description": "Conditional statement",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?(?=...)yes|no)": {
    		"description": "Lookahead conditional",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?(?<=...)yes|no)": {
    		"description": "Lookahead conditional",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?R)": {
    		"description": "Recursive match of entire pattern",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?n)": {
    		"description": "Atomic group by number",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?+1)": {
    		"description": "match expression defined in the first relative capture group",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?&name)": {
        	"description": "Match expression defined in capture group 'name'", 
            "sample_text": "", 
            "sample_result": ""},
    	"(?P=name)": {
        	"description": "Match text from earlier group 'name'",
            "sample_text": "", 
            "sample_result": ""},
    	"(?P>name)": {
        	"description": "Match expression defined in the capture group 'name'", 
            "sample_text": "", 
            "sample_result": ""},
    	"(?(DEFINE)...)": {
    		"description": "Pre-define patterns before using them",
    		"sample_text": "",
    		"sample_result": ""},
    	"?:": {
    		"description": "Non-capturing group",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?=...)": {
    		"description": "Positive lookahead assertion",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?!...)": {
    		"description": "Negative lookahead assertion",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?<=...)": {
    		"description": "Positive lookbehind assertion",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?<!...)": {
    		"description": "Negative lookbehind assertion",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*ACCEPT)": {
    		"description": "Control verb",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*FAIL)": {
    		"description": "Control verb",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*MARK:NAME)": {
    		"description": "Control verb",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*COMMIT)": {
    		"description": "Control verb",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*PRUNE)": {
    		"description": "Control verb",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*SKIP)": {
    		"description": "Control verb",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*THEN)": {
    		"description": "Control verb",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*UTF)": {
    		"description": "Pattern modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*UTF8)": {
    		"description": "Pattern modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*UTF16)": {
    		"description": "Pattern modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*UTF32)": {
    		"description": "Pattern modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*UCP)": {
    		"description": "Pattern modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*CR)": {
    		"description": "Line break modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*LF)": {
    		"description": "Line break modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*CRLF)": {
    		"description": "Line break modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*BSR_UNICODE)": {
    		"description": "Line break modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*BSR_ANYCRLF)": {
    		"description": "Line break modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*ANYCRLF)": {
    		"description": "Line break modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*ANY)": {
    		"description": "Line break modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*NOTEMPTY)": {
    		"description": "Empty match modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*NOTEMPTY_ATSTART)": {
    		"description": "Empty match modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*NO_JIT)": {
    		"description": "JIT Modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*LIMIT_RECURSION=d)": {
    		"description": "Regex engine modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*LIMIT_MATCH=x)": {
    		"description": "Regex engine modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*NO_AUTO_POSSESS)": {
    		"description": "Regex engine modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(*NO_START_OPT)": {
    		"description": "Regex engine modifier",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?i)": {
    		"description": "Case-insensitive",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?L)": {
    		"description": "Locale dependent",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?m)": {
    		"description": "Multiline",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?s)": {
    		"description": "Dot matches all",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?u)": {
    		"description": "Unicode",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?x)": {
    		"description": "Verbose",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?-...)": {
    		"description": "Toggle flags within pattern",
    		"sample_text": "", 
            "sample_result": ""},
        },
	"Character Classes": {
    	"[abc]": {
    		"description": "Matches either an a, b, or c character",
    		"sample_text": "",
    		"sample_result": ""},
    	"[^abc]": {
    		"description": "Matches any character except for an a, b, or c",
    		"sample_text": "",
    		"sample_result": ""},
    	"[a-z]": {
    		"description": "Matches any lowercase letter from a to z",
    		"sample_text": "",
    		"sample_result": ""},
    	"[A-Z]": {
    		"description": "Matches any uppercase letter from A to Z",
    		"sample_text": "",
    		"sample_result": ""},
    	"[^a-z]": {
    		"description": "Match a single character NOT in the range a-z",
    		"sample_text": "",
    		"sample_result": ""},
    	"[a-zA-Z]": {
    		"description": "Match a single character in the range a-z or A-Z",
    		"sample_text": "",
    		"sample_result": ""},
    	"[0-9]": {
    		"description": "Matches any digit from 0 to 9",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\d": {
    		"description": "Matches any digit (equivalent to [0-9])",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\D": {
    		"description": "Matches any non-digit character (equivalent to [^0-9])",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\w": {
    		"description": "Matches any word character (equivalent to [a-zA-Z0-9_])",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\W": {
    		"description": "Matches any non-word character (equivalent to [^a-zA-Z0-9_])",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\s": {
    		"description": "Matches any whitespace character (spaces, tabs, line breaks)",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\S": {
    		"description": "Matches any non-whitespace character",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:alnum:]]": {
    		"description": "Letters and digits",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:alpha]]": {
    		"description": "Letters",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:ascii:]]": {
    		"description": "ASCII codes 0-127",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:blank:]]": {
    		"description": "Space or tab only",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:cntrl:]]": {
    		"description": "Control characters",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:digit:]]": {
    		"description": "Decimal digits",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:graph:]]": {
    		"description": "Visible character (not space)",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:lower:]]": {
    		"description": "Lowercase letters",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:print:]]": {
    		"description": "Visible characters",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:punct:]]": {
    		"description": "Visible punctuation characters",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:space:]]": {
    		"description": "Whitespace",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:upper:]]": {
    		"description": "Uppercase letters",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:word:]]": {
    		"description": "Word characters",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:xdigit:]]": {
    		"description": "Hexadecimal digits",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:<:]]": {
    		"description": "Start of word",
    		"sample_text": "",
    		"sample_result": ""},
    	"[[:>:]]": {
    		"description": "End of word",
    		"sample_text": "", 
            "sample_result": ""},
        },
	"Flags/Modifiers": {
    	"s": {
    		"description": "Dot matches all - dot matches newline",
    		"sample_text": "",
    		"sample_result": ""},
    	"u": {
    		"description": "Unicode - pattern strings are unicode",
    		"sample_text": "",
    		"sample_result": ""},
    	"X": {
    		"description": "eXtra",
    		"sample_text": "",
    		"sample_result": ""},
    	"U": {
    		"description": "Ungreedy",
    		"sample_text": "",
    		"sample_result": ""},
    	"A": {
    		"description": "Anchor",
    		"sample_text": "",
    		"sample_result": ""},
    	"J": {
    		"description": "Duplicate group names",
    		"sample_text": "",
    		"sample_result": ""},
    	"n": {
    		"description": "Non-capturing groups",
    		"sample_text": "",
    		"sample_result": ""},
    	"xx": {
    		"description": "Ignore all whitespace / verbose",
    		"sample_text": "",
    		"sample_result": ""},
    	"g": {
    		"description": "Global - match all occurrences",
    		"sample_text": "",
    		"sample_result": ""},
    	"i": {
    		"description": "Case-insensitive matching",
    		"sample_text": "",
    		"sample_result": ""},
    	"m": {
    		"description": "Multiline - ^ and $ match start/end of line",
    		"sample_text": "",
    		"sample_result": ""},
    	"y": {
    		"description": "Sticky - match from lastIndex only",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?i)": {
    		"description": "Case-insensitive matching",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?m)": {
    		"description": "Multi-line matching",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?s)": {
    		"description": "Dot matches newline",
    		"sample_text": "",
    		"sample_result": ""},
    	"(?x)": {
    		"description": "Ignore whitespace and comments",
    		"sample_text": "", 
            "sample_result": ""},
        },
    "Substitution": {
    	"$0": {
    		"description": "Complete match contents",
    		"sample_text": "",
    		"sample_result": ""},
    	"$1": {
    		"description": "Contents in capture group 1",
    		"sample_text": "",
    		"sample_result": ""},
    	"$$": {
    		"description": "Insert a dollar sign",
    		"sample_text": "",
    		"sample_result": ""},
    	"${foo}": {
        	"description": "Contents in capture roup 'foo'", 
            "sample_text": "", 
            "sample_result": ""},
    	"$n": {
    		"description": "nth captured group",
    		"sample_text": "",
    		"sample_result": ""},
    	"$`": {
    		"description": "Before matched string",
    		"sample_text": "",
    		"sample_result": ""},
    	"$'": {
    		"description": "After matched string",
    		"sample_text": "",
    		"sample_result": ""},
    	"$&": {
    		"description": "Entire matched string",
    		"sample_text": "",
    		"sample_result": ""},
    	"$+": {
    		"description": "Last captured group",
    		"sample_text": "",
    		"sample_result": ""},
    	"$_": {
    		"description": "Entire input string",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\x20": {
    		"description": "Hexadecimal replacement values",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\x{06fa}": {
    		"description": "Hexadecimal replacement values",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\t": {
    		"description": "Insert a tab",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\r": {
    		"description": "Insert a carriage return",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\n": {
    		"description": "Insert a newline",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\f": {
    		"description": "Insert a form-feed",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\U": {
    		"description": "Uppercase Transformation",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\L": {
    		"description": "Lowercase Transformation",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\E": {
    		"description": "Terminate any Transformation",
    		"sample_text": "",
    		"sample_result": ""},
    	"${1:+foo:bar}": {
    		"description": "Conditional replacement",
    		"sample_text": "",
    		"sample_result": ""},
    	"\\[": {
    		"description": "Insert the escaped literal",
    		"sample_text": "", 
            "sample_result": ""},
        }
    }

saved_expressions = {
    "Common Regular Expressions": {
        "Credit Cards": {
    		"description": "^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6011[0-9]{12}|622((12[6-9]|1[3-9][0-9])|([2-8][0-9][0-9])|(9(([0-1][0-9])|(2[0-5]))))[0-9]{10}|64[4-9][0-9]{13}|65[0-9]{14}|3(?:0[0-5]|[68][0-9])[0-9]{11}|3[47][0-9]{13})*$",
            "sample_text": "",
    		"sample_result": ""},
        "Date (2003-08-06)": { 
            "description": "[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}",
            "sample_text": "",
    		"sample_result": ""},
        "Date (Jan 3, 2003)": { 
            "description": "[A-Z][a-z][a-z] [0-9][0-9]*, [0-9]\{4\}",
            "sample_text": "",
    		"sample_result": ""},
        "Date (DD/MM/YYYY or MM/DD/YY)": {
            "description": "^(\d{1,2})\/(\d{1,2})\/(\d{2}|(19|20)\d{2})$",
            "sample_text": "",
    		"sample_result": ""},
        "Dollar amounts with a $ symbol": { 
            "description": "\$[0-9]*.[0-9][0-9]",
            "sample_text": "",
    		"sample_result": ""},
        "E-mail address": {
            "description": "^[\\w\\-]+(\\.[\\w\\-]+)*@([A-Za-z0-9-]+\\.)+[A-Za-z]{2,4}$", 
            "sample_text": "",
    		"sample_result": ""},
        "IP Address": { 
            "description": "^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$", 
            "sample_text": "",
    		"sample_result": ""},
        "Percentage (2 decimal places)": {
            "description": "^-?[0-9]{0,2}(\.[0-9]{1,2})?$|^-?(100)(\.[0]{1,2})?$",
            "sample_text": "",
    		"sample_result": ""},
        "Phone Numbers": { 
            "description": "(^\+[0-9]{2}|^\+[0-9]{2}\(0\)|^\(\+[0-9]{2}\)\(0\)|^00[0-9]{2}|^0)([0-9]{9}$|[0-9\-\s]{10}$)",
            "sample_text": "",
    		"sample_result": ""},
        "Social Security": { 
            "description": "[0-9]\{3\}-[0-9]\{2\}-[0-9]\{4\}",
            "sample_text": "",
    		"sample_result": ""},
        "URL": {
            "description": "^http(s)?:\/\/((\d+\.\d+\.\d+\.\d+)|(([\w-]+\.)+([a-z,A-Z][\w-]*)))(:[1-9][0-9]*)?(\/([\w-.\/:%+@&=]+[\w- .\/?:%+@&=]*)?)?(#(.*))?$/i",
            "sample_text": "",
    		"sample_result": ""},
        "Zip Code": { 
            "description": "[0-9]\{5\}(-[0-9]\{4\})?",
            "sample_text": "",
    		"sample_result": ""},
    }
}
 
 
# Global variable to track toggle state
treeview_visible = False
current_data = categories  # Default to "categories"


# User Interface --------------------------------------------------------------

def create_window():
    """Creates the main window for the application with dynamic initial height."""
    global root, treeview_frame

    root = tk.Tk()
    root.title("PyRex Regular Expression Editor")
    root.geometry("900x1")  # Temporary small height to calculate actual needed height

    # Create menu, toolbar, and main widgets
    create_menu(root)
    create_toolbar(root)
    create_widgets(root)

    # Update the window to compute widget sizes
    root.update_idletasks()

    # Dynamically adjust the initial window size based on the widgets' required size
    initial_height = root.winfo_reqheight()  # Required height after widgets are placed
    root.geometry(f"900x{initial_height}")  # Set the correct initial height

    # Start the main event loop
    root.mainloop()


def create_menu(window):
    """Creates the main menu."""
    menu_bar = tk.Menu(window)

    # File menu
    file_menu = tk.Menu(menu_bar, tearoff=0)
    #file_menu.add_command(label="Export to File", command=export_results)
    file_menu.add_command(label="Save Expression", command=open_save_expression_popup)
    file_menu.add_separator()
    file_menu.add_command(label="Exit", command=window.destroy)

    # Search menu
    search_menu = tk.Menu(menu_bar, tearoff=0)

    # Toggle between Match Results being returned as Instances or Sentences
    global match_mode_var
    # Create variable for Match Results checkbutton
    # Global variable to track the match mode
    match_mode_var = tk.IntVar(value=0)  # 0 = "Instance", 1 = "Sentence"

    # Add mutually exclusive checkbuttons with toggle logic
    search_menu.add_checkbutton(
        label="Match Instances",
        variable=match_mode_var,
        onvalue=0,
        offvalue=1,
        command=lambda: toggle_search_mode(0)
    )
    search_menu.add_checkbutton(
        label="Match Sentences",
        variable=match_mode_var,
        onvalue=1,
        offvalue=0,
        command=lambda: toggle_search_mode(1)
    )

    # View menu
    view_menu = tk.Menu(menu_bar, tearoff=0)

    # Toggle between the Treeview Panel with one of two datasets
    view_menu.add_command(
        label="Regular Expression Cheatsheet",
        command=lambda: toggle_treeview_with_data(categories)
    )
    view_menu.add_command(
        label="Saved Expressions",
        command=lambda: toggle_treeview_with_data(saved_expressions)
    )   

    # Add menus to the menu bar
    menu_bar.add_cascade(label="File", menu=file_menu)
    menu_bar.add_cascade(label="Search", menu=search_menu)
    menu_bar.add_cascade(label="View", menu=view_menu)

    window.config(menu=menu_bar)


def create_widgets(window):
    """Creates the main UI components by delegating to helper functions."""
    global main_frame, treeview_frame

    # Configures the grid layout of the main window.
    #configure_window_grid(window)
    window.columnconfigure(0, weight=1)  	# Single column
    window.rowconfigure(1, weight=1)    	# Main frame (static widgets)
    window.rowconfigure(2, weight=0)    	# Treeview frame (toggling widget)

    # Create Toolbar
    create_toolbar(window)

    # Main Frame (Fixed Widgets)
    main_frame = create_main_frame(window)

    # Add Widgets to Main Frame
    create_regex_input(main_frame)    
    create_test_string_field(main_frame)
    create_match_results_field(main_frame)
    create_buttons(main_frame)

    # Create Collapsible Treeview Panel
    treeview_frame = create_treeview_panel(window)


def create_toolbar(window):
    """Creates a toolbar at the top of the window (for Treeview toggle buttons)"""
    toolbar = ttk.Frame(window, padding="5")
    toolbar.grid(row=0, column=0, sticky="ew")

    # Button to toggle RegEx CheatSheet
    ttk.Button(
        toolbar,
        text="RegEx CheatSheet",
        command=lambda: toggle_treeview_with_data(categories)
    ).pack(side="left", padx=5)

    # Button to toggle Saved Expressions
    ttk.Button(
        toolbar,
        text="Saved Expressions",
        command=lambda: toggle_treeview_with_data(saved_expressions)
    ).pack(side="left", padx=5)


def create_main_frame(window):
    """Creates the main frame and configures its layout."""
    main_frame = ttk.Frame(window, padding="5")  # Add padding to the main frame
    main_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=10, pady=0)  # Add padding to the grid

    # Configure main_frame grid
    main_frame.columnconfigure(0, weight=1)
    main_frame.columnconfigure(1, weight=1)
    main_frame.rowconfigure(0, weight=0)  # Regular Expression label (fixed)
    main_frame.rowconfigure(1, weight=0)  # Regular Expression input (fixed)
    main_frame.rowconfigure(2, weight=0)  # Test String/Match Results labels (fixed)
    main_frame.rowconfigure(3, weight=0)  # Test String/Match Results widgets (expandable)
    main_frame.rowconfigure(4, weight=0)  # Buttons row (fixed)

    return main_frame


def create_regex_input(parent):
    """Adds a regular expression input field to the given parent frame."""
    global regex_input

    ttk.Label(parent, text="Regular Expression:").grid(row=0, column=0, columnspan=2, sticky=tk.W, pady=(5, 2))
    regex_input = tk.Text(parent, height=3, wrap="word")
    regex_input.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(2, 5))
    
    # regex_input.insert("end", "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}") # Find Email Addresses
    # regex_input.insert("end", "https?://[^\s]+") # Find URLs
    # regex_input.insert("end", "[A|B][a-z]+")  # Find Words Starting with 'A' or 'B'
    regex_input.insert("end", "[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}")  # Find Domains


def create_test_string_field(parent):
    """Adds test string text field to the left column of the given parent frame."""
    global test_string_input

    # Test String
    ttk.Label(parent, text="Test String:").grid(row=2, column=0, sticky=tk.W, pady=(5, 2))
    test_string_input = tk.Text(parent, height=10, wrap="word")
    test_string_input.grid(row=3, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 5))

    test_string_input.insert("end",     
    """Alice's email is alice@example.com, and Bob's email is bob@example.org. Contact us at support@company.com or visit our website: https://www.example.com."""
    )


def create_match_results_field(parent):
    """Adds match results text field to the right column of the given parent frame."""
    global match_result

    # Match Results
    ttk.Label(parent, text="Match Results:").grid(row=2, column=1, sticky=tk.W, pady=(5, 2))
    match_result = tk.Text(parent, height=10, wrap="word", state="disabled")
    match_result.grid(row=3, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(5, 0))


def create_buttons(parent):
    """Adds buttons to the given parent frame."""
    button_frame = ttk.Frame(parent)
    button_frame.grid(row=4, column=0, columnspan=2, sticky=tk.EW)
    button_frame.columnconfigure(0, weight=1)
    button_frame.columnconfigure(1, weight=1)

    ttk.Button(button_frame, text="Clear Fields", command=clear_fields).grid(row=0, column=0, pady=5, sticky=tk.W)
    ttk.Button(button_frame, text="Match", command=perform_match).grid(row=0, column=1, pady=5, sticky=tk.E)



def create_treeview_panel(window):
    """Creates the collapsible Treeview Panel with sample text and result fields below the Treeview widgets."""
    global treeview_frame, sample_text_widget, sample_results_widget, sample_text_label, sample_results_label

    treeview_frame = ttk.Frame(window, padding="5")
    treeview_frame.grid(row=2, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=10, pady=0)
    treeview_frame.columnconfigure(0, weight=1)
    treeview_frame.columnconfigure(1, weight=1)

    # Create Treeview Widgets
    create_treeview_section(treeview_frame, 0)

    # Sample Text Row (Placed Below Treeview)
    sample_text_label = ttk.Label(treeview_frame, text="Sample Text:")
    sample_text_label.grid(row=1, column=0, sticky=tk.W, padx=(0, 5), pady=(5, 2))
    sample_text_widget = tk.Entry(treeview_frame)  # Single-line text widget
    sample_text_widget.grid(row=1, column=1, sticky=(tk.W, tk.E), padx=(0, 10), pady=(5, 2))

    # Sample Results Row (Placed Below Treeview)
    sample_results_label = ttk.Label(treeview_frame, text="Sample Results:")
    sample_results_label.grid(row=2, column=0, sticky=tk.W, padx=(0, 5), pady=(2, 5))
    sample_results_widget = tk.Entry(treeview_frame)  # Single-line text widget
    sample_results_widget.grid(row=2, column=1, sticky=(tk.W, tk.E), padx=(0, 10), pady=(2, 5))

    # Adjust row weights
    treeview_frame.rowconfigure(0, weight=1)  # Treeview row expandable
    treeview_frame.rowconfigure(1, weight=0)  # Fixed height for Sample Text
    treeview_frame.rowconfigure(2, weight=0)  # Fixed height for Sample Results

    treeview_frame.grid_remove()  # Start hidden
    return treeview_frame



'''
# Leaves scrollbar running through sample_results and sample_text
def create_treeview_panel(window):
    """Creates the collapsible Treeview Panel with sample text and result fields."""
    global treeview_frame, sample_text_widget, sample_results_widget, sample_text_label, sample_results_label

    treeview_frame = ttk.Frame(window, padding="5")
    treeview_frame.grid(row=2, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=10, pady=0)
    treeview_frame.columnconfigure(0, weight=1)
    treeview_frame.columnconfigure(1, weight=1)

    # Add "Sample Text" and "Sample Results" fields above the Treeview widgets
    # Sample Text Row
    sample_text_label = ttk.Label(treeview_frame, text="Sample Text:")
    sample_text_label.grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    sample_text_widget = tk.Entry(treeview_frame)  # Single-line text widget
    sample_text_widget.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(0, 10))  # Proper spacing to avoid scrollbar

    # Sample Results Row
    sample_results_label = ttk.Label(treeview_frame, text="Sample Results:")
    sample_results_label.grid(row=1, column=0, sticky=tk.W, padx=(0, 5))
    sample_results_widget = tk.Entry(treeview_frame)  # Single-line text widget
    sample_results_widget.grid(row=1, column=1, sticky=(tk.W, tk.E), padx=(0, 10))  # Proper spacing to avoid scrollbar

    # Create Treeview Widgets
    create_treeview_section(treeview_frame, 2)

    # Add a spacer row using a Frame with a fixed height (optional)
    spacer = ttk.Frame(treeview_frame, height=10)
    spacer.grid(row=3, column=0, columnspan=2, sticky="nsew")

    treeview_frame.rowconfigure(2, weight=1)  # Make the Treeview row expandable
    treeview_frame.rowconfigure(3, weight=0)  # Make the spacer row fixed height

    treeview_frame.grid_remove()  # Start hidden
    return treeview_frame
'''

'''
def create_treeview_panel(window):
    """Creates the collapsible Treeview Panel with sample text and result fields."""
    global treeview_frame, sample_text_widget, sample_results_widget, sample_text_label, sample_results_label

    treeview_frame = ttk.Frame(window, padding="5")
    treeview_frame.grid(row=2, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=10, pady=0)
    treeview_frame.columnconfigure(0, weight=1)
    treeview_frame.columnconfigure(1, weight=1)

    # Add "Sample Text" and "Sample Results" fields above the Treeview widgets
    # Sample Text Row
    sample_text_label = ttk.Label(treeview_frame, text="Sample Text:")
    sample_text_label.grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    sample_text_widget = tk.Entry(treeview_frame, width=100)  # One-line text widget
    sample_text_widget.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(0, 5))

    # Sample Results Row
    sample_results_label = ttk.Label(treeview_frame, text="Sample Results:")
    sample_results_label.grid(row=1, column=0, sticky=tk.W, padx=(0, 5))
    sample_results_widget = tk.Entry(treeview_frame, width=100)  # One-line text widget
    sample_results_widget.grid(row=1, column=1, sticky=(tk.W, tk.E), padx=(0, 5))

    # Create Treeview Widgets
    create_treeview_section(treeview_frame, 2)

    # Add a spacer row using a Frame with a fixed height (optional)
    spacer = ttk.Frame(treeview_frame, height=10)
    spacer.grid(row=3, column=0, columnspan=2, sticky="nsew")

    treeview_frame.rowconfigure(2, weight=1)  # Make the Treeview row expandable
    treeview_frame.rowconfigure(3, weight=0)  # Make the spacer row fixed height

    treeview_frame.grid_remove()  # Start hidden
    return treeview_frame
'''

'''
def create_treeview_panel(window):
    global treeview_frame
    treeview_frame = ttk.Frame(window, padding="5")  # Add padding to the main frame
    treeview_frame.grid(row=2, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=10, pady=0)  # Add padding to the grid
    treeview_frame.columnconfigure(0, weight=1)
    treeview_frame.columnconfigure(1, weight=1)

    # Create Treeview and add it to the first row
    create_treeview_section(treeview_frame, 0)

    # Add a spacer row using a Frame with a fixed height
    spacer = ttk.Frame(treeview_frame, height=10)
    spacer.grid(row=1, column=0, columnspan=2, sticky="nsew")

    treeview_frame.rowconfigure(0, weight=1)  # Make the Treeview row expandable
    treeview_frame.rowconfigure(1, weight=0)  # Make the spacer row fixed height

    treeview_frame.grid_remove()  # Start hidden
    return treeview_frame
'''

# /User Interface -------------------------------------------------------------


# Save RegEx Pop-Up Interface ------------------------------------------------


def open_save_expression_popup():
    """
    Opens a popup window for saving a regular expression.
    """
    popup = tk.Toplevel(root)
    popup.title("Save Regular Expression")
    popup.geometry("500x275")
    popup.resizable(False, False)  # Prevent resizing
    popup.transient(root)  # Set the popup as a child of the main window

    # Frames for layout
    category_frame = ttk.Frame(popup, padding="10")
    category_frame.grid(row=0, column=0, sticky="nsew")
    regex_frame = ttk.Frame(popup, padding="10")
    regex_frame.grid(row=1, column=0, sticky="nsew")
    description_frame = ttk.Frame(popup, padding="10")
    description_frame.grid(row=2, column=0, sticky="nsew")
    button_frame = ttk.Frame(popup, padding="10")
    button_frame.grid(row=3, column=0, sticky="ew")

    # Configure column weights for proper layout
    popup.columnconfigure(0, weight=1)
    category_frame.columnconfigure(1, weight=1)
    regex_frame.columnconfigure(0, weight=1)
    description_frame.columnconfigure(0, weight=1)
    button_frame.columnconfigure(0, weight=1)
    button_frame.columnconfigure(1, weight=1)

    # Category Section
    ttk.Label(category_frame, text="Category:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    category_combobox = ttk.Combobox(category_frame, values=list(saved_expressions.keys()), state="readonly", width=30)
    category_combobox.grid(row=0, column=1, sticky=tk.W, padx=(5, 0))
    add_category_button = ttk.Button(category_frame, text="Add Category", command=lambda: add_new_category(category_combobox))
    add_category_button.grid(row=0, column=2, padx=(5, 0))

    # Regular Expression Display
    ttk.Label(regex_frame, text="Regular Expression:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    regex_display = tk.Text(regex_frame, height=3, wrap="word", width=60, state="disabled")
    regex_display.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), padx=(0, 0))

    # Populate the Regular Expression field
    regex_content = regex_input.get("1.0", tk.END).strip()
    if regex_content:  # Ensure regex_input has content
        regex_display.configure(state="normal")  # Temporarily make it editable
        regex_display.insert("1.0", regex_content)  # Insert the regex
        regex_display.configure(state="disabled")  # Disable editing again

    # Description Field
    ttk.Label(description_frame, text="Description:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    description_field = tk.Text(description_frame, height=3, wrap="word", width=60)
    description_field.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), padx=(0, 0))

    # Save and Cancel Buttons
    save_button = ttk.Button(
        button_frame,
        text="Save",
        command=lambda: save_expression(category_combobox, regex_display, description_field, popup)
    )
    save_button.grid(row=0, column=0, sticky=tk.E, padx=5)

    cancel_button = ttk.Button(button_frame, text="Cancel", command=popup.destroy)
    cancel_button.grid(row=0, column=1, sticky=tk.W, padx=5)


def add_new_category(category_combobox):
    """
    Prompts the user to add a new category to the saved_expressions dictionary.
    """
    
    new_category = simpledialog.askstring("New Category", "Enter the name of the new category:")
    
    if new_category and new_category.strip():
        new_category = new_category.strip()
        if new_category not in saved_expressions:
            saved_expressions[new_category] = {}  # Add new category to the dictionary
            category_combobox["values"] = list(saved_expressions.keys())  # Refresh combobox
            category_combobox.set(new_category)  # Auto-select the new category
        else:
            messagebox.showinfo("Info", f"The category '{new_category}' already exists.")
		   

def save_expression(category_combobox, regex_display, description_field, popup):
    """
    Saves the current regular expression and description to the selected category
    in the `saved_expressions` nested dictionary.
    """
    # Get the selected category
    category = category_combobox.get().strip()
    if not category:
        messagebox.showerror("Error", "Category cannot be empty.")
        return

    # Get the regex from regex_display
    regex = regex_display.get("1.0", tk.END).strip()
    if not regex:
        messagebox.showerror("Error", "Regular Expression cannot be empty.")
        return

    # Get the description
    description = description_field.get("1.0", tk.END).strip()
    if not description:
        messagebox.showerror("Error", "Description cannot be empty.")
        return

    # Add the expression to the saved_expressions dictionary
    is_new_category = False
    if category not in saved_expressions:
        saved_expressions[category] = {}
        is_new_category = True

    saved_expressions[category][regex] = description

    # Notify the user
    messagebox.showinfo("Success", f"Expression saved to category '{category}'.")

    # Highlight the saved expression and category if Treeview Panel is open
    if treeview_visible and toggle_treeview_with_data._last_data_id == id(saved_expressions):
        if is_new_category:
            # Refresh the entire Treeview for new category
            populate_treeview(saved_expressions)
        else:
            # Update only the right-side Treeview for the current category
            if category in saved_expressions:
                display_key_value_pairs(saved_expressions[category], key_value_tree)

        # Highlight the category in category_tree
        for child in category_tree.get_children():
            item_text = category_tree.item(child, "text")
            if item_text == category:  # Match the saved category
                category_tree.selection_set(child)  # Highlight the saved category
                category_tree.see(child)  # Scroll to the saved category
                break

        # Highlight the newly saved expression in key_value_tree
        for child in key_value_tree.get_children():
            item = key_value_tree.item(child)
            if item["values"] and item["values"][0] == regex:  # Match the saved regex
                key_value_tree.selection_set(child)  # Highlight the saved expression
                key_value_tree.see(child)  # Scroll to the saved expression
                break

    # Close the popup
    popup.destroy()

# /Save RegEx Pop-Up Interface ------------------------------------------------


# Matching Functions ----------------------------------------------------------

def perform_match(*args):
    """Determines match mode dynamically and performs the appropriate matching."""
    global match_results_as_instances

    # Prevent Regex execution on empty input
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    if not regex:
        messagebox.showwarning("Input Error", "Regular Expression field cannot be empty.")
        return

    if not test_string:
        messagebox.showwarning("Input Error", "Test String field cannot be empty.")
        return

    # Check the current match mode directly from match_mode_var
    # match_mode (0 = Instances, 1 = Sentences)
    if match_mode_var.get() == 0:
        match_instances(*args)  # Perform instance-level matching
    else:
        match_sentences(*args)  # Perform sentence-level matching


def match_instances(*args):
    """Displays instances of matching search term in Match Result Window"""
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights
    test_string_input.tag_remove("highlight", "1.0", tk.END)

    try:
        # Step 1: Find sentences containing matches
        matches = re.finditer(regex, test_string)
        result = ""

        for match in matches:
            # Step 2: Highlight matches in Test String widget
            start_idx = f"1.0 + {match.start()} chars"
            end_idx = f"1.0 + {match.end()} chars"
            # Highlight the match
            test_string_input.tag_add("highlight", start_idx, end_idx)

            # Add match details to result
            result += f"{match.group()}\n\n"  # Add a blank line after each result

        if not result:
            result = "No matches found."

        # Apply highlighting style
        test_string_input.tag_config("highlight", background="yellow", foreground="black")

        # Update the Match Results widget
        update_match_result(result)

    except re.error as e:
        # Handle regex errors
        update_match_result(f"Invalid regular expression: {str(e)}")

        
def match_sentences(*args):
    """Displays sentences containing instances of matching search term in Match Result Window"""
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights in both widgets
    test_string_input.tag_remove("highlight", "1.0", tk.END)
    match_result.tag_remove("highlight", "1.0", tk.END)

    try:
        # Step 1: Find sentences containing matches
        matches = list(re.finditer(regex, test_string))
        sentences = re.split(r'(?<=[.!?])\s+', test_string)  # Split into sentences

        result_sentences = []  # To store unique sentences with matches
        for match in matches:
            for sentence in sentences:
                if match.group() in sentence and sentence not in result_sentences:
                    result_sentences.append(sentence)
                    break

        # Step 2: Display sentences in match_result
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)

        if result_sentences:
            # Display results
            for sentence in result_sentences:
                match_result.insert(tk.END, sentence + "\n\n")  # Add a blank line after each sentence

            # Highlight matches in match_result
            match_result_text = match_result.get("1.0", tk.END)
            for match in re.finditer(regex, match_result_text):
                start_idx = f"1.0 + {match.start()} chars"
                end_idx = f"1.0 + {match.end()} chars"
                match_result.tag_add("highlight", start_idx, end_idx)

            match_result.tag_config("highlight", background="yellow", foreground="black")
        else:
            result = "No matches found."

        match_result.config(state="disabled")

    except re.error as e:
        # Handle regex errors
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)
        match_result.insert(tk.END, f"Invalid regular expression: {str(e)}")

        match_result.config(state="disabled")


def clear_fields():
    #regex_input.delete("1.0", tk.END)
    test_string_input.delete("1.0", tk.END)
    match_result.config(state="normal")
    match_result.delete("1.0", tk.END)
    match_result.config(state="disabled")


def export_results():
    # TODO: Add f-string with name of current open document to header
    # Add a dialog to get header text
    header = simpledialog.askstring(
        "Export Header", "Enter header for exported file:", initialvalue="Search Results:\n")
    if not header:
        header = "Search Results:\n"
    
    header = "\\b " + header + "\\b0"
        

    # Ensure match_result is not empty
    match_result_text = match_result.get("1.0", tk.END).strip()
    if not match_result_text:
        print("No results to export.")
        return

    # Prompt user to save the file
    file_path = filedialog.asksaveasfilename(
        defaultextension=".rtf",
        filetypes=[("Rich Text Format", "*.rtf"), ("All Files", "*.*")]
    )
    if not file_path:
        return  # User cancelled the save dialog

    try:
        # Begin writing the RTF content
        with open(file_path, "w") as file:
            # RTF header with color table for highlighting
            file.write("{\\rtf1\\ansi\\deff0\n")
            file.write("{\\colortbl;\\red255\\green255\\blue0;}\n")  # Define yellow color

            # Add header text with a blank line
            #file.write("Search results from file test.doc:\\line \\line \n")
            #file.write("\\b Search results from file test.doc:\\b0\\line \\line \n")
            file.write(header + "\\line \\line \n")

            # Retrieve text and highlighted regions
            full_text = match_result.get("1.0", tk.END)  # Get the full text
            highlight_ranges = match_result.tag_ranges("highlight")  # Get highlight ranges

            # Initialize absolute position tracker
            current_pos = 0

            for i in range(0, len(highlight_ranges), 2):
                # Get start and end indices of the highlight in absolute positions
                start = match_result.index(highlight_ranges[i])
                end = match_result.index(highlight_ranges[i + 1])

                start_line, start_char = map(int, start.split("."))
                end_line, end_char = map(int, end.split("."))

                # Calculate absolute indices in the text
                start_idx = sum(len(match_result.get(f"{line}.0", f"{line}.end")) + 1 for line in range(1, start_line)) + start_char
                end_idx = sum(len(match_result.get(f"{line}.0", f"{line}.end")) + 1 for line in range(1, end_line)) + end_char

                # Write normal text before the highlight
                if current_pos < start_idx:
                    normal_text = full_text[current_pos:start_idx]
                    file.write(normal_text.replace("\n", "\\line ") + "\n")

                # Write highlighted text
                highlighted_text = full_text[start_idx:end_idx]
                file.write("{\\highlight1 " + highlighted_text.replace("\n", "\\line ") + "}\n")

                # Update the current position
                current_pos = end_idx

            # Write any remaining text after the last highlight
            if current_pos < len(full_text):
                remaining_text = full_text[current_pos:]
                file.write(remaining_text.replace("\n", "\\line ") + "\n")

            # End the RTF content
            file.write("}")
            
        # Notify user of successful export
        print(f"Results exported to {file_path}")
        messagebox.showinfo("Export Successful", f"Results saved to {file_path}")

    except Exception as e:
        print(f"Error exporting results: {e}")
        messagebox.showerror("Export Error", f"Failed to save file: {str(e)}")


def toggle_search_mode(new_mode):
    """Toggles between match modes and re-runs the search if results are present."""
    # Update the match_mode_var to reflect the new mode
    match_mode_var.set(new_mode)

    def is_match_result_empty():
        """Checks if the match_result text widget is empty."""
        content = match_result.get("1.0", tk.END).strip()  # Get all text and remove surrounding whitespace
        return len(content) == 0  # True if empty, False otherwise

    # Check if match_result has content
    if not is_match_result_empty():
        # Re-run the search in the new mode
        perform_match()
    else:
        print(f"Search mode set to: {'Instances' if new_mode == 0 else 'Sentences'}")


def update_match_result(text):
    match_result.config(state='normal')
    match_result.delete("1.0", tk.END)
    match_result.insert(tk.END, text)
    match_result.config(state='disabled')

# /Matching Functions ---------------------------------------------------------


# Treeview Functions ---------------------------------------------------------

def create_treeview_section(parent, row):
    """
    Creates the Treeview section with two widgets: category_tree and key_value_tree.
    """

    global category_tree, key_value_tree

    # Removed code for creating "Tree" that causes Treeview to span two columns

    # Adjust column weights to control widths of the Treeview widgets
    parent.columnconfigure(0, weight=1)  # Left column: Narrower
    parent.columnconfigure(1, weight=4)  # Right column: Wider
    # These two lines of code can be set to weights of 2/2, 1/3, 1/4 or deleted altogether

    # Category Treeview (Left)
    category_tree = create_category_treeview(parent, row)
    category_tree.grid(row=row, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 5))

    # Key-Value Treeview (Right)
    key_value_tree = create_key_value_treeview(parent)
    key_value_tree.grid(row=row, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(5, 0))

    # No need to bind <<TreeviewSelect>> here; populate_treeview handles this dynamically

    # Add some space beneath the Treeview widgets
    parent.grid_rowconfigure(1, weight=1, pad=10)  # Add 10px padding
    
    return parent # If not creating a new "tree" Treeview, return parent


def create_category_treeview(parent, row):
    """Creates the Category Treeview with styles."""
    configure_treeview_style()

    tree = ttk.Treeview(parent, show="tree", selectmode="browse", style="Custom.Treeview") 
    # style="Custom.Treeview" ensures that the Treeview's alternate row styling is visible

    scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
    scrollbar.grid(row=0, column=1, sticky="ns")
    tree.configure(yscrollcommand=scrollbar.set)

    # Populate with the top-level keys of categories
    for category in categories.keys():
        tree.insert("", "end", text=category)

    return tree


def create_key_value_treeview(parent):
    """Creates the Key-Value Treeview with styles and alternating row colors."""
    tree = ttk.Treeview(parent, columns=("Key", "Value"), show="headings", style="Custom.Treeview")
    # !Remember: Excluding style="Custom.Treeview" from line above removes alternating row style!    
    
    tree.heading("Key", text="Key")
    tree.heading("Value", text="Value")
    tree.column("Key", width=50, anchor="w")
    tree.column("Value", width=300, anchor="w")

    scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
    scrollbar.grid(row=0, column=2, sticky="ns")
    tree.configure(yscrollcommand=scrollbar.set)

    apply_row_styles(tree)
    configure_hover_effect(tree)

    # Bind double-click to append the key to the regex_input
    tree.bind("<Double-Button-1>", lambda event: on_key_double_click(event, tree))

    return tree


def display_key_value_pairs(category_data, key_value_tree):
    """
    Populates the key_value_tree with the key-value pairs of the selected category.
    Applies alternating row styling after populating.
    """
    # Clear existing data
    key_value_tree.delete(*key_value_tree.get_children())

    # Populate the Treeview with key-value pairs
    for key, value_dict in category_data.items():
        if isinstance(value_dict, dict) and "description" in value_dict:
            description = value_dict["description"]
        else:
            description = "No description available"
        key_value_tree.insert("", "end", values=(key, description))

    # Apply alternating row styles
    apply_row_styles(key_value_tree)
    
     
def on_key_double_click(event, tree):
    """Handles double-clicks on the Key-Value Treeview by appending the key to the regex_input field."""
    # Get the selected item
    selected_item = tree.focus()
    if not selected_item:
        return  # No item selected

    # Retrieve the key from the selected row
    selected_values = tree.item(selected_item, "values")
    if selected_values:
        key = selected_values[0]  # The key is in the first column

        # Append the key to the regex_input
        current_text = regex_input.get("1.0", tk.END).strip()  # Get current content
        new_text = current_text + key  # Append the key
        regex_input.delete("1.0", tk.END)  # Clear the current content
        regex_input.insert("1.0", new_text)  # Insert the updated content








def populate_treeview(data):
    """
    Populates the category_tree with the given data.
    Clears the key_value_tree to start fresh.
    """
    # Clear the left and right Treeview widgets
    category_tree.delete(*category_tree.get_children())
    key_value_tree.delete(*key_value_tree.get_children())

    # Populate the left Treeview
    for key in data.keys():
        category_tree.insert("", "end", text=key)

    # Set up selection binding for the left Treeview
    def on_select(event):
        selected_item = category_tree.focus()
        if selected_item:
            category = category_tree.item(selected_item, "text")
            display_key_value_pairs(data.get(category, {}), key_value_tree)

    category_tree.bind("<<TreeviewSelect>>", on_select)

    # Bind selection for the right-side Treeview
    def on_key_select(event):
        selected_item = key_value_tree.focus()
        if selected_item:
            item_data = key_value_tree.item(selected_item, "values")
            if item_data:
                regex = item_data[0]
                for key, inner_data in data.items():
                    if regex in inner_data:
                        sample_text_widget.delete(0, tk.END)
                        sample_text_widget.insert(0, inner_data[regex].get("sample_text", ""))
                        sample_results_widget.delete(0, tk.END)
                        sample_results_widget.insert(0, inner_data[regex].get("sample_result", ""))
                        break

    key_value_tree.bind("<<TreeviewSelect>>", on_key_select)



'''
def populate_treeview(data):
    """
    Populates the category_tree with the given data.
    Clears the key_value_tree to start fresh.
    """
    # Clear the left and right Treeview widgets
    category_tree.delete(*category_tree.get_children())
    key_value_tree.delete(*key_value_tree.get_children())

    # Populate the left Treeview
    for key in data.keys():
        category_tree.insert("", "end", text=key)

    # Bind the selection to update the right Treeview
    def on_select(event):
        selected_item = category_tree.focus()
        if selected_item:
            category = category_tree.item(selected_item, "text")
            display_key_value_pairs(data.get(category, {}), key_value_tree)

    category_tree.bind("<<TreeviewSelect>>", on_select)
'''

'''
def populate_treeview(data):
    """
    Populates the category_tree with the given data.
    Clears the key_value_tree to start fresh.
    """
    # Clear the left and right Treeview widgets
    category_tree.delete(*category_tree.get_children())
    key_value_tree.delete(*key_value_tree.get_children())

    # Populate the left Treeview
    for key in data.keys():
        category_tree.insert("", "end", text=key)

    # Bind the selection to the reusable on_category_selected function
    category_tree.bind("<<TreeviewSelect>>", lambda event: on_category_selected(event, data))


def on_category_selected(event, data):
    """
    Handles selection in the left-side Treeview and displays key-value pairs in the right-side Treeview.
    """
    selected_item = category_tree.focus()
    if selected_item:
        category = category_tree.item(selected_item, "text")
        if category in data:
            display_key_value_pairs(data[category], key_value_tree)
'''

'''
def populate_treeview(data):
    """
    Populates the category_tree with the given data.
    Clears the key_value_tree to start fresh.
    """
    # Clear the left and right Treeview widgets
    category_tree.delete(*category_tree.get_children())
    key_value_tree.delete(*key_value_tree.get_children())

    # Populate the left Treeview
    for key in data.keys():
        category_tree.insert("", "end", text=key)

    # Set up selection binding for the left Treeview
    # Replaces category_tree.bind lambda in the on_category_select function
    def on_select(event):
        selected_item = category_tree.focus()
        if selected_item:
            category = category_tree.item(selected_item, "text")
            display_key_value_pairs(data.get(category, {}), key_value_tree)

    category_tree.bind("<<TreeviewSelect>>", on_select)
'''



def toggle_treeview_with_data(data):
    """
    Toggles the Treeview Panel on/off or repopulates it if the data changes.
    Efficiently checks if the requested data is the same as the current dataset.
    """
    if not hasattr(toggle_treeview_with_data, "_last_data_id"):
        toggle_treeview_with_data._last_data_id = None

    global treeview_visible, treeview_frame

    # Compare the id of the current dataset with the requested dataset
    if treeview_visible and toggle_treeview_with_data._last_data_id == id(data):
        # If the panel is already displaying the requested data, toggle it off
        treeview_frame.grid_remove()
        treeview_visible = False
    else:
        # Show the Treeview Panel and populate with new data
        treeview_frame.grid(row=2, column=0, sticky="nsew")
        populate_treeview(data)
        toggle_treeview_with_data._last_data_id = id(data)
        treeview_visible = True

    # Adjust window size dynamically
    root.update_idletasks()
    new_height = root.winfo_reqheight()
    root.geometry(f"{root.winfo_width()}x{new_height}")


'''
def toggle_treeview_with_data(data):
    """
    Toggles the Treeview Panel on/off or repopulates it if the data changes.
    Efficiently checks if the requested data is the same as the current dataset.
    """
    # Use an attribute to store the last dataset id
    if not hasattr(toggle_treeview_with_data, "_last_data_id"):
        toggle_treeview_with_data._last_data_id = None

    global treeview_visible, treeview_frame

    # Compare the id of the current dataset with the requested dataset
    if treeview_visible and toggle_treeview_with_data._last_data_id == id(data):
        # If the panel is already displaying the requested data, toggle it off
        treeview_frame.grid_remove()
        treeview_visible = False
    else:
        # Show the Treeview Panel and populate with new data
        treeview_frame.grid(row=2, column=0, sticky="nsew")
        populate_treeview(data)
        toggle_treeview_with_data._last_data_id = id(data)
        treeview_visible = True

    # Adjust window size dynamically
    root.update_idletasks()
    new_height = root.winfo_reqheight() # + (100 if treeview_visible else 0) # Too much space!
    root.geometry(f"{root.winfo_width()}x{new_height}")
'''

# /Treeview Functions ---------------------------------------------------------


# Treeview Styling Functions -----------------------------------------------

def apply_row_styles(tree):
    """Applies alternating row styles to the Treeview."""
    for i, child in enumerate(tree.get_children()):
        if i % 2 == 0:
            tree.tag_configure("evenrow", background="white")
            tree.item(child, tags=("evenrow",))
        else:
            tree.tag_configure("oddrow", background="#f2f2f2")
            tree.item(child, tags=("oddrow",))


def configure_hover_effect(tree):
    """Configures the hover effect for the Treeview rows."""
    def on_mouse_over(event):
        item_id = tree.identify_row(event.y)
        for child in tree.get_children():
            tree.tag_configure("hover", background="#d9d9d9")
            apply_row_styles(tree)
        if item_id:
            tree.item(item_id, tags=("hover",))

    def on_mouse_leave(event):
        apply_row_styles(tree)

    tree.bind("<Motion>", on_mouse_over)
    tree.bind("<Leave>", on_mouse_leave)


def configure_treeview_style():
    """Configures the Treeview widget style."""
    style = ttk.Style()
    style.configure("Custom.Treeview", rowheight=25)
    style.map(
        "Custom.Treeview",
        background=[("selected", "#cce5ff")],
        foreground=[("selected", "black")],
    )


def on_double_click(event):
    """Handles the double-click event on a Treeview row."""
    item_id = event.widget.focus()
    item = event.widget.item(item_id)
    item_text = item["text"]  # Get the text from the first column ("Item")
    if item_text:
        regex_input.delete(0, tk.END)  # Clear the current text
        regex_input.insert(0, item_text)  # Insert the "Item" text

# /Treeview Styling Functions -----------------------------------------------


if __name__ == "__main__":
    # Run the application
    create_window()

  


#%%

 
# TODO: Cheetsheet in extenable panel below interface 
# TODO: Create export options
# TODO: Place Regex String beneath text windows    
# TODO: Make search Apply to larger text widget for integration into Text Editor


# Syntax Highlighting for Regex Input

# Add line numbers to match results

# Save and Load Regular Expressions 

# Menu Options: Add "Save Regex" and "Load Regex" options in the File menu.

# Search History 

# Resizable Widgets
    # Allow the regex_input, test_string_input, and match_result widgets to resize dynamically with the window.
    
# Regex Validation
    # Provide real-time feedback if the entered regex is invalid, instead of waiting for the "Match" button.
    # Use re.compile() to check the validity of the regex whenever it is edited.
    
# Refactor into Classes
    # RegexEditor: Main application class.
    # RegexTester: Handles regex matching logic.
    # TreeviewManager: Manages the Treeview widgets.

# Improve Modularity and Code Structure 
    # Separate GUI and Logic Layers: regex matching, data handling, etc
        # gui.py: All GUI-related functions.
        # core.py: Regex logic, data handling, and utility functions.
        # main.py: Initializes and connects GUI with the core logic.
        # Group Similar Functions into Classes or Namespaces:

# Use classes to encapsulate related functionality. For instance:
    # TreeviewManager class to handle all Treeview-related functions (creation, population, styling, events).
    # RegexProcessor class for regex matching and handling user input/output.

# Add Search/Filter for Treeviews:
    # Add a search bar above the left Treeview (category_tree) so users can quickly find a category by name.
    # Add a filter option for the right Treeview (key_value_tree) to limit the visible key-value pairs based on user input.

# Real-Time Regex Matching: regex in real-time as the user types in the regex_input field

# Regex History: Maintain a history of previously entered regex patterns.

# Regex Validation: Add a visual indicator (like a red border or icon) to show whether the entered regex is valid or has syntax errors.

# Regex Syntax Highlighting: Add syntax highlighting for the regex_input field to improve readability

# File Input and Output Load Test String from File
    # Allow users to load a test string from a text file instead of typing it manually.
 
# Allow users to save frequently used regex patterns to a file and reload them later.

# Add keyboard shortcuts for common actions like toggling the Treeview Panel (Ctrl+T), matching (Ctrl+M), and clearing fields (Ctrl+L).

# Resizable Widgets: Allow users to resize the text fields (test_string_input, regex_input, and match_result) dynamically by dragging their edges.

# Help Section: Add a "Help" menu or button to provide guidance on how to use the application, write regex, and interpret results.

# Include links to external regex resources (e.g., cheat sheets or tutorials).

# Group Highlighting: Highlight matched groups (e.g., group 1, group 2, etc.) with different colors in the match_result field.

# Dark Mode

# Custom Styles: Allow users to customize fonts, colors, and sizes of the widgets via a settings menu.

# Improve Large Dataset Handling: If you anticipate loading large dictionaries into the Treeview, consider lazy-loading (populating Treeview items only when a category is expanded).

# Database Integration: Store categories and saved_expressions in a database (like SQLite) for more efficient management and querying.

# Use libraries like pyregex or regex for additional regex features, such as fuzzy matching or Unicode property support.

# Export Results Enhancements: Allow exporting match results to formats like JSON, CSV, or plain text (in addition to .rtf).

 
