# -*- coding: utf-8 -*-
# Goal: Make the "Invalid regex" errors more useful with both a message and a position index where the regex failed. 
# Expanded Try/Except portion of explain_regex function to show context of error position.
# Completed format_regex_error function to format regex errors with context and highlighting.
# Created safe_parse_regex function to safely parse regex and return friendly error messages.
# Insert error message into regex_info_field   regex_info_field.insert("1.0", str(safe_parse_regex(regex_info)))
# Expanded format_regex_error to offer hints.
# update_regex_info now calls safe_parse_regex to show errors in regex_info_field
# Restored real-time regex explanations in regex_info_field as user types in regex_input

# Issue: regex_info_field now does not display an explanation of text


import tkinter as tk
from tkinter import ttk

from tkinter import Label, Text, Frame

import tkinter.colorchooser as colorchooser   # def create_syntax_colors_popup
import tkinter.filedialog as filedialog       # To export search results as an .rtf
from tkinter import simpledialog
from tkinter import messagebox

# import threading # For running regex matching in a separate thread
from pathlib import Path # For .json paths
import json # For loading regular_expressions.json and saved_expressions.json
# import winsound # For Save/Delete Regex Confirmations

# Libraries for Regular Expression Parser (Explanations):
import re
import rstr     # For generating regex examples in generate_sample_from_regex
import sre_parse    # For parsing regex patterns in explain_regex Function
from sre_parse import SubPattern    # For parsing regex patterns in explain_regex Function


# Table of Contents:
    # Global Variables
    # Load External Data
    # User Interface
    # Syntax Highlighting Colors Pop-Up Interface
    # History Manager
    # Save RegEx Pop-Up Interface 
    # Matching Functions
    # Treeview Functions
    # Treeview Styling Functions 
    # Regular Expression Generator
    # Regular Expression Parser (Explanations)


# Global Variables ------------------------------------------------------------  


# Updating the color box in the UI when a color is changed via the color picker.
color_displays = {}  # Global or module-level dict to link tags to swatch widgets

# Default Global variables for syntax highlights in the create_regex_input function
# Used for resetting all current values back to a known baseline.
DEFAULT_SYNTAX_HIGHLIGHTING_COLORS = {
    "Anchors": "orange",                    # For ^, $, \b
    "Backreferences": "slateblue",          # For \1, \g<name>
    "Character Classes": "green",           # For character sets []
	"Comments": "black",                    # For comments starting with #
    
    "Escaped Characters": "deeppink",       # For \d, \w, \t  
    "Escaped (Non-Special)": "pink",        # For \a, \b, \f, \n, \r, \t, \v, \\ (non-special escaped characters)
    "Escaped (Unicode)": "pink",            # For \uFFFF or \UFFFFFFFF
    "Escaped (Octal)": "pink",              # For \077      
    "Escaped (Hex)": "pink",                # For \xFF

    "Group": "blue",                        # For capturing & non-capturing groups
    "Group (Atomic)": "light blue",         # For atomic groups (?>...) 
    "Group (Named)": "light blue",          # For named groups (?P<name>...)
    "Group (Non-capturing)": "light blue",  # For non-capturing groups (?:...)

	"Inline Flags": "darkgreen",            # For (?i), (?L), etc
    "Lookaheads": "teal",                   # For (?=...), (?<=...)
	
    "Quantifiers": "darkviolet",            # For *, +, ?, {m,n}
    "Quantifiers (Lazy)": "purple",         # For *?, +?, ??, {m,n}?
	"Quantifiers (Possessive)": "purple",   # For *+, ++, ?+, {m,n}+

    "Special": "brown",                     # For ., |, etc.
}

# Storage for current syntax highlight colors in regex_input.
syntax_highlighting_colors = {
    "Anchors": "orange",                # For ^, $, \b
    "Backreferences": "slateblue",      # For \1, \g<name>
    "Character Classes": "green",       # For character sets []
	"Comments": "black",                # For comments starting with #
    
    "Escaped Characters": "deeppink",   # For \d, \w, \t  
    "Escaped (Non-Special)": "pink",    # For \a, \b, \f, \n, \r, \t, \v, \\ (non-special escaped characters)
    "Escaped (Unicode)": "pink",        # For \uFFFF or \UFFFFFFFF
    "Escaped (Octal)": "pink",          # For \077      
    "Escaped (Hex)": "pink",            # For \xFF

    "Group": "blue",                    # For capturing & non-capturing groups
    "Group (Atomic)": "blue",           # For atomic groups (?>...) 
    "Group (Named)": "blue",            # For named groups (?P<name>...)
    "Group (Non-capturing)": "blue",    # For non-capturing groups (?:...)

	"Inline Flags": "darkgreen",        # For (?i), (?L), etc
    "Lookaheads": "teal",               # For (?=...), (?<=...)
	
    "Quantifiers": "darkviolet",        # For *, +, ?, {m,n}
    "Quantifiers (Lazy)": "purple",     # For *?, +?, ??, {m,n}?
	"Quantifiers (Possessive)": "purple", # For *+, ++, ?+, {m,n}+

    "Special": "brown",                 # For ., |, etc.
}


#/Global Variables ------------------------------------------------------------    


# Load External Data-----------------------------------------------------------


# Constants for file paths 
DATA_DIR = Path(__file__).parent
REGEX_FILE_PATH = DATA_DIR / "regular_expressions.json"
SAVED_FILE_PATH = DATA_DIR / "saved_expressions.json"

# REGEX_FILE_PATH = "C:/Python/Python38-32/Programs/Tkinter/Regular Expression Editor/regular_expressions.json"
# SAVED_FILE_PATH = "C:/Python/Python38-32/Programs/Tkinter/Regular Expression Editor/saved_expressions.json"

# Default data in case JSON files are missing or invalid
DEFAULT_REGULAR_EXPRESSIONS = {
    # Add minimal default data here to keep the program functional
}

DEFAULT_SAVED_EXPRESSIONS = {
    # Add minimal default data here to keep the program functional
}


# Load Regular Expressions
def load_regular_expressions():
    """Loads a JSON file and returns its content, or default if not found or invalid."""
    try:
        # Explicitly specify the correct encoding when opening the json file
        with open(REGEX_FILE_PATH, 'r', encoding='utf-8') as file:
            return json.load(file)
    except FileNotFoundError:
        print(f"File not found AT {REGEX_FILE_PATH}. Loading default regular expressions.")
        print("Error: 'regular_expressions.json' not found. Loading default data.")
        return DEFAULT_REGULAR_EXPRESSIONS
    except json.JSONDecodeError:
        print(f"Invalid JSON format in file: {REGEX_FILE_PATH}. Loading default regular expressions.")
        return DEFAULT_REGULAR_EXPRESSIONS


# Load Saved Expressions
def load_saved_expressions():
    try:
        # Explicitly specify the correct encoding when opening the json file
        with open(SAVED_FILE_PATH, 'r', encoding='utf-8') as file:
            return json.load(file)
    except FileNotFoundError:
        print(f"File not found AT {SAVED_FILE_PATH}. Loading default regular expressions.")
        print("Error: 'saved_expressions.json' not found. Loading default data.")
        return DEFAULT_SAVED_EXPRESSIONS
    except json.JSONDecodeError:
        print(f"Invalid JSON format in file: {SAVED_FILE_PATH}. Loading default regular expressions.")
        return DEFAULT_SAVED_EXPRESSIONS


# Load the data
regular_expressions = load_regular_expressions()
saved_expressions = load_saved_expressions()


# Global variable to track toggle state
treeview_visible = False
current_data = regular_expressions  # Default to "Regular Expressions" for Treeview widget


#/Load External Data-----------------------------------------------------------


# User Interface --------------------------------------------------------------

"""
Structure
Organized to ensure that, if regex_info_field.grid_remove() is called, 
the rows below shift up automatically.

window (root)
    row 0 → Toolbar
    row 1 → main_frame (everything above treeview)
    row 2 → treeview_frame (collapsible)

main_frame
    row 0 → Regex input section label
    row 1 → Regex text widget
    row 2 → Regex info frame (contains regex_info_field when visible)
    row 3 → Buttons below regex input (clear_regex_button, save_regex_button)
    row 4 → Test String, Match Results labels (test_string_label, match_results_label)
    row 5 → Test String and Match Results text widgets (test_string_input, match_result)
    row 6 → Clear Fields and Match buttons (create_buttons())
"""

def create_window():
    """Creates the main window for the application with dynamic initial height."""
    
    global root, treeview_frame

    root = tk.Tk()
    root.title("PyRex Regular Expression Editor")
    
    # Let Tkinter determine an initial size automatically
    root.geometry("")  
    root.geometry("900x1")  # Temporary small height to calculate actual needed height
    root.resizable(True, True) # Let the window be resizable

    # Create menu, toolbar, and main widgets
    create_menu(root)
    create_toolbar(root)
    create_widgets(root)

    # Update the window to compute widget sizes
    root.update_idletasks() # Update the window to compute widget sizes
    
    # Set the initial height based on the required height of the main frame
    initial_height = root.winfo_reqheight()  # Required height after widgets are placed
    root.geometry(f"900x{initial_height}")  # Set the correct initial height

    # Record the initial state
    history['record'](get_current_state())

    # Start the main event loop
    root.mainloop()


def create_menu(window):
    """Creates the main menu."""
    
    menu_bar = tk.Menu(window)

    # File menu
    file_menu = tk.Menu(menu_bar, tearoff=0)
    file_menu.add_command(label="Export with Highlighting", command=lambda: export_results(True))
    file_menu.add_command(label="Export without Highlighting", command=lambda: export_results(False))
    file_menu.add_separator()
    file_menu.add_command(label="Save Expression", command=create_save_expression_popup)
    file_menu.add_command(label="Move Expression", command=move_expression_popup)
    file_menu.add_command(label="Delete Expression", command=delete_expression)
    file_menu.add_separator()
    file_menu.add_command(label="Exit", command=window.destroy)

    # Edit menu
    edit_menu = tk.Menu(menu_bar, tearoff=0)
    edit_menu.add_command(label="Undo", command=undo_action, accelerator="Ctrl+Z")
    edit_menu.add_command(label="Redo", command=redo_action, accelerator="Ctrl+Y")

    # Options menu
    options_menu = tk.Menu(menu_bar, tearoff=0)

   # Allows user to cause the reg_ex text to change color when regex is invalid
    global active_validation
    # Create a BooleanVar to track checkbox state for regex_input validation
    active_validation = tk.BooleanVar(value=True) # True = Active

    # Display explanations of regular expressions below the regex input field
    global active_regex_explanations 
    # Create a BooleanVar to track checkbox state for regex explanations
    active_regex_explanations = tk.BooleanVar(value=True) # True = Active

    options_menu.add_command(
        label="Customize Syntax Colors",
        command=create_syntax_colors_popup
    )
    options_menu.add_separator()  # Add a separator line
    # Add checkbutton with toggle logic (Called in create_regex_input  Function)
    options_menu.add_checkbutton(
        label="Display Explainations of Regular Expressions",
        variable=active_regex_explanations,
        onvalue=True,
        offvalue=False,
        command=update_regex_info_visibility  # Toggle regex_info visibility on and off
    )
    options_menu.add_separator()  # Add a separator line
    # Add checkbutton with toggle logic (Called in create_regex_input  Function)
    options_menu.add_checkbutton(
        label="Validate RegEx as you Type",
        variable=active_validation,
        onvalue=True,
        offvalue=False,
        command=validate_and_update_display  # Toggle the background to white if False
    )

    # Toggle between Match Results being returned as Instances or Sentences
    global match_mode_var
    # Create variable for Match Results checkbutton
    # Global variable to track the match mode
    match_mode_var = tk.IntVar(value=0)  # 0 = "Instance", 1 = "Sentence"

    options_menu.add_separator()  # Add a separator line
    # Add mutually exclusive checkbuttons with toggle logic
    options_menu.add_radiobutton(
        label="Match Instances",
        variable=match_mode_var,
        value=0,
        command=lambda: toggle_search_mode(0)
    )
    options_menu.add_radiobutton(
        label="Match Sentences",
        variable=match_mode_var,
        value=1,
        command=lambda: toggle_search_mode(1)
    )

    # History menu
    history_menu = tk.Menu(menu_bar, tearoff=0)
    
    history_menu.add_command(
        label="Recent Expressions", 
        command=show_recent_expressions
    )

    history_menu.add_separator()

    history_menu.add_command(
        label="Clear History",
        command=clear_history
    )

    # View menu
    view_menu = tk.Menu(menu_bar, tearoff=0)

    # Toggle between the Treeview Panel with one of two datasets
    view_menu.add_command(
        label="Regular Expression Cheatsheet",
        command=lambda: toggle_treeview_with_data(current_data)
    )
    view_menu.add_command(
        label="Saved Expressions",
        command=lambda: toggle_treeview_with_data(saved_expressions)
    )

    # Add menus to the menu bar
    menu_bar.add_cascade(label="File", menu=file_menu)
    menu_bar.add_cascade(label="Edit", menu=edit_menu)
    menu_bar.add_cascade(label="Options", menu=options_menu)
    menu_bar.add_cascade(label="History", menu=history_menu)
    menu_bar.add_cascade(label="View", menu=view_menu)

    window.config(menu=menu_bar)


def create_widgets(window):
    """Creates the main UI components by delegating to helper functions."""
    
    global main_frame, treeview_frame

    # Configure the grid layout of the main window.
    window.columnconfigure(0, weight=1)  	# Single column
    window.rowconfigure(1, weight=1)    	# Main frame (static widgets)
    window.rowconfigure(2, weight=0)    	# Treeview frame (toggling widget)

    # Create Toolbar
    create_toolbar(window)

    # Main Frame (Fixed Widgets)
    main_frame = create_main_frame(window)

    # Add Widgets to Main Frame
    create_regex_input(main_frame)              # Row 0 and 1
    create_regex_info_field(main_frame)         # Row 2 (Toggle-able)
    create_regex_input_buttons(main_frame)      # Row 3
    create_test_string_field(main_frame)        # Row 4
    create_match_results_field(main_frame)      # Row 5
    create_match_results_buttons(main_frame)    # Row 6

    # Create Collapsible Treeview Panel
    treeview_frame = create_treeview_panel(window)


def create_toolbar(window):
    """Creates a toolbar at the top of the window (for Treeview toggle buttons)"""
    
    toolbar = ttk.Frame(window, padding="5")
    toolbar.grid(row=0, column=0, sticky="w")  # Changed from "ew" to just "w"

    # Do NOT call columnconfigure — it causes expansion
    # toolbar.columnconfigure((0, 1), weight=1) 

    # Place both buttons in the SAME cell using a container frame
    button_container = ttk.Frame(toolbar)
    button_container.grid(row=0, column=0, sticky="w", padx=(0, 0)) # Just one column, so no need to configure columns

    # Button 1: RegEx CheatSheet
    cheat_button = ttk.Button(
        button_container,
        text="RegEx CheatSheet",
        command=lambda: toggle_treeview_with_data(current_data)
    )
    cheat_button.grid(row=0, column=0, padx=(0, 5), sticky="w")

    # Button 2: Saved Expressions
    saved_button = ttk.Button(
        button_container,
        text="Saved Expressions",
        command=lambda: toggle_treeview_with_data(saved_expressions)
    )
    saved_button.grid(row=0, column=1, sticky="w")


def create_main_frame(window):
    """Creates the main frame and configures its layout."""

    main_frame = ttk.Frame(window, padding="5")  # Add padding to the main frame
    main_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=0)

    # Configure 2-column layout weights for horizontal expansion
    main_frame.columnconfigure(0, weight=1)  # Left column
    main_frame.columnconfigure(1, weight=1)  # Right column

    # Configure row weights for vertical expansion
    main_frame.rowconfigure(0, weight=0)  # Regular Expression label  
    main_frame.rowconfigure(1, weight=0)  # Regular Expression text widget
    main_frame.rowconfigure(2, weight=0)  # RegEx Info Frame (Toggle-able)
    main_frame.rowconfigure(3, weight=0)  # Buttons below regex  
    main_frame.rowconfigure(4, weight=0)  # Test String/Match Results labels  
    main_frame.rowconfigure(5, weight=1)  # Test String/Match Results text widgets (expandable)
    main_frame.rowconfigure(6, weight=0)  # Clear Fields / Match Buttons
 
    return main_frame






def create_regex_info_field(parent):
    global regex_info_frame, regex_info_field

    regex_info_frame = ttk.Frame(parent)
    regex_info_frame.grid(row=2, column=0, columnspan=2, sticky="we")
    regex_info_frame.columnconfigure(0, weight=1)
    regex_info_frame.columnconfigure(1, weight=1)

    if active_regex_explanations.get():
        pattern = regex_input.get("1.0", "end-1c")
        try:
            re.compile(pattern)
            explanation = explain_regex(pattern)
        except re.error as e:
            explanation = format_regex_error(pattern, e)
        

        regex_info_field_label = ttk.Label(regex_info_frame, text="Explanation:")
        regex_info_field_label.grid(row=0, column=0, columnspan=2, sticky="w", pady=(5, 2))

        regex_info_field = tk.Text(regex_info_frame, height=3, wrap="word")
        regex_info_field.grid(row=1, column=0, columnspan=2, sticky="nsew", pady=(2, 5))
        regex_info_field.insert("1.0", explanation)
        regex_info_field.edit_reset()
    else:
        regex_info_frame.grid_remove()

'''
def create_regex_info_field(parent):
    """
    Adds a regex explanation field below the regex input field in the given parent frame.
    Toggled by the "Display Explanations of Regular Expressions" option in the Options menu.
    """

    global regex_info_frame, regex_info_field

    # Create a container frame for the toggleable regex_info_field and everything below
    regex_info_frame = ttk.Frame(parent)
    regex_info_frame.grid(row=2, column=0, columnspan=2, sticky="we")   

    regex_info_frame.columnconfigure(0, weight=1)
    regex_info_frame.columnconfigure(1, weight=1)

    if active_regex_explanations.get():
        # If explanations are active, create the regex info field
        regex_info = explain_regex(regex_input.get("1.0", "end-1c"))  # Get the regex text and explain it

        # RegEx Info Field Label
        regex_info_field_label = ttk.Label(regex_info_frame, text="Explanation:")
        regex_info_field_label.grid(row=0, column=0, columnspan=2, sticky="w", pady=(5, 2))

        # RegEx Info Text Widget (Read-Only)
        regex_info_field = tk.Text(regex_info_frame, height=3, wrap="word")																			   
        regex_info_field.grid(row=1, column=0, columnspan=2, sticky="nsew", pady=(2, 5))

        # Initial placeholder text (optional), then clear undo history
        # regex_info_field.insert("1.0", str(safe_parse_regex(regex_info)))
        regex_info_field.insert("1.0", regex_info)
        regex_info_field.edit_reset()  # Clears the undo stack, preventing first undo from wiping text

    else:
        regex_info_frame.grid_remove()'''


def create_regex_input(parent):
    """Adds a regular expression input field to the given parent frame."""

    # global middle_section
    global regex_button_frame, regex_info_field, regex_input, regex_info_frame

    # Label for the regex input
    regex_input_label = ttk.Label(main_frame, text="Regular Expression:")
    regex_input_label.grid(row=0, column=0, columnspan=2, sticky="w", pady=(5, 2))

    # Regex input field
    regex_input = tk.Text(main_frame, height=3, wrap="word")
    # regex_input = tk.Text(parent, height=3, wrap="word", undo=True, maxundo=-1) 																				   
    regex_input.grid(row=1, column=0, columnspan=2, sticky="we", pady=(2, 5))

    # Initial placeholder text (optional), then clear undo history																  
    regex_input.insert("1.0", r"\b([A-Za-z0-9.-]+)\.([A-Za-z]{2,}|org|net)\b|\d+\.\d+\.\d+")
    regex_input.edit_reset()  # Clears the undo stack, preventing first undo from wiping text

    # Tag for general regex status highlighting											   
    regex_input.tag_configure("regex_status", foreground="black")   # Do NOT configure to paint the background white.
    regex_input.tag_configure("sel", background="lightblue", foreground="black")  # Default selection colors
    regex_input.tag_lower("regex_status", "sel")    # Manually control which tag has priority (draw selection over my regex_status tag)
    validate_and_update_display()  # Validate regex in real time

    # Define tags for syntax highlighting										 
    for tag, color in syntax_highlighting_colors.items():
        regex_input.tag_configure(tag, foreground=color)

    # Bind Undo (Ctrl+Z) and Redo (Ctrl+Y) to regex_input 														  
    regex_input.bind("<Control-z>", lambda event: undo_action())
    regex_input.bind("<Control-y>", lambda event: redo_action())
			 
    # Keybinding for validating regex patterns											  
    regex_input.bind("<FocusOut>", on_user_edit, add="+")                   # (Never use <KeyRelease>!)	
    regex_input.bind("<KeyRelease>", update_regex_info, add="+")            # Update regex_info_field in real time
    regex_input.bind("<KeyRelease>", validate_and_update_display, add="+")  # Validate regex in real time

    # Apply syntax highlighting at program launch												 
    highlight_regex_syntax()

    # Read-only info field
    return regex_input


def create_regex_input_buttons(parent):
    """Adds buttons to the given parent frame."""

    # RegEx Input Buttons
    regex_input_button_frame = ttk.Frame(parent)
    regex_input_button_frame.grid(row=3, column=0, columnspan=2, pady=(5, 5), sticky="ew")

    # Configure two columns for edge alignment
    regex_input_button_frame.columnconfigure(0, weight=1)
    regex_input_button_frame.columnconfigure(1, weight=1)    

    # Clear button				  
    clear_regex_button = ttk.Button(
        regex_input_button_frame,
        text="Clear Field",
        command=lambda: regex_input.delete("1.0", tk.END))
    clear_regex_button.grid(row=2, column=0, pady=(5, 5), padx=(0, 5), sticky="w")

    # Save button				 
    save_regex_button = ttk.Button(
        regex_input_button_frame,
        text="Save Expression",
        command=create_save_expression_popup)
    save_regex_button.grid(row=2, column=1, pady=(5, 5), padx=(5, 0), sticky="e")    


def create_test_string_field(parent):
    """Adds test string text field to the left column of the given parent frame."""
    
    global test_string_input, test_string_label

    # Test String label & entry
    test_string_input_label = ttk.Label(parent, text="Test String:")
    test_string_input_label.grid(row=4, column=0, columnspan=2, sticky=tk.W, pady=(5, 2))

    test_string_input = tk.Text(parent, height=10, wrap="word")
    test_string_input.grid(row=5, column=0, columnspan=1, sticky="nsew", padx=(0, 5))

    test_string_input.bind("<KeyRelease>", on_user_edit)

    test_string_input.bind("<Control-z>", lambda event: undo_action())
    test_string_input.bind("<Control-y>", lambda event: redo_action())

    test_string_input.insert("end", 
"""Alice's email is alice@example.com.
Bob's domain is bobs-place.net.
Here's a malformed one: support@company.
Another good one: hello@dev-stack.io
Invalid: admin@nope
Visit us at www.docs.example.org
You can also ping the server at 192.168.0.1
"""
    )
    return test_string_input   


def create_match_results_field(parent):
    """Adds match results text field to the right column of the given parent frame."""

    global matching_buttons_frame, match_result
 
    # Match results label & output
    match_results_label = ttk.Label(parent, text="Match Results:")
    match_results_label.grid(row=4, column=1, sticky="w", pady=(5, 2))

    match_result = tk.Text(parent, height=10, wrap="word", state="disabled")
    match_result.grid(row=5, column=1, columnspan=1, sticky="nsew", padx=(5,0))

    return match_result


def create_match_results_buttons(parent):
    """Adds buttons to the given parent frame."""

    # RegEx Input Buttons
    match_results_button_frame = ttk.Frame(parent)
    match_results_button_frame.grid(row=6, column=0, columnspan=2, pady=(5, 5), sticky="ew")

    # Configure two columns for edge alignment
    match_results_button_frame.columnconfigure(0, weight=1)
    match_results_button_frame.columnconfigure(1, weight=1)

    # Clear Fields Button
    regex_input_clear_button = ttk.Button(
        match_results_button_frame, 
        text="Clear Fields", 
        command=clear_fields)
    regex_input_clear_button.grid(row=0, column=0, sticky="w")

    # Match Button
    match_results_button = ttk.Button(
        match_results_button_frame, 
        text="Match", 
        command=perform_match)
    match_results_button.grid(row=0, column=1, sticky="e")


def create_treeview_panel(window):
    """
    Creates the collapsible Treeview Panel with sample expression and result fields 
    spanning the entire window width.
    """
    
    global treeview_frame, sample_expression_widget, sample_results_widget

    treeview_frame = ttk.Frame(window, padding="5")
    treeview_frame.grid(row=3, column=0, sticky="nsew", padx=10, pady=0)
    treeview_frame.columnconfigure(0, weight=1)  # Spanning the entire width

    # Create Treeview Widgets
    create_treeview_section(treeview_frame, 0)
    
    # Bind selection event to automatically highlight first expression
    category_tree.bind("<<TreeviewSelect>>", on_category_select)    

    # Sample Expression Row (Label and Entry on the same line)
    sample_expression_label = ttk.Label(treeview_frame, text="Sample RegEx:")
    sample_expression_label.grid(row=1, column=0, sticky="nw", pady=(5, 0))

    # Place Generate button directly below the label, same column
    generate_button = ttk.Button(treeview_frame, text="Generate", command=auto_generate_sample)
    generate_button.grid(row=1, column=0, sticky="nw", pady=(25, 0))

    # Sample Expression Text widget (aligned to the right of label+button)
    sample_expression_widget = tk.Text(treeview_frame, height=3, wrap="word", state="disabled")
    sample_expression_widget.grid(row=1, column=0, rowspan=2, sticky="we", padx=(100, 5), pady=(5, 2), columnspan=2)

    # Sample Results Row (Label and Entry on the same line)
    sample_results_label = ttk.Label(treeview_frame, text="RegEx Result:")
    sample_results_label.grid(row=3, column=0, sticky="nw", pady=(5, 5))

    sample_results_widget = tk.Text(treeview_frame, height=3, wrap="word", state="disabled")
    sample_results_widget.grid(row=3, column=0, sticky="we", padx=(100, 5), pady=(5, 0), columnspan=2)
    # Add padding to the right side of the sample results widget

    # Adjust row weights
    treeview_frame.rowconfigure(0, weight=1)  # Treeview row expandable
    treeview_frame.rowconfigure(1, weight=0)  # Fixed height for Sample Expression row
    treeview_frame.rowconfigure(2, weight=0)  # Fixed height for Sample Results row

    treeview_frame.grid_remove()  # Start hidden
    return treeview_frame


# /User Interface -------------------------------------------------------------


# Syntax Highlighting Colors Pop-Up Interface ----------------------------------------------


def highlight_regex_syntax():
    """
    Use regular expressions to detect regex components (e.g. groups, classes, quantifiers).
    Applies syntax highlighting to the content of a regex input widget.
    Colorizes groups, anchors, character classes, quantifiers, etc.
    """
    
    global syntax_highlighting_colors       # Colors associated with each syntax type
    
    # Regular expression patterns per syntax type (prioritized to avoid overlaps)
    syntax_patterns = {
        # Anchors: start/end of string or word boundaries
        "Anchors": r"(?<!\\)(\^|\$|\\[bBAZG])",

        # Backreferences: numbered or named backrefs
        "Backreferences": r"(\\[1-9][0-9]*|\\g<\w+>|\\k<\w+>|\\k'\w+')",
        
        # Character classes: things inside square brackets
        "Character Classes": r"\[[^\]]+\]",

        # Comments
        "Comments": r"(?<!\\)#.*",                                       # # Comment (in verbose mode)

        # Escaped characters (non-special, formatting, etc.)
        "Escaped Characters": r"\\[abfnrtv\\]",                         # Non-special escaped chars	
        "Escaped (Non-Special)": r"\\[abfnrtv]",                        # Non-special escaped chars
        "Escaped (Hex)": r"\\x[0-9A-Fa-f]{2}",                          # \xFF
		"Escaped (Unicode)": r"\\u[0-9A-Fa-f]{4}|\\U[0-9A-Fa-f]{8}",    # \uFFFF or \UFFFFFFFF
		"Escaped (Octal)": r"\\0[0-7]{1,2}",                            # \077
		"unicode_properties": r"\\[pP]{\w+}",                           # \p{L}, \P{Nd}  
		
        # Groups: capturing, non-capturing, named
        #"group": r"\((\?P<[^>]+>|[?:=!<])?",
        "Group": r"\((?!\?P<|[?!:=><])",                                # Catch-all for other groups (plain)		
        "Group (Atomic)": r"\(\?>",                                     # (?>...)
		"Group (Named)": r"\(\?P<[^>]+>",                               # (?P<name>...)
		"Group (Non-capturing)": r"\(\?:",                              # (?:...)

	    # Flags and modifiers (?iLmsux) or (?x:...)	
		"Inline Flags": r"\(\?[aiLmsux]+(?=:|\))",                      # Inline flags like (?i), (?L), etc.

        # Lookahead/lookbehind (positive/negative)
        "Lookaheads": r"\(\?([=!<]=?|<!)",                              # Lookahead/lookbehind

        # Quantifiers: *, +, ?, and {m,n}                               # Most specific first
		"Quantifiers": r"(\*|\+|\?|\{\d+(,\d*)?\})",                    # Standard greedy	
        "Quantifiers (Lazy)": r"(\*\?|\+\?|\?\?|\{\d+(,\d*)?\}\?)",     # Lazy forms
	    "Quantifiers (Possessive)": r"(\*\+|\+\+|\?\+|\{\d+(,\d*)?\}\+)", # Greedy and possessive

        # Special metacharacters (.| or \d \w etc.)
		"Special": r"(?<!\\)(\.|\\[dDsSwW])",                           # . \d \w etc.
    }

    # Get the content of the regex input widget
    content = regex_input.get("1.0", "end-1c")
    
    # Clear all previous tags (remove from text, but keep tag definitions)
    for tag in syntax_highlighting_colors:
        regex_input.tag_remove(tag, "1.0", "end")
        regex_input.tag_configure(tag, foreground=syntax_highlighting_colors[tag])

    # Clear all previous tags (remove from text, but keep tag definitions)
    for tag in syntax_highlighting_colors:
        # Use tag_remove instead of tag_delete to clear highlighting from the text but keep the tag styles.
        regex_input.tag_remove(tag, "1.0", "end") 
        regex_input.tag_configure(tag, foreground=syntax_highlighting_colors[tag])

    # Apply each syntax pattern
    for syntax_type, pattern in syntax_patterns.items():
        for match in re.finditer(pattern, content):
            start, end = match.span()
            start_index = f"1.{start}"
            end_index = f"1.{end}"
            regex_input.tag_add(syntax_type, start_index, end_index)


def make_color_picker(tag_name, display_widget, settings_window):
    # Open color picker as child of settings_window
    color_code = colorchooser.askcolor(
        title=f"Choose color for {tag_name}",
        parent=settings_window  # Makes dialog transient to the settings window
    )[1]
    
    if color_code:
        syntax_highlighting_colors[tag_name] = color_code
        display_widget.config(bg=color_code)

        # Reconfigure just this tag
        regex_input.tag_configure(tag_name, foreground=color_code)
        # Reapply highlighting
        highlight_regex_syntax()


def reset_syntax_color_settings():
    for color, default_color in DEFAULT_SYNTAX_HIGHLIGHTING_COLORS.items():
        syntax_highlighting_colors[color] = default_color
        regex_input.tag_configure(color, foreground=default_color)

        if color in color_displays:
            color_displays[color].config(bg=default_color)

    highlight_regex_syntax()
            

def create_syntax_colors_popup():
    """
    Pop-up menu to allow user to customize regex syntax highlighting colors.
    Called from Options drop-down menu.
    """

    syntax_colors_popup = tk.Toplevel(root)
    syntax_colors_popup.title("Customize Syntax Highlighting Colors")
    syntax_colors_popup.resizable(False, False)

    # Make the settings window modal
    syntax_colors_popup.transient(root)                 # Ties windows to main program
    syntax_colors_popup.grab_set()                      # Prevent interaction with main window
    syntax_colors_popup.focus()                         # Set focus 
    syntax_colors_popup.lift(root)                      # Raise it above the main window
    syntax_colors_popup.protocol("WM_DELETE_WINDOW", syntax_colors_popup.destroy)


    row = 0

    for color in syntax_highlighting_colors:
        tk.Label(syntax_colors_popup, text=color.capitalize() + ":", anchor="w", width=18).grid(
            row=row, column=0, padx=10, pady=5, sticky="w")

        color_display = tk.Label(syntax_colors_popup, bg=syntax_highlighting_colors[color], width=10, relief="sunken")
        color_display.grid(row=row, column=1)

        pick_button = tk.Button(syntax_colors_popup, text="Change", 
                        command=lambda c=color, d=color_display: make_color_picker(c, d, syntax_colors_popup))
        pick_button.grid(row=row, column=2, padx=10)
        row += 1

    # Bottom frame for buttons
    matching_buttons_frame = tk.Frame(syntax_colors_popup)
    matching_buttons_frame.grid(row=row, column=0, columnspan=3, pady=10, sticky="ew")

    # Add a stretch column on either side to center the buttons
    matching_buttons_frame.columnconfigure(0, weight=1)
    matching_buttons_frame.columnconfigure(3, weight=1)

    # Place buttons in the center columns (1 and 2)
    tk.Button(matching_buttons_frame, text="Reset", command=reset_syntax_color_settings).grid(row=0, column=1, padx=10)
    tk.Button(matching_buttons_frame, text="Close", command=syntax_colors_popup.destroy).grid(row=0, column=2, padx=10)


# /Syntax Highlighting Colors Pop-Up Interface -------------------------------


# History Manager ------------------------------------------------------------


def clear_history():
    """
    Clears the history stack and redo stack, and notifies the user,
    after prompting for confirmation.
    """

    # Confirm deletion of History Stack
    confirm = messagebox.askyesno(
        "Confirm Deletion",
        "Are you sure you want to delete all previous Regular Expressions?\n\n"
        "This action will clear the entire history stack and cannot be undone.",
        parent=root  # Ensure the dialog is modal to the main window
    )
    
    if not confirm:
        # User chose not to clear history
        return

    # Clear the history stack and redo stack
    history['stack'].clear()
    history['redo_stack'].clear()

    # Properly clear the match_result text widget
    match_result.config(state="normal")
    match_result.delete("1.0", "end")
    match_result.config(state="disabled")

    root.bell()
    messagebox.showinfo("History Cleared", "The history stack has been cleared.")


def create_recent_expressions_treeview(parent, recent_states, restore_selected):
    """
    Creates a Treeview widget to display recent expressions and their match results,
    with sortable columns.
    """
    configure_treeview_style()

    # Frame to hold treeview and scrollbars
    recent_expressions_frame = ttk.Frame(parent)    # parent, not main_frame, is the popup
    recent_expressions_frame.grid(row=0, column=0, sticky="nsew")

    # Make the frame expandable
    recent_expressions_frame.rowconfigure(0, weight=1)
    recent_expressions_frame.columnconfigure(0, weight=1)

    # Create Treeview
    history_tree = ttk.Treeview(
        recent_expressions_frame,
        columns=("No", "Regex", "Match Results"),
        show="headings",
        height=15
    )

    history_tree.heading("No", text="#")
    history_tree.heading("Regex", text="Regular Expression")
    history_tree.heading("Match Results", text="Match Results")

    history_tree.column("No", width=40, anchor="center")
    history_tree.column("Regex", width=320, anchor="w")
    history_tree.column("Match Results", width=320, anchor="w")

    # Vertical scrollbar
    vertical_scrollbar = ttk.Scrollbar(
        recent_expressions_frame,
        orient="vertical",
        command=history_tree.yview
    )
    history_tree.configure(yscrollcommand=vertical_scrollbar.set)
												   
    # Horizontal scrollbar
    horizontal_scrollbar = ttk.Scrollbar(
        recent_expressions_frame,
        orient="horizontal",
        command=history_tree.xview
    )
    history_tree.configure(xscrollcommand=horizontal_scrollbar.set)
									
    # Place widgets using grid
    history_tree.grid(row=0, column=0, sticky="nsew")
    vertical_scrollbar.grid(row=0, column=1, sticky="ns")
    horizontal_scrollbar.grid(row=1, column=0, sticky="ew")

    # Reverse the order of recent states to show most recent first
    for idx, state in enumerate(reversed(recent_states)):
        regex = state.get("regex_input", "").replace("\n", " ")[:100]
        match_results = state.get("match_results", "")
        match_results_display = match_results.replace("\n", " ")[:100] if match_results and match_results.strip() else ""
        history_tree.insert("", "end", values=(idx + 1, regex, match_results_display))

    apply_row_styles(history_tree)
    #history_tree.bind("<Double-Button-1>", lambda event: on_key_double_click(event, redo_action()))
    history_tree.bind("<Double-Button-1>", lambda event: restore_selected())

    # Sorting logic continues from here...
    sort_state = {}

    def sort_by(col):
        reverse = sort_state.get(col, False)

        # Sort the data based on the column clicked
        # Use a tuple of (value, item) to sort by the column value
        data = [(history_tree.set(child, col), child) for child in history_tree.get_children('')]
        
        if col == "No":
            # Safely convert to int, put non-integers at the end
            def safe_int(val):
                """
                # Corrects attempt to return dictionary as integer
                Attempts to convert val to an integer.
                Returns the integer value if successful.
                If conversion fails, returns float('inf') so non-integer values sort to the end.
                """

                try:
                    return int(val)
                except Exception:
                    return float('inf')
            data.sort(key=lambda x: safe_int(x[0]), reverse=reverse)
        else:
            data.sort(key=lambda x: x[0].lower() if isinstance(x[0], str) else "", reverse=reverse)

        # Sort by the column value, converting to int for "No" column
        # Move items to the correct position in the Treeview
        for index, (_, item) in enumerate(data):
            history_tree.move(item, '', index)
        
        # Reset all column headers
        for column in history_tree["columns"]:
            history_tree.heading(column, text=column)
        
        # Apply arrow to current column
        arrow = ' ▼' if reverse else ' ▲'
        history_tree.heading(col, text=col + arrow)
        sort_state[col] = not reverse

        # Reapply row styles after sorting
        apply_row_styles(history_tree) 

    for col in history_tree["columns"]:
        history_tree.heading(col, command=lambda c=col: sort_by(c))

    # /Sorting Logic ------------------------

    # Initial sort by "No" descending (most recent first)
    history_tree.after(10, lambda: sort_by("No"))

    #return history_tree
    return history_tree


def HistoryManager():
    """
    Creates a simple, functional (function-based) history manager for undo/redo stacks.

    Returns:
        dict: A dictionary with the following keys:
            - 'record': function(state) -> None
                Records a new state in the history stack. If the state is identical to the last, it is not added.
                Clears the redo stack when a new state is recorded.
            - 'undo': function(current_state) -> state
                Moves one step back in the history stack and returns the previous state.
                If already at the earliest state, returns the current_state unchanged.
            - 'redo': function(current_state) -> state
                Moves one step forward in the redo stack and returns the next state.
                If there is nothing to redo, returns the current_state unchanged.
            - 'stack': list
                The list of recorded states (history).
            - 'redo_stack': list
                The list of states available for redo.

    Usage:
        history = HistoryManager()
        history['record'](state)
        state = history['undo'](current_state)
        state = history['redo'](current_state)
        # Access history['stack'] and history['redo_stack'] directly if needed.

    Notes:
        - The stack is limited to 100 entries (oldest entries are discarded).
        - This implementation does not use classes and is suitable for functional programming styles.
    """

    history = {
        'stack': [],
        'redo_stack': []
    }

    def record(state):
        # Record the current state in the history stack.
        # If the current state is the same as the last one, do not add a new
        if not history['stack'] or history['stack'][-1] != state:
            history['stack'].append(state.copy())
        
        # Limit stack size to 50 entries
        if len(history['stack']) > 50:
            history['stack'].pop(0)
        
        # Clear redo stack when a new record is added
        history['redo_stack'].clear()

    def undo(current_state):
        if len(history['stack']) > 1:
            history['redo_stack'].append(history['stack'].pop())
            return history['stack'][-1].copy()
        
        # If no undo available, return the current state
        return current_state

    def redo(current_state):
        if history['redo_stack']:
            state = history['redo_stack'].pop()
            history['stack'].append(state)
            return state.copy()
        
        # If no redo available, return the current state
        return current_state

    return {
        'record': record,
        'undo': undo,
        'redo': redo,
        'stack': history['stack'],
        'redo_stack': history['redo_stack'],
    }


history = HistoryManager()
history_timer = None


def get_current_state():
    return {
        # Only store match_result in history when perform_match is called
        # "match_results": match_result.get("1.0", "end-1c")
        "regex_input": regex_input.get("1.0", "end-1c"),
        "test_string_input": test_string_input.get("1.0", "end-1c"),
    }


def on_user_edit(event=None):
    """
    Stores user edits to the regex_input and test_string_input widgets for the history manager.
    Adds a new history record ONLY if the regex_input content has changed
    compared to the most recent entry in the history stack.

    This function is bound to the <FocusOut> event of the regex_input widget.

    perform_match(*args) is called to update the match results after each edit.

    Behavior:
        - When regex_input loses focus, the function checks if the current regex differs from the last recorded regex in history.
        - If the regex has changed, a new history record is created with the current regex and test string.
        - This prevents duplicate or unnecessary history entries and ensures that only meaningful changes are tracked.
        - The function also cancels any pending history timer to avoid race conditions.

    Args:
        event (tkinter.Event, optional): The event object from the widget event binding.
    """

    global history_timer

    # Cancel any pending history timer
    if history_timer:
        root.after_cancel(history_timer)
        history_timer = None

    # Get the widget that triggered the event
    widget = event.widget if event else None

    # If the event is from regex_input, check if the regex has changed
    if event and event.type == "9" and widget is regex_input:
        current_regex = regex_input.get("1.0", "end-1c")
        last_regex = None

        # If the regex_input is empty, do not record an empty state
        if not current_regex.strip():
            return

        # Check the last recorded regex in history
        # This ensures that we only record a new state if the regex has changed
        for entry in reversed(history['stack']):
            if 'regex_input' in entry:
                last_regex = entry['regex_input']
                break
        
        # If the current regex is different from the last recorded one, record it
        if current_regex != last_regex:
            state = {
                "regex_input": current_regex,
                "test_string_input": test_string_input.get("1.0", "end-1c"),
            }
            # Record the new state in history
            history['record'](state)


def redo_action(event=None):
    """Performs a redo action in the regex_input field."""

    state = history['redo'](get_current_state())
    restore_state(state)


def restore_state(state):
    # Restore regex_input to selected state
    regex_input.delete("1.0", "end")
    regex_input.insert("1.0", state.get("regex_input", ""))
    regex_input.edit_reset()  # Clear built-in undo stack

    # Apply syntax highlighting to the restored regex
    highlight_regex_syntax()

    # Restore test_string_input to selected state
    test_string_input.delete("1.0", "end")
    test_string_input.insert("1.0", state.get("test_string_input", ""))
    test_string_input.edit_reset()  # Clear built-in undo stack

    # Restore match_result if present
    match_result.config(state="normal")
    match_result.delete("1.0", "end")

    if "match_results" in state:
        match_result.insert("1.0", state["match_results"])

    match_result.config(state="disabled")


def show_recent_expressions():
    global history

    # Force a history record if regex_input has changed
    current_regex = regex_input.get("1.0", "end-1c")
    last_regex = None

											  
    for entry in reversed(history['stack']):
        if 'regex_input' in entry:
            last_regex = entry['regex_input']
            break


    # If the current regex is not empty and different from the last one, record it																				  
    if current_regex.strip() and current_regex != last_regex:
        state = {
            "regex_input": current_regex,
            "test_string_input": test_string_input.get("1.0", "end-1c"),
        }
        history['record'](state)

    # Get the last 25 states from history, or an empty list if no history exists																				
    recent_states = history['stack'][-25:] if len(history['stack']) > 0 else []

    # If no recent states, show a message and return
    # This ensures that the "Recent Expressions" popup is never empty.
    if not recent_states:
        messagebox.showinfo("Recent Expressions", "No recent expressions found.")
        return


    def restore_selected():
        sel = history_tree.selection()

        if not sel:
            return
        
        # Get the selected item index and restore the corresponding state
        idx = int(history_tree.item(sel[0])['values'][0]) - 1
        state = list(reversed(recent_states))[idx]
        restore_state(state)

        def close_popup():
            popup.destroy()
        
        # Delay closing the popup to ensure UI redraw
        # This is necessary to avoid flickering or incomplete UI updates.
        root.after(50, close_popup)

    # Create popup window
    popup = tk.Toplevel(root)
    popup.title("Recent Expressions")
    popup.geometry("900x500")
    popup.transient(root)
    popup.grab_set()

    # Configure the grid layout of popup
    popup.rowconfigure(0, weight=1)
    popup.columnconfigure(0, weight=1)

    # Add Treeview widget using grid (Don't forget to pass in restore_selected for double-click action)
    history_tree = create_recent_expressions_treeview(popup, recent_states, restore_selected)
    history_tree.grid(row=0, column=0, padx=10, pady=10, sticky="nsew") 

    # Configure the Treeview to allow selection
    # Configure hover effect for the history treeview													 
    configure_hover_effect(history_tree)

    # Frame for centering buttons
    btn_frame = ttk.Frame(popup)
    btn_frame.grid(row=1, column=0, pady=10, sticky="n")

    # Center-align the button group in 3 columns: [spacer][buttons][spacer]
    btn_frame.columnconfigure(0, weight=1)
    btn_frame.columnconfigure(1, weight=0)
    btn_frame.columnconfigure(2, weight=1)

    # Container frame for the Restore and Close buttons
    button_container = ttk.Frame(btn_frame)
    button_container.grid(row=0, column=1)  # Place in center column

    # Restore Button
    ttk.Button(
        button_container,
        text="Restore",
        command=restore_selected
    ).grid(row=0, column=0, padx=(0, 10))

    # Close Button
    ttk.Button(
        button_container,
        text="Close",
        command=popup.destroy
    ).grid(row=0, column=1)


def undo_action(event=None):
    """Performs an undo action in the regex_input field."""

    state = history['undo'](get_current_state())
    restore_state(state)


# /History Manager -----------------------------------------------------------


# Save RegEx Pop-Up Interface ------------------------------------------------


def create_save_expression_popup():
    """
    Create a popup window for saving a regular expression.
    """

    popup = tk.Toplevel(root)
    popup.title("Save Regular Expression")
    #popup.geometry("500x275")
    #popup.resizable(False, False)  # Prevent resizing
    popup.transient(root)  # Set the popup as a child of the main window

    # Frames for layout
    category_frame = ttk.Frame(popup, padding="10")
    category_frame.grid(row=0, column=0, sticky="nsew")

    regex_frame = ttk.Frame(popup, padding="10")
    regex_frame.grid(row=1, column=0, sticky="nsew")

    description_frame = ttk.Frame(popup, padding="10")
    description_frame.grid(row=2, column=0, sticky="nsew")

    sample_regex_frame = ttk.Frame(popup, padding="10")
    sample_regex_frame.grid(row=3, column=0, sticky="nsew")

    regex_result_frame = ttk.Frame(popup, padding="10")
    regex_result_frame.grid(row=4, column=0, sticky="nsew")
    
    save_button_frame = ttk.Frame(popup, padding="10")
    save_button_frame.grid(row=5, column=0, sticky="ew")

    # Configure column weights for proper layout
    popup.columnconfigure(0, weight=1)
    category_frame.columnconfigure(1, weight=1)
    regex_frame.columnconfigure(0, weight=1)
    description_frame.columnconfigure(0, weight=1)
    sample_regex_frame.columnconfigure(0, weight=1)
    regex_result_frame.columnconfigure(0, weight=1)
    save_button_frame.columnconfigure(0, weight=1)
    save_button_frame.columnconfigure(1, weight=1)

    # Category Section
    category_label = ttk.Label(category_frame, text="Category:")
    category_label.grid(row=0, column=0, sticky=tk.W, padx=(0, 5))

    # Retrieve and sort the saved categories to show first category by default
    categories = sorted(saved_expressions.keys())
    category_combobox = ttk.Combobox(category_frame, state="readonly", width=30)
    category_combobox["values"] = categories

    # Set the default value to the first category in the sorted list
    if categories:  # Ensure there are categories available
        category_combobox.set(categories[0])  # Set the default value to the first category

    #category_combobox = ttk.Combobox(category_frame, values=list(saved_expressions.keys()), state="readonly", width=30)
    category_combobox.grid(row=0, column=1, sticky=tk.W, padx=(5, 0))
    add_category_button = ttk.Button(category_frame, text="Add Category", command=lambda: add_new_category(category_combobox))
    add_category_button.grid(row=0, column=2, padx=(5, 0))

    # Regular Expression Display
    regex_display_label = ttk.Label(regex_frame, text="Regular Expression:")
    regex_display_label.grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    regex_display = tk.Text(regex_frame, height=3, wrap="word", width=60, state="disabled")
    regex_display.grid(row=1, column=0, columnspan=2, sticky="we", padx=(0, 0))

    # Populate the Regular Expression field
    regex_content = regex_input.get("1.0", tk.END).strip()

    if regex_content:  # Ensure regex_input has content
        regex_display.configure(state="normal")  # Temporarily make it editable
        regex_display.insert("1.0", regex_content)  # Insert the regex
        regex_display.configure(state="disabled")  # Disable editing again

    # Description Field
    description_field_label = ttk.Label(description_frame, text="Description:")
    description_field_label.grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    description_field = tk.Text(description_frame, height=3, wrap="word", width=60)
    description_field.grid(row=1, column=0, columnspan=2, sticky="we", padx=(0, 0))

    # Sample RegEx Field
    sample_regex_field_label = ttk.Label(sample_regex_frame, text="Sample RegEx:")
    sample_regex_field_label.grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    sample_regex_field = tk.Text(sample_regex_frame, height=3, wrap="word", width=60)
    sample_regex_field.grid(row=2, column=0, columnspan=2, sticky="we", padx=(0, 0))

    # RegEx Result Field
    regex_result_field_label = ttk.Label(regex_result_frame, text="RegEx Result:")
    regex_result_field_label.grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    regex_result_field = tk.Text(regex_result_frame, height=3, wrap="word", width=60)
    regex_result_field.grid(row=2, column=0, columnspan=2, sticky="we", padx=(0, 0))

    # Save and Cancel Buttons
    save_button = ttk.Button(
        save_button_frame,
        text="Save",
        command=lambda: save_expression(category_combobox, regex_display, description_field, sample_regex_field, regex_result_field, popup)
    )

    save_button.grid(row=0, column=0, sticky=tk.E, padx=5)

    cancel_button = ttk.Button(save_button_frame, text="Cancel", command=popup.destroy)
    cancel_button.grid(row=0, column=1, sticky=tk.W, padx=5)


def add_new_category(category_combobox):
    """
    Adds a new category to saved_expressions, updates the category_combobox, 
    and ensures categories are displayed alphabetically.
    """
    
    # Prompt the user for the new category name
    new_category = simpledialog.askstring("Add New Category", "Enter a new category name:")
    if not new_category:
        return  # User canceled or entered nothing

    # Trim whitespace and validate the input
    new_category = new_category.strip()
    if not new_category:
        messagebox.showerror("Invalid Input", "Category name cannot be empty.")
        return

    if new_category in saved_expressions:
        messagebox.showerror("Duplicate Category", f"The category '{new_category}' already exists.")
        return

    # Add the new category to saved_expressions
    saved_expressions[new_category] = {}

    # Save the updated saved_expressions to the JSON file
    try:
        with open(SAVED_FILE_PATH, "w") as file:
            json.dump(saved_expressions, file, indent=4)
    except Exception as e:
        messagebox.showerror("Error", f"Failed to save the new category: {e}")
        return

    # Update and sort the category_combobox values
    sorted_categories = sorted(saved_expressions.keys(), key=str.lower)
    category_combobox['values'] = sorted_categories
    category_combobox.set(new_category)  # Set the new category as the selected value

    # Update the category_tree if the Treeview Panel is displaying saved_expressions
    if treeview_visible and toggle_treeview_with_data._last_data_id == id(saved_expressions):  # type: ignore[attr-defined]
        # Insert the new category into the category_tree
        category_tree.insert("", "end", text=new_category)

        # Re-sort the category_tree alphabetically
        sort_category_tree()
                
    # Confirm category was created
    #messagebox.showinfo("Success", f"Category '{new_category}' added successfully.")
    root.bell() # Windows bell sound


def sort_category_tree():
    """
    Sorts the categories in the category_tree alphabetically.
    """
    
    # Get all current categories in the Treeview
    categories = [(category_tree.item(child, "text"), child) for child in category_tree.get_children()]

    # Sort categories by name
    categories.sort(key=lambda item: item[0].lower())

    # Re-insert categories in sorted order
    for index, (category_name, category_id) in enumerate(categories):
        category_tree.move(category_id, "", index)


def save_expression(category_combobox, regex_display, description_field, sample_regex_field, regex_result_field, popup):
    """
    Saves the current regular expression and description to the selected category
    in the `saved_expressions` nested dictionary.
    """

    # Get user input from the popup fields (Stripping whitespace)
    category = category_combobox.get().strip()
    regex = regex_display.get("1.0", tk.END).strip()
    description = description_field.get("1.0", tk.END).strip()
    sample_regex = sample_regex_field.get("1.0", tk.END).strip()
    regex_result = regex_result_field.get("1.0", tk.END).strip()
    sample_regex = sample_regex_field.get("1.0", tk.END).strip()
    regex_result = regex_result_field.get("1.0", tk.END).strip()

    if not category or not regex or not description:
        messagebox.showerror("Error", "Category, Regular Expression, and Description fields are required.")
        return

    # Determine if this is a new category
    is_new_category = category not in saved_expressions
    if is_new_category:
        saved_expressions[category] = {}

    # Add/update regular expression, sorting by description
    saved_expressions[category][regex] = {
        "description": description,
        "sample_expression": sample_regex,
        "sample_result": regex_result, 
        "sample_regex": sample_regex,
        "regex_result": regex_result
    }
    
    # Sort the expressions in the category by description
    saved_expressions[category] = dict(sorted(saved_expressions[category].items(), key=lambda item: item[1]["description"].lower()))

    # Save changes to JSON
    try:
        with open(SAVED_FILE_PATH, "w") as file:
            json.dump(saved_expressions, file, indent=4)
    except Exception as e:
        messagebox.showerror("Error", f"Failed to update saved_expressions.json: {e}")
        return

    # Notify user
    # messagebox.showinfo("Success", f"Expression saved to category '{category}'.")
    root.bell() # Windows bell sound

    # If the treeview is not visible or not showing saved_expressions, open it
    if not treeview_visible or last_treeview_data_id != id(saved_expressions):
        toggle_treeview_with_data(saved_expressions)
    else:
        # If already open and showing saved_expressions, just refresh contents
        populate_treeview(saved_expressions) # Refresh both trees


    # Ensure category is highlighted
    for child in category_tree.get_children():
        if category_tree.item(child, "text") == category:
            category_tree.selection_set(child)
            category_tree.focus(child)
            category_tree.see(child)
            # Simulate selection event to update right-side treeview
            category_tree.event_generate("<<TreeviewSelect>>")
            break

    # Delay highlighting to ensure UI updates first
    root.after(100, highlight_saved_expression, regex)

    # Close the popup
    popup.destroy()


def highlight_saved_expression(regex):
    """ Highlights the newly saved regular expression after a delay """
   
    for child in key_value_tree.get_children():
        item = key_value_tree.item(child)
        if item["values"] and item["values"][0] == regex:  # Match the moved regex
            key_value_tree.selection_remove(*key_value_tree.get_children())  # Clear previous selections
            key_value_tree.selection_set(child)  # Select the item
            key_value_tree.focus(child)  # Set focus to the specific item
            key_value_tree.see(child)  # Scrollto it to ensure it's visible
            key_value_tree.event_generate("<<TreeviewSelect>>")  # Simulate click to ensure UI update
            break


def delete_expression():
    """
    Deletes one or more selected regular expressions from the `saved_expressions` JSON file.
    If an entire category is emptied, prompts the user for confirmation before deleting it.
    After deletion, highlights the first category and its first regular expression.
	If no category is selected but a regular expression is, the correct category is auto-selected.
    """

    global saved_expressions

    # Get the selected category
    selected_category = category_tree.selection()
    if not selected_category:
        messagebox.showerror("Error", "Please select a category first.")
        return

    category_name = category_tree.item(selected_category[0], "text")

    # Get multiple selected regular expressions
    selected_items = key_value_tree.selection()
    if not selected_items:
        messagebox.showerror("Error", "Please select at least one regular expression to delete.")
        return

    # Extract the regex expressions from the selection
	# This line allows multiple expressions to be selected simultaneously.
    selected_regexes = [key_value_tree.item(item, "values")[0] for item in selected_items]

    # Confirm deletion of selected regexes
    confirm = messagebox.askyesno(
        "Confirm Deletion",
        f"Are you sure you want to delete the following regular expressions from '{category_name}'?\n\n"
        + "\n".join(selected_regexes)
    )
    
    if not confirm:
        return

    # Delete selected regexes from saved_expressions
    if category_name in saved_expressions:
        category_data = saved_expressions[category_name]
        for regex in selected_regexes:
            if regex in category_data:
                del category_data[regex]  # Remove from dictionary

        # If category is now empty, ask to delete the category
        if not category_data:
            delete_category = messagebox.askyesno(
                "Delete Category",
                f"The category '{category_name}' is now empty.\n\n"
                "Do you want to delete this category as well?"
            )
            if delete_category:
                del saved_expressions[category_name]  # Delete category
                category_tree.delete(selected_category[0])  # Remove from category_tree

                # Save the updated JSON
                try:
                    with open(SAVED_FILE_PATH, "w") as file:
                        json.dump(saved_expressions, file, indent=4)
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to update saved_expressions.json: {e}")
                    return

                # Refresh category_tree
                populate_treeview(saved_expressions)

                # Select the first category in category_tree
                category_items = category_tree.get_children()
                if category_items:
                    first_category = category_items[0]  # Get first category
                    category_tree.selection_set(first_category)
                    category_tree.focus(first_category)
                    category_tree.see(first_category)

                    # Display the first category’s expressions in key_value_tree
                    first_category_name = category_tree.item(first_category, "text")
                    display_key_value_pairs(saved_expressions.get(first_category_name, {}), key_value_tree)

                    # Highlight the first regular expression in key_value_tree
                    root.after(100, highlight_first_available_expression)

                return  # Stop execution after category deletion

    # Save updated JSON file
    try:
        with open(SAVED_FILE_PATH, "w") as file:
            json.dump(saved_expressions, file, indent=4)
    except Exception as e:
        messagebox.showerror("Error", f"Failed to update saved_expressions.json: {e}")
        return

    # Refresh key_value_tree after deletion
    display_key_value_pairs(saved_expressions.get(category_name, {}), key_value_tree)

    # Highlight the first remaining regex in the category
    root.after(100, highlight_first_available_expression)

    messagebox.showinfo("Success", "The selected expression was successfully deleted.")


def highlight_first_available_expression():
    """
    Highlights the first available regular expression in key_value_tree.
    If no expressions remain, the key_value_tree stays empty.
    Used after deletion or when switching between categories.
    """

    key_items = key_value_tree.get_children()
    if key_items:
        first_key = key_items[0]  # Select first available regular expression
        key_value_tree.selection_set(first_key)
        key_value_tree.focus(first_key)
        key_value_tree.see(first_key)
        key_value_tree.event_generate("<<TreeviewSelect>>")


def move_expression_popup():
    """
    Opens a popup window allowing the user to move a selected regular expression
    from one category to another using a listbox instead of a combobox.
    """

    global saved_expressions

    # Get selected expression and category
    selected_category_item = category_tree.selection()
    selected_expression_item = key_value_tree.selection()

    if not selected_category_item or not selected_expression_item:
        messagebox.showerror("Error", "Please select a regular expression to move.")
        return

    current_category = category_tree.item(selected_category_item[0], "text")
    selected_expression = key_value_tree.item(selected_expression_item[0], "values")[0]	 # Get regex pattern
    selected_expression_key = selected_expression
    selected_expression_desc = saved_expressions[current_category].get(
        selected_expression_key, {}
    ).get("description", "Unknown Description")
	
	# Validate that the selected expression exists in the current category
    if current_category not in saved_expressions or selected_expression not in saved_expressions[current_category]:
        messagebox.showerror("Error", "Invalid selection. Expression not found.")
        return

    # Open Move Expression Popup
    popup = tk.Toplevel(root)
    popup.title("Move Expression")
    popup.geometry("400x300")
    popup.resizable(False, False)
    popup.transient(root)

    # Configure popup grid
    popup.columnconfigure(0, weight=1)
    popup.rowconfigure(1, weight=1)  # make the listbox row expandable

    # Label
    label = ttk.Label(
        popup,
        text=f"Move the regular expression\n'{selected_expression_desc}'\n"
             f"'{selected_expression_key}'\n"
             f"from the '{current_category}' category to:",
        anchor="center",
        justify="center"
    )
    label.grid(row=0, column=0, padx=10, pady=(10, 5), sticky="ew")

    # Create category list (excluding current category)
    available_categories = [cat for cat in saved_expressions.keys() if cat != current_category]

    if not available_categories:
        messagebox.showerror("Error", "No other categories available.")
        popup.destroy()
        return

    # Create a Frame for the Listbox and Scrollbar
    listbox_frame = ttk.Frame(popup)
    listbox_frame.grid(row=1, column=0, padx=10, pady=5, sticky="nsew")
    listbox_frame.columnconfigure(0, weight=1)
    listbox_frame.rowconfigure(0, weight=1)

    # Listbox for category selection
    category_listbox = tk.Listbox(listbox_frame, height=8, exportselection=False)
    category_listbox.grid(row=0, column=0, sticky="nsew", padx=(0, 5), pady=5)

    # Scrollbar for the listbox
    scrollbar = ttk.Scrollbar(listbox_frame, orient="vertical", command=category_listbox.yview)
    scrollbar.grid(row=0, column=1, sticky="ns", pady=5)
    category_listbox.config(yscrollcommand=scrollbar.set)

    # Populate listbox with categories
    for category in sorted(available_categories):
        category_listbox.insert("end", category)

    # Select first category by default									  
    category_listbox.select_set(0)

    # Buttons to confirm or cancel
    confirm_cancel_button_frame = ttk.Frame(popup)
    confirm_cancel_button_frame.grid(row=2, column=0, pady=10)

    # Buttons
    ok_button = ttk.Button(
        confirm_cancel_button_frame,
        text="OK",
        command=lambda: move_expression(category_listbox, current_category, selected_expression, popup)
    )
    ok_button.grid(row=0, column=0, padx=10)

    cancel_button = ttk.Button(confirm_cancel_button_frame, text="Cancel", command=popup.destroy)
    cancel_button.grid(row=0, column=1, padx=10)


def move_expression(category_listbox, old_category, regex, popup):
    """
    Moves the selected regular expression from old_category to the new category.
    Updates JSON file and refreshes Treeview widgets.
    """

    global saved_expressions

    # Get selected category from listbox
    selected_index = category_listbox.curselection()
    if not selected_index:
        messagebox.showerror("Error", "Please select a category.")
        return

    new_category = category_listbox.get(selected_index[0])

    if new_category not in saved_expressions:
        saved_expressions[new_category] = {}

    # Move the expression
    saved_expressions[new_category][regex] = saved_expressions[old_category][regex]
    del saved_expressions[old_category][regex]

    # If the old category is now empty, prompt for deletion
    if not saved_expressions[old_category]:
        delete_category = messagebox.askyesno(
            "Delete Empty Category",
            f"The category '{old_category}' is now empty.\n\nDo you want to delete this category?"
        )
        if delete_category:
            del saved_expressions[old_category]

    # Sort new category alphabetically by description
    saved_expressions[new_category] = dict(
        sorted(
            saved_expressions[new_category].items(),
            key=lambda item: item[1]["description"].lower()
        )
    )

    # Save changes to JSON file
    try:
        with open(SAVED_FILE_PATH, "w") as file:
            json.dump(saved_expressions, file, indent=4)
    except Exception as e:
        messagebox.showerror("Error", f"Failed to update saved_expressions.json: {e}")
        return

    # Refresh Treeview to reflect changes
    populate_treeview(saved_expressions)

    # Highlight the new category in category_tree
    for child in category_tree.get_children():
        item_text = category_tree.item(child, "text")
        if item_text == new_category:
            category_tree.selection_set(child)
            category_tree.focus(child)
            category_tree.see(child)
            break

    # Highlight the moved expression in key_value_tree
    root.after(100, lambda: highlight_saved_expression(regex))

    # Close the popup
    popup.destroy()

    #messagebox.showinfo("Success", f"Expression moved to '{new_category}' successfully!")
    root.bell() # Windows bell sound


# /Save RegEx Pop-Up Interface ------------------------------------------------


# Matching Functions ----------------------------------------------------------


def clear_fields():
    #regex_input.delete("1.0", tk.END)
    test_string_input.delete("1.0", tk.END)
    match_result.config(state="normal")
    match_result.delete("1.0", tk.END)
    match_result.config(state="disabled")


def export_results(include_highlighting=True):
    """ 
    Exports the search results from the match_result Text widget to an RTF file.
    
    Args:
        include_highlighting (bool, optional): _description_. Defaults to True.
    """

    header = simpledialog.askstring("Export Header", "Enter header for exported file:", initialvalue="Search Results:\n")

    if not header:
        header = "Search Results:\n"
    header = "\\b " + rtf_escape(header).replace("\n", "\\line ") + "\\b0"

    # Ensure match_result is not empty
    match_result_text = match_result.get("1.0", tk.END).strip()
    if not match_result_text:
        print("No results to export.")
        return

    # Prompt user to save the file
    file_path = filedialog.asksaveasfilename(
        defaultextension=".rtf",
        filetypes=[("Rich Text Format", "*.rtf"), ("All Files", "*.*")]
    )
    if not file_path:
        return  # User cancelled the save dialog

    try:
        # Begin writing the RTF content
        with open(file_path, "w") as file:
            # RTF header with color table for highlighting
            file.write("{\\rtf1\\ansi\\deff0\n")
            if include_highlighting:
                file.write("{\\colortbl;\\red255\\green255\\blue0;}\n")  # color table for yellow

            # Add header text with a blank line
            file.write(header + "\\line \\line ")

            # Write the main content# Retrieve text and highlighted regions
            full_text = match_result.get("1.0", tk.END)    # Get the full text

            if include_highlighting:
                highlight_ranges = match_result.tag_ranges("highlight")   # Get highlight ranges
                # Initialize absolute position tracker
                current_pos = 0

                for i in range(0, len(highlight_ranges), 2):
                    # Get start and end indices of the highlight in absolute positions
                    start = match_result.index(highlight_ranges[i])
                    end = match_result.index(highlight_ranges[i + 1])

                    start_idx = index_to_offset(match_result, start)
                    end_idx = index_to_offset(match_result, end)

                    # Write normal text before the highlighted section  
                    if current_pos < start_idx:
                        normal_text = full_text[current_pos:start_idx]
                        file.write(rtf_escape(normal_text).replace("\n", "\\line "))

                    # Write the highlighted section   
                    highlighted_text = full_text[start_idx:end_idx]
                    file.write("{\\highlight1 " + rtf_escape(highlighted_text).replace("\n", "\\line ") + "}")

                    # Update the current position tracker
                    current_pos = end_idx

                # Write any remaining text after the last highlight
                if current_pos < len(full_text):
                    remaining = full_text[current_pos:]
                    file.write(rtf_escape(remaining).replace("\n", "\\line "))
            else:
                file.write(rtf_escape(full_text).replace("\n", "\\line "))

            # End the RTF document
            file.write("}")

        # Notify user of successful export
        # print(f"Results exported to {file_path}")
        # messagebox.showinfo("Export Successful", f"Results saved to {file_path}")

    except Exception as e:
        print(f"Error exporting results: {e}")
        messagebox.showerror("Export Error", f"Failed to save file: {str(e)}")


def index_to_offset(widget, index):
    """
    Convert indices to absolute character positions
    This function converts a Tkinter Text widget index to an absolute offset
    from the start of the text, which is useful for RTF export."""

    try:
        return len(widget.get("1.0", index))
    except Exception as e:
        print(f"Index error from 1.0 to {index}: {e}")
        return 0


def match_instances(*args):
    """Displays instances of matching search term in Match Result Window"""
    
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights
    test_string_input.tag_remove("highlight", "1.0", tk.END)
	# No need to remove highlighting from match_result

    try:
        # Find sentences containing matches
       
        matches = re.finditer(regex, test_string)
		#No need to split sentences
		
        result_instances = ""   

        for match in matches:
            # Step 2: Highlight matches in Test String widget
            start_idx = f"1.0 + {match.start()} chars"
            end_idx = f"1.0 + {match.end()} chars"
            # Highlight the match
            test_string_input.tag_add("highlight", start_idx, end_idx)

            # Add match details to result
            result_instances += f"{match.group()}\n\n"  # Add a blank line after each result

        if not result_instances:
            result_instances = "No matches found."

        # Apply highlighting style
        test_string_input.tag_config("highlight", background="yellow", foreground="black")

        # Update the Match Results widget
        match_result.config(state='normal')
        match_result.delete("1.0", tk.END)
        match_result.insert(tk.END, result_instances)
        match_result.config(state='disabled')

    except re.error as e:
        # Handle regex errors
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)
        match_result.insert(tk.END, str(safe_parse_regex(regex)))
        '''match_result.insert(tk.END, f"Invalid regular expression: {str(e)}")'''
        match_result.config(state="disabled")


def match_sentences(*args):
    """Displays sentences containing instances of matching search term in Match Result Window"""
    
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights in both widgets
    test_string_input.tag_remove("highlight", "1.0", tk.END)
    match_result.tag_remove("highlight", "1.0", tk.END)

    try:
        # Find sentences containing matches
        matches = list(re.finditer(regex, test_string))
        sentences = test_string.split('\n')
        # sentences = re.split(r'(?<=[.!?])\s+|\n', test_string)
        # sentences = test_string.splitlines()
        # sentences = re.split(r'(?<=[.!?])\s+|\n+', test_string)
        # sentences = re.split(r'(?<=[.!?])[\s\n]+', test_string) # will not split sentences that are simply separated by newlines if those newlines are not immediately preceded by ., !, or ?.
        # sentences = re.split(r'(?<=[.!?])\s+|\n+', test_string) # Split into sentences.  Break at punctuation and newlines.
        # sentences = re.split(r'(?<=[.!?])\s+', test_string)  # Split into sentences																																																					 
																					 
        print("Sentences:", repr(sentences))
        result_sentences = []  # To store unique sentences with matches
        print("result_sentences 0:", result_sentences)
        
        for match in matches:
            for sentence in sentences:
                if match.group() in sentence and sentence not in result_sentences:
                    result_sentences.append(sentence)
                    break

        print("result_sentences 1:", result_sentences)                    

		# Display sentences in match_result
        # Always make widget editable before updating it
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)

        if result_sentences:
            # Display results
            for sentence in result_sentences:
                for line in sentence.splitlines():
                    match_result.insert(tk.END, line + "\n")
                    match_result.insert(tk.END, "\n\n")  # Add a blank line after each sentence
           
            # Highlight matches in match_result
            match_result_text = match_result.get("1.0", tk.END)
   
            for match in re.finditer(regex, match_result_text):
                start_idx = f"1.0 + {match.start()} chars"
                end_idx = f"1.0 + {match.end()} chars"
                match_result.tag_add("highlight", start_idx, end_idx)

            match_result.tag_config("highlight", background="yellow", foreground="black")

        else:
            print("result_sentences 2:", result_sentences)
            match_result.insert(tk.END, "No matches found.")
										 
        match_result.config(state="disabled")

    except re.error as e:
		# Handle regex errors					 
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)
        match_result.insert(tk.END, f"Invalid regular expression: {str(e)}")
        match_result.config(state="disabled")


def perform_match(*args):
    """Determines match mode dynamically and performs the appropriate matching."""
    global match_results_as_instances

    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    if not regex:
        messagebox.showwarning("Input Error", "Regular Expression field cannot be empty.")
        return

    if not test_string:
        messagebox.showwarning("Input Error", "Test String field cannot be empty.")
        return

    # Perform the match
    if match_mode_var.get() == 0:
        match_instances(*args)
    else:
        match_sentences(*args)

    # Prepare new state
    state = get_current_state()
    state["match_results"] = match_result.get("1.0", "end-1c")

    # Overwrite the last entry if it matches the current regex and has no match_results
    for i in range(len(history['stack']) - 1, -1, -1):
        entry = history['stack'][i]
        if entry.get('regex_input') == state['regex_input']:
            if 'match_results' not in entry:
                history['stack'][i] = state.copy()
                history['redo_stack'].clear()
                return
            break

    # Otherwise, add a new record
    history['record'](state)


def rtf_escape(text):
    """
    Escapes special characters for RTF format.
    This function replaces backslashes, curly braces, and other special characters
    with their RTF-safe equivalents.

    Used in the export_results function to ensure the text is safe for RTF output.
    
    Args:
        text (str): The text to escape for RTF format.
    """ 

    return text.replace("\\", "\\\\").replace("{", "\\{").replace("}", "\\}")


def toggle_search_mode(new_mode):
    """
    Toggles between match modes and re-runs the search if results are present.
    """

    # Update the match_mode_var to reflect the new mode
    match_mode_var.set(new_mode)

    def is_match_result_empty():
        """Checks if the match_result text widget is empty."""

        content = match_result.get("1.0", tk.END).strip()  # Get all text and remove surrounding whitespace
        return len(content) == 0  # True if empty, False otherwise

    # Check if match_result has content
    if not is_match_result_empty():
        # Re-run the search in the new mode
        perform_match()
    else:
        print(f"Search mode set to: {'Instances' if new_mode == 0 else 'Sentences'}")


def validate_and_update_display(event=None):
    """
    Checks the validity of regular expressions entered into the regex_input
    text widget, then updates the background using the 'regex_status' tag,
    but only if the user hasn't deactivated the active_validation variable 
    under the View menu.
    Green = valid regex, Red = invalid regex, White = empty.
    """

    global active_validation

    if not active_validation.get():
        # Reset the background to white and remove any highlighting
        regex_input.tag_configure("regex_status", background="white")
        regex_input.tag_add("regex_status", "1.0", tk.END)
        return  # Skip validation logic
    
    # Get text from the regex_input text widget created in create_regex_input
    expression = regex_input.get("1.0", tk.END).strip()
    regex_input.tag_remove("regex_status", "1.0", tk.END)

    # If input is empty, use neutral background
    if not expression:
        # Apply the "regex_status" tag across the entire input
        regex_input.tag_add("regex_status", "1.0", tk.END)
        regex_input.tag_configure("regex_status", background="white")
        return

    # Validate regex and set background color
    try:
        re.compile(expression) # Valid pattern
        # Apply the "regex_status" tag across the entire input
        regex_input.tag_add("regex_status", "1.0", tk.END)
        regex_input.tag_configure("regex_status", background="#d1ffdb")  # light green
    except re.error: # Invalid pattern
        # Apply the "regex_status" tag across the entire input
        regex_input.tag_add("regex_status", "1.0", tk.END)
        regex_input.tag_configure("regex_status", background="#ff7f7f")  # light red


# /Matching Functions ---------------------------------------------------------


# Treeview Functions ---------------------------------------------------------


def create_treeview_section(parent, row):
    """
    Creates the Treeview section with two widgets: category_tree and key_value_tree.
    """

    global category_tree, key_value_tree

    # Removed code for creating "Tree" that causes Treeview to span two columns

    # Adjust column weights to control widths of the Treeview widgets
    parent.columnconfigure(0, weight=1)  # Left column: Narrower
    parent.columnconfigure(1, weight=4)  # Right column: Wider
    # These two lines of code can be set to weights of 2/2, 1/3, 1/4 or deleted altogether

    # Category Treeview (Left)
    category_tree = create_category_treeview(parent, row)
    category_tree.grid(row=row, column=0, sticky="nsew", padx=(0, 5))
  
    # Key-Value Treeview (Right)
    key_value_tree = create_key_value_treeview(parent)
    key_value_tree.grid(row=row, column=1, sticky="nsew", padx=(5, 0))

    # No need to bind <<TreeviewSelect>> here; populate_treeview handles this dynamically

    # Add some space beneath the Treeview widgets
    parent.grid_rowconfigure(1, weight=1, pad=10)  # Add 10px padding
    
    return parent # If not creating a new "tree" Treeview, return parent


def create_category_treeview(parent, row):
    """Creates the Category Treeview with styles."""
    
    configure_treeview_style()

    tree = ttk.Treeview(parent, show="tree", selectmode="browse", style="Custom.Treeview") 
    # style="Custom.Treeview" ensures that the Treeview's alternate row styling is visible

    tree.column("#0", width=150, anchor="w", stretch=True)  # Set the width of the left tree

    scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
    scrollbar.grid(row=0, column=1, sticky="ns")
    tree.configure(yscrollcommand=scrollbar.set)

    # Populate with the top-level keys of the current_data json (Previously categories)
    for category in current_data.keys():
        tree.insert("", "end", text=category)

    return tree


def create_key_value_treeview(parent):
    """
	Creates the Key-Value Treeview with sortable columns, styles, and alternating row colors.
	Initially sorted by the Key column in ascending order.
	"""

    treeview_widget = ttk.Treeview(parent, columns=("Key", "Value"), show="headings", style="Custom.Treeview")
    # !Remember: Excluding style="Custom.Treeview" from line above removes alternating row style!   
 
    # Configure column headers and widths
    treeview_widget.heading("Key", text="Key")
    treeview_widget.heading("Value", text="Value")

    treeview_widget.column("Key", width=100, anchor="w")
    treeview_widget.column("Value", width=350, anchor="w")

    # Add scrollbars
    vertical_scrollbar = ttk.Scrollbar(parent, orient="vertical", command=treeview_widget.yview)
    horizontal_scrollbar = ttk.Scrollbar(parent, orient="horizontal", command=treeview_widget.xview)
    vertical_scrollbar.grid(row=0, column=2, sticky="ns")
    horizontal_scrollbar.grid(row=1, column=1, sticky="ew")
    treeview_widget.configure(yscrollcommand=vertical_scrollbar.set, xscrollcommand=horizontal_scrollbar.set)

    apply_row_styles(treeview_widget)
    configure_hover_effect(treeview_widget)

    # Double-click to insert regex
    treeview_widget.bind("<Double-Button-1>", lambda event: on_key_double_click(event, treeview_widget))

    # Sorting logic
    sort_state = {}

    def sort_by(col):
        """
		Sort headers with toggle arrows without using globals
		"""
	
        reverse = sort_state.get(col, False)
        data = [(str(treeview_widget.set(child, col)).lower(), child) for child in treeview_widget.get_children('')]
        data.sort(reverse=reverse)

        for index, (_, item) in enumerate(data):
            treeview_widget.move(item, '', index)

        # Reset all column headers
        for column in treeview_widget["columns"]:
            treeview_widget.heading(column, text=column)

        # Apply arrow to current column
        arrow = ' ▼' if reverse else ' ▲'
        treeview_widget.heading(col, text=col + arrow)

        # Update state
        sort_state[col] = not reverse
        
        # Restore alternating row styling after sorting
        apply_row_styles(treeview_widget)

    for col in treeview_widget["columns"]:
        treeview_widget.heading(col, command=lambda c=col: sort_by(c))

    # Initial sort by "Key" ascending
    treeview_widget.after(10, lambda: sort_by("Key"))

    # Return the Treeview
    return treeview_widget


def display_key_value_pairs(category_data, key_value_tree):
    """
    Populates the key_value_tree with the key-value pairs of the selected category.
    Applies alternating row styling after populating.
    Always sorts entries by the description field.
    Updates sample expression widget
    """
    
    # Clear existing data   
    key_value_tree.delete(*key_value_tree.get_children())  # Clear previous entries

	# Sort entries by the regex string (key)key_value_tree
    sorted_items = sorted(category_data.items(), key=lambda item: item[0])

    for key, value in sorted_items:	
        key_value_tree.insert("", "end", values=(key, value["description"]))

    # Apply alternating row styling
    apply_row_styles(key_value_tree)

    # Bind selection event to update Sample Expression fields
    key_value_tree.bind("<<TreeviewSelect>>", lambda event: update_sample_expression(category_data))


def on_category_select(event):
    """
    Handles selection in the category_tree and updates key_value_tree.
    Automatically highlights the first regular expression.
    """
    
    selected_item = category_tree.selection()
    if selected_item:
        category_name = category_tree.item(selected_item[0], "text")
        # category_name = category_tree.item(selected_item, "text")

        # Display key-value pairs in key_value_tree
        if category_name in saved_expressions:
            display_key_value_pairs(saved_expressions[category_name], key_value_tree)

            # Highlight the first regular expression after UI updates
            root.after(100, highlight_first_expression)

     
def on_key_double_click(event, tree):
    """
    Handles double-clicks on the Key-Value Treeview by appending the key to 
    the regex_input field.
    """
    
    # Get the selected item
    selected_item = tree.focus()

    if not selected_item:
        return  # No item selected

    # Retrieve the key from the selected row
    selected_values = tree.item(selected_item, "values")

    if selected_values:
        key = selected_values[0]  # The key is in the first column

        # Append the key to the regex_input
        current_text = regex_input.get("1.0", tk.END).strip()  # Get current content
        new_text = current_text + key  # Append the key
        regex_input.delete("1.0", tk.END)  # Clear the current content
        regex_input.insert("1.0", new_text)  # Insert the updated content
    
    # Schedule highlighting after widget update
    regex_input.after_idle(highlight_regex_syntax)
    update_regex_info()     # Ensure that the regex_info_field updates when a user double-clicks a Treeview row


def populate_treeview(data):
    """
    Populates the category_tree with the given data.
    Clears the key_value_tree to start fresh.
    """
    
    # Clear the left and right Treeview widgets
    category_tree.delete(*category_tree.get_children())
    key_value_tree.delete(*key_value_tree.get_children())

    # Alphabetize categories
    # Sort categories (top-level keys) alphabetically
    sorted_categories = sorted(data.keys(), key=str.lower)

    # Populate the left Treeview with sorted categories
    for category in sorted_categories:
        category_tree.insert("", "end", text=category)
    
    # Set up selection binding for the left Treeview
    def on_select(event):
        selected_item = category_tree.focus()
        if selected_item:
            category = category_tree.item(selected_item, "text")
            display_key_value_pairs(data.get(category, {}), key_value_tree)

    category_tree.bind("<<TreeviewSelect>>", on_select)

    # Bind selection for the right-side Treeview
    def on_key_select(event):
        selected_item = key_value_tree.focus()
        if selected_item:
            item_data = key_value_tree.item(selected_item, "values")
            if item_data:
                regex = item_data[0]
                for key, inner_data in data.items():
                    if regex in inner_data:
                        sample_expression_widget.delete(0, tk.END)
                        sample_expression_widget.insert(0, inner_data[regex].get("sample_expression", ""))
                        sample_results_widget.delete(0, tk.END)
                        sample_results_widget.insert(0, inner_data[regex].get("sample_result", ""))
                        break

    key_value_tree.bind("<<TreeviewSelect>>", on_key_select)


# Add this global variable at the top of your file, near other globals:
# last_treeview_data_id = None

def toggle_treeview_with_data(data):
    """
    Toggles the Treeview Panel on/off or repopulates it if the data changes.
    Ensures the first category and first regular expression are highlighted.
    """
    
    global treeview_visible, treeview_frame, last_treeview_data_id

    # If the panel is already open and showing the same data, toggle it off
    if treeview_visible and last_treeview_data_id == id(data):
        treeview_frame.grid_remove()
        treeview_visible = False
        last_treeview_data_id = None  # Reset stored dataset ID

        # Explicitly Resize the Window After Hiding the Treeview 🔽
        root.update_idletasks()  # Ensure UI updates
        new_height = root.winfo_reqheight()  # Get required height
        root.geometry(f"{root.winfo_width()}x{new_height}")  # Resize window
        return  # Exit function after closing

    # Otherwise, show the Treeview Panel and populate it with new data
    treeview_frame.grid(row=2, column=0, sticky="nsew")
    populate_treeview(data)
    last_treeview_data_id = id(data)
    treeview_visible = True

    # Adjust window size dynamically
    root.update_idletasks()
    new_height = root.winfo_reqheight()
    root.geometry(f"{root.winfo_width()}x{new_height}")

    # Ensure categories exist before selecting one
    category_items = category_tree.get_children()
    if category_items:
        first_category = category_items[0]  # Get first category ID

        # Highlight & scroll to the first category
        category_tree.selection_set(first_category)
        category_tree.focus(first_category)
        category_tree.see(first_category)

        # Get the category name
        category_name = category_tree.item(first_category, "text")

        # Ensure the first category’s expressions are displayed in key_value_tree
        if category_name in data:
            display_key_value_pairs(data[category_name], key_value_tree)

            # Delay selecting the first expression to allow UI update
            root.after(100, highlight_first_expression)


def highlight_first_expression():
    """ 
    Highlights the first available regular expression in key_value_tree. 
    Used when switching categories.
    """
    
    key_items = key_value_tree.get_children()
    if key_items:
        first_key = key_items[0]
        key_value_tree.selection_set(first_key)
        key_value_tree.focus(first_key)
        key_value_tree.see(first_key)
        key_value_tree.event_generate("<<TreeviewSelect>>")  # Simulate user selection


def update_sample_expression(category_data):
    """ 
    Updates the Sample Expression without highlighting and applies highlighting only 
    to the sample results. 
    """
    
    selected_item = key_value_tree.focus()
    if not selected_item:
        return
    
    regex_key = key_value_tree.item(selected_item, "values")[0]

    if regex_key in category_data:
        sample_expression = category_data[regex_key].get("sample_expression", "")
        sample_result = category_data[regex_key].get("sample_result", "")

        # Clear previous text
        sample_expression_widget.config(state="normal")
        sample_expression_widget.delete("1.0", tk.END)
        sample_results_widget.config(state="normal")
        sample_results_widget.delete("1.0", tk.END)

        # Remove brackets from Sample Expression but do NOT apply highlighting
        clean_text, _ = extract_highlight_ranges(sample_expression)  # Extract text only, discard highlight info
        sample_expression_widget.insert("1.0", clean_text)

        # Process sample results with highlighting
        clean_result, highlight_ranges = extract_highlight_ranges(sample_result)
        sample_results_widget.insert("1.0", clean_result)
        apply_highlighting(sample_results_widget, highlight_ranges)

        # Disable editing
        sample_expression_widget.config(state="disabled")
        sample_results_widget.config(state="disabled")


def extract_highlight_ranges(text):
    """
    Extracts clean text without brackets and calculates highlight ranges 
    as Tkinter Text widget indices (line.column).
    Supports multi-line highlighting.
    """
    
    clean_text_lines = []
    highlight_ranges = []
    current_line = ""
    highlight_start_index = None

    line_num = 1
    col_num = 0

    for char in text:
        if char == "[":
            #inside_brackets = True
            highlight_start_index = f"{line_num}.{col_num}"
        elif char == "]":
            #inside_brackets = False
            highlight_end_index = f"{line_num}.{col_num}"
            if highlight_start_index:
                highlight_ranges.append((highlight_start_index, highlight_end_index))
                highlight_start_index = None
        elif char == "\n":
            current_line += "\n"
            clean_text_lines.append(current_line)
            current_line = ""
            line_num += 1
            col_num = 0
        else:
            current_line += char

    if current_line:
        clean_text_lines.append(current_line)

    clean_text = "".join(clean_text_lines)
    return clean_text, highlight_ranges


def apply_highlighting(widget, highlight_ranges):
    """ Highlights text in sample_results_widget based on extracted highlight ranges. """
    
    widget.tag_configure("highlight", background="yellow", foreground="black", font=("Arial", 10, "bold"))

    for start, end in highlight_ranges:
        # widget.tag_add("highlight", f"1.{start}", f"1.{end}")
        # Handles Tkinter-compliant full text indices
        widget.tag_add("highlight", start, end)

        
# /Treeview Functions ---------------------------------------------------------


# Treeview Styling Functions -----------------------------------------------


def apply_row_styles(tree):
    """
    Applies alternating row colors to the given Treeview widget.
    """
    # Configure the tag backgrounds once (not inside the loop)
    tree.tag_configure("evenrow", background="white")
    tree.tag_configure("oddrow", background="#f2f2f2")

    # Assign tags to each row for alternating colors
    for index, child in enumerate(tree.get_children()):
        tag = "evenrow" if index % 2 == 0 else "oddrow"
        tree.item(child, tags=(tag,))


def configure_hover_effect(tree):
    """Configures the hover effect for the Treeview rows."""
    
    def on_mouse_over(event):
        item_id = tree.identify_row(event.y)

        for child in tree.get_children():
            tree.tag_configure("hover", background="#d9d9d9")
            apply_row_styles(tree)

        if item_id:
            tree.item(item_id, tags=("hover",))

    def on_mouse_leave(event):
        apply_row_styles(tree)

    tree.bind("<Motion>", on_mouse_over)
    tree.bind("<Leave>", on_mouse_leave)


def configure_treeview_style():
    """Configures the Treeview widget style."""
    
    style = ttk.Style()
    # Explicitly set a theme for interface:
    # style.theme_use('default')  # or 'clam'
    style.configure("Custom.Treeview", rowheight=25)
    style.map(
        "Custom.Treeview",
        background=[("selected", "#cce5ff")],
        foreground=[("selected", "black")],
    )


def on_double_click(event):
    """Handles the double-click event on a Treeview row."""
    
    item_id = event.widget.focus()
    item = event.widget.item(item_id)
    item_text = item["text"]  # Get the text from the first column ("Item")

    if item_text:
        regex_input.delete(0, tk.END)  # Clear the current text
        regex_input.insert(0, item_text)  # Insert the "Item" text


# /Treeview Styling Functions -----------------------------------------------


# Regular Expression Generator ----------------------------------------------


def auto_generate_sample():
    """
    Automatically generate a sample if the sample input box is empty.

    - Reads the regex pattern from the regex_input text widget.
    - Checks the sample_input text widget.
    - If sample_input is empty and a regex is provided, generates one or more
        sample strings using `generate_samples_from_regex`.
    - Inserts the generated sample(s) into the sample_input widget.
    """
    pattern = normalize_regex(regex_input.get("1.0", "end-1c").strip())    
    # pattern = regex_input.get("1.0", "end-1c").strip()
    sample = sample_expression_widget.get("1.0", "end-1c").strip()

    if not sample and pattern:
        generated = generate_sample_from_regex(pattern)

        sample_expression_widget.config(state="normal")  # enable editing
        sample_expression_widget.delete("1.0", "end")
        sample_expression_widget.insert("1.0", generated)
        sample_expression_widget.config(state="disabled")  # lock it again


def generate_sample_from_regex(pattern: str, max_attempts=5) -> str:
    """
    Generate example matching text for the given regex pattern.
    If generation fails, returns an empty string.

    Args:
        pattern (str): The regex pattern to generate a sample from.
        max_attempts (int): Number of attempts to try generating a valid sample.

    Returns:
        str: A string matching the regex pattern.
             Returns "[Invalid regex]" if the pattern is invalid.
             Returns "[Unable to generate sample]" if no valid string could be generated.
    """

    # Quick validation of pattern
    try:
        re.compile(pattern)
    except re.error:
        return "Invalid Regular Expression"

    # Try to generate a match
    for _ in range(max_attempts):
        try:
            sample = rstr.xeger(pattern)
            if sample:  # Ensure it's not empty
                return sample
        except Exception:
            pass

    return "Unable to generate sample"


'''def normalize_regex(pattern: str) -> str:
    """
    Convert common POSIX BRE escapes into Python/PCRE-style regex.
    Supports single/range quantifiers, operators, grouping, anchors, and dots.

    Examples:
        [0-9]\{5\}        -> [0-9]{5}
        [A-Z]\{2,5\}      -> [A-Z]{2,5}
        [a-z]\{2,\}       -> [a-z]{2,}
        A\+               -> A+
        foo\?             -> foo?
        x\|y              -> x|y
        \(abc\)           -> (abc)
        \^hello world\$   -> ^hello world$
        file\.txt         -> file.txt
    """
    # Convert \{n\}, \{n,m\}, \{n,\}
    pattern = re.sub(
        r'\\\{(\d+)(?:,(\d*)?)?\\\}',
        lambda m: (
            f'{{{m.group(1)}}}' if not m.group(2)
            else f'{{{m.group(1)},{m.group(2)}}}' if m.group(2) != ''
            else f'{{{m.group(1)},}}'
        ),
        pattern
    )

    # Convert escaped BRE quantifiers/operators
    pattern = pattern.replace(r'\+', '+')
    pattern = pattern.replace(r'\?', '?')
    pattern = pattern.replace(r'\|', '|')

    # Convert escaped grouping parentheses
    pattern = pattern.replace(r'\(', '(')
    pattern = pattern.replace(r'\)', ')')

    # Convert escaped anchors
    pattern = pattern.replace(r'\^', '^')
    pattern = pattern.replace(r'\$', '$')

    # Convert escaped literal dot
    pattern = pattern.replace(r'\.', '.')

    return pattern'''



'''def normalize_regex(pattern: str) -> str:
    """
    Convert common POSIX BRE escapes into Python/PCRE-style regex.
    Supports both single and range quantifiers.
    
    Examples:
        [0-9]\{5\}        -> [0-9]{5}
        [0-9]\{5,9\}      -> [0-9]{5,9}
        [A-Z]\{2,5\}      -> [A-Z]{2,5}
        A\+               -> A+
        foo\?             -> foo?
        x\|y              -> x|y
        \(abc\)           -> (abc)
    """
    # Convert \{n\}, \{n,m\}, \{n,\}
    pattern = re.sub(r'\\\{(\d+)(?:,(\d*)?)?\\\}',
                     lambda m: (
                         f'{{{m.group(1)}}}' if not m.group(2)
                         else f'{{{m.group(1)},{m.group(2)}}}' if m.group(2) != ''
                         else f'{{{m.group(1)},}}'
                     ),
                     pattern)

    # Convert escaped BRE quantifiers/operators
    pattern = pattern.replace(r'\+', '+')
    pattern = pattern.replace(r'\?', '?')
    pattern = pattern.replace(r'\|', '|')

    # Convert escaped grouping parentheses
    pattern = pattern.replace(r'\(', '(')
    pattern = pattern.replace(r'\)', ')')

    return pattern'''



def normalize_regex(pattern: str) -> str:
    """
    Convert common POSIX BRE escapes into Python/PCRE-style regex.
    Examples:
        [0-9]\{5\}      -> [0-9]{5}
        [0-9]\{5,9\}    -> [0-9]{5,9}
        A\+             -> A+
        foo\?           -> foo?
        x\|y            -> x|y
        \(abc\)         -> (abc)
    """

    # Convert \{n\} or \{n,m\} into {n} or {n,m}
    pattern = re.sub(r'\\\{(\d+(?:,\d+)?)\\\}', r'{\1}', pattern)

    # Convert escaped BRE quantifiers/operators
    pattern = pattern.replace(r'\+', '+')
    pattern = pattern.replace(r'\?', '?')
    pattern = pattern.replace(r'\|', '|')

    # Convert escaped grouping parentheses
    pattern = pattern.replace(r'\(', '(')
    pattern = pattern.replace(r'\)', ')')

    return pattern


# /Regular Expression Generator ---------------------------------------------


# Regular Expression Parser (Explanations) ------------------------------------


# Used to explain regex patterns in plain English in the explain_regex Function
# Displayed in the regex_info_field
CATEGORY_MAP = {
    "category_digit": "a digit (0-9)",
    "category_not_digit": "a non-digit character",
    "category_space": "a whitespace character (space, tab, or newline)",
    "category_not_space": "a non-whitespace character",
    "category_word": "a word character (letter, digit, or underscore)",
    "category_not_word": "a non-word character",
}


'''def explain_regex(pattern):
    # show context of error position.
    try:
        parsed = sre_parse.parse(pattern)
    except re.error as e:
        # Try to extract position info
        msg = str(e)
        if e.pos is not None:  # re.error sometimes has .pos
            pos = e.pos
            caret_line = " " * pos + "^"
            snippet = f"{pattern}\n{caret_line}"
            return f"Invalid regex: {msg}\n{snippet}"
        return f"Invalid regex: {msg}"'''


def explain_regex(pattern: str) -> str:
    try:
        parsed = sre_parse.parse(pattern)
    except re.error as e:
        return format_regex_error(pattern, e)

    def _explain(parsed_pattern):
        if isinstance(parsed_pattern, SubPattern):
            parsed_pattern = list(parsed_pattern)   # type: ignore

        parts = []
        for t_type, t_value in parsed_pattern:
            t_name = str(t_type)

            if t_name == "LITERAL":
                parts.append(f"the character '{chr(t_value)}'")

            elif t_name == "ANY":
                parts.append("any character")

            elif t_name == "IN":  # Character set
                chars = []
                for st_type, st_value in t_value:
                    st_name = str(st_type)
                    if st_name == "LITERAL":
                        chars.append(chr(st_value))
                    elif st_name == "RANGE":
                        start, end = st_value
                        chars.append(f"{chr(start)}-{chr(end)}")
                    elif st_name == "CATEGORY":
                        st_str = str(st_value).lower()
                        chars.append(CATEGORY_MAP.get(st_str, st_str))

                # Make output cleaner for single-element sets
                if len(chars) == 1:
                    parts.append(chars[0])
                else:
                    parts.append(f"one of [{', '.join(chars)}]")

            elif t_name == "MAX_REPEAT":
                min_rep, max_rep, subpattern = t_value
                rep_desc = _explain(subpattern)

                if min_rep == 0 and max_rep == sre_parse.MAXREPEAT:
                    parts.append(f"{rep_desc} zero or more times")
                elif min_rep == 1 and max_rep == sre_parse.MAXREPEAT:
                    parts.append(f"{rep_desc} one or more times")
                elif min_rep == 0 and max_rep == 1:
                    parts.append(f"{rep_desc} zero or one time")
                elif min_rep == max_rep:
                    parts.append(f"{rep_desc} exactly {min_rep} times")
                else:
                    parts.append(f"{rep_desc} {min_rep} to {max_rep} times")

            elif t_name == "SUBPATTERN":
                _, _, _, subpattern = t_value
                parts.append(f"( { _explain(subpattern) } )")

            elif t_name == "BRANCH":  # Alternation (|)
                _, branches = t_value
                branch_desc = ["( " + _explain(branch) + " )" for branch in branches]
                parts.append(" or ".join(branch_desc))

            elif t_name == "CATEGORY":
                t_str = str(t_value).lower()
                parts.append(CATEGORY_MAP.get(t_str, t_str))

            elif t_name == "AT":
                if str(t_value) == "AT_BEGINNING":
                    parts.append("the start of the string")
                elif str(t_value) == "AT_END":
                    parts.append("the end of the string")

            else:
                if isinstance(t_value, SubPattern):
                    parts.append(_explain(t_value))
                else:
                    parts.append(f"{t_name} {t_value}")

        return ", ".join(parts)

    # Return the full explanation
    return "Matches " + _explain(parsed)


def format_regex_error(pattern: str, error: re.error) -> str:
    """
    Format a regex error with context, highlighting, and a possible hint.
    """
    msg = str(error)
    pos = getattr(error, "pos", None)

    output = [f"Invalid regex: {msg}"]

    # Highlight offending location if possible
    if pos is not None and 0 <= pos < len(pattern):
        caret_line = " " * pos + "^"
        output.append("\nHere:\n" + pattern + "\n" + caret_line)

        bad_char = pattern[pos]
        bracketed = pattern[:pos] + "[" + bad_char + "]" + pattern[pos + 1:]
        output.append("\nHighlighted:\n" + bracketed)

    elif pos is not None:
        caret_line = " " * len(pattern) + "^"
        output.append("\nHere:\n" + pattern + "\n" + caret_line)

    # Add a "hint" if this looks like a common error
    hint = None
    lowered = msg.lower()

    if "bad character range" in lowered:
        hint = (
            "Hint: You probably put '-' in the middle of a character class.\n"
            "Try escaping it as '\\-' or moving it to the start/end of the class.\n"
            "Example: [\\w\\-] or [-\\w]"
        )
    elif "missing )" in lowered:
        hint = "Hint: You may have unbalanced parentheses."
    elif "unterminated character set" in lowered:
        hint = "Hint: You may have forgotten a closing ']' in a character class."
    elif "bad group name" in lowered:
        hint = "Hint: Group names must be valid Python identifiers."
    elif "unexpected end of pattern" in lowered:
        hint = "Hint: Your regex ends abruptly — did you forget a closing ')' or ']'?"

    if hint:
        output.append("\n" + hint)

    return "\n".join(output)


'''def format_regex_error(pattern: str, error: re.error) -> str:
    """
    Format a regex error with context and highlighting.

    - Shows the error message
    - Highlights the offending character with ^ or brackets
    """
    msg = str(error)
    pos = getattr(error, "pos", None)  # position of error, if available

    # Base error message
    output = [f"Invalid regex: {msg}"]

    if pos is not None and 0 <= pos < len(pattern):
        # caret-style pointer
        caret_line = " " * pos + "^"
        output.append("\nHere:\n" + pattern + "\n" + caret_line)

        # optional bracket-style pointer
        bad_char = pattern[pos]
        bracketed = pattern[:pos] + "[" + bad_char + "]" + pattern[pos + 1:]
        output.append("\nHighlighted:\n" + bracketed)

    elif pos is not None:
        # pos may point *just past* the end of pattern
        caret_line = " " * len(pattern) + "^"
        output.append("\nHere:\n" + pattern + "\n" + caret_line)

    return "\n".join(output)'''


'''def explain_regex(pattern):
    try:
        parsed = sre_parse.parse(pattern)
    except re.error as e:
        return f"Invalid regex: {e}"

    def _explain(parsed_pattern):
        if isinstance(parsed_pattern, SubPattern):
            parsed_pattern = list(parsed_pattern)   # type: ignore

        parts = []
        for t_type, t_value in parsed_pattern:
            t_name = str(t_type)

            if t_name == "LITERAL":
                parts.append(f"the character '{chr(t_value)}'")

            elif t_name == "ANY":
                parts.append("any character")

            elif t_name == "IN":  # Character set
                chars = []
                for st_type, st_value in t_value:
                    st_name = str(st_type)
                    if st_name == "LITERAL":
                        chars.append(chr(st_value))
                    elif st_name == "RANGE":
                        start, end = st_value
                        chars.append(f"{chr(start)}-{chr(end)}")
                    elif st_name == "CATEGORY":
                        st_str = str(st_value).lower()
                        chars.append(CATEGORY_MAP.get(st_str, st_str))

                # Make output cleaner for single-element sets
                if len(chars) == 1:
                    parts.append(chars[0])
                else:
                    parts.append(f"one of [{', '.join(chars)}]")

            elif t_name == "MAX_REPEAT":
                min_rep, max_rep, subpattern = t_value
                rep_desc = _explain(subpattern)

                if min_rep == 0 and max_rep == sre_parse.MAXREPEAT:
                    parts.append(f"{rep_desc} zero or more times")
                elif min_rep == 1 and max_rep == sre_parse.MAXREPEAT:
                    parts.append(f"{rep_desc} one or more times")
                elif min_rep == 0 and max_rep == 1:
                    parts.append(f"{rep_desc} zero or one time")
                elif min_rep == max_rep:
                    parts.append(f"{rep_desc} exactly {min_rep} times")
                else:
                    parts.append(f"{rep_desc} {min_rep} to {max_rep} times")

            elif t_name == "SUBPATTERN":
                _, _, _, subpattern = t_value
                parts.append(f"( { _explain(subpattern) } )")

            elif t_name == "BRANCH":  # Alternation (|)
                _, branches = t_value
                branch_desc = ["( " + _explain(branch) + " )" for branch in branches]
                parts.append(" or ".join(branch_desc))

            elif t_name == "CATEGORY":
                t_str = str(t_value).lower()
                parts.append(CATEGORY_MAP.get(t_str, t_str))

            elif t_name == "AT":
                if str(t_value) == "AT_BEGINNING":
                    parts.append("the start of the string")
                elif str(t_value) == "AT_END":
                    parts.append("the end of the string")

            else:
                if isinstance(t_value, SubPattern):
                    parts.append(_explain(t_value))
                else:
                    parts.append(f"{t_name} {t_value}")

        return ", ".join(parts)

    return "Matches " + _explain(parsed)'''


def safe_parse_regex(pattern: str):
    """
    Try to parse/compile a regex. 
    Returns parsed object if valid, or a friendly error string if invalid.
    """

    try:
        parsed = re.compile(pattern)
        return parsed
    except re.error as e:
        return format_regex_error(pattern, e)


def update_regex_info(event=None):
    if not active_regex_explanations.get():
        return

    pattern = regex_input.get("1.0", "end-1c")
    regex_info_field.config(state="normal")
    regex_info_field.delete("1.0", "end")

    try:
        re.compile(pattern)
        explanation = explain_regex(pattern)
        regex_info_field.insert("1.0", explanation)
    except re.error as e:
        error_msg = format_regex_error(pattern, e)
        regex_info_field.insert("1.0", error_msg)

    regex_info_field.config(state="disabled")


'''def update_regex_info(event=None):
    if not active_regex_explanations.get():
        return

    pattern = regex_input.get("1.0", "end-1c")
    regex_info_field.config(state="normal")
    regex_info_field.delete("1.0", "end")

    try:
        re.compile(pattern)
        explanation = explain_regex(pattern)
        regex_info_field.insert("1.0", explanation)
    except re.error as e:
        error_msg = format_regex_error(pattern, e)
        regex_info_field.insert("1.0", error_msg)

    regex_info_field.config(state="disabled")'''


'''def update_regex_info(event=None):
    """Update the regex_info_field in real time based on the regex_input widget."""
    if not active_regex_explanations.get():
        return

    pattern = regex_input.get("1.0", "end-1c")
    regex_info_field.config(state="normal")     # make editable temporarily
    regex_info_field.delete("1.0", "end")       # clear old content

    try:
        re.compile(pattern)  # validate only
        explanation = explain_regex(pattern)    # safe, since it compiled
        regex_info_field.insert("1.0", explanation)
    except re.error as e:
        error_msg = format_regex_error(pattern, e)
        regex_info_field.insert("1.0", error_msg)

    regex_info_field.config(state="disabled")   # make read-only again'''


'''def update_regex_info(event=None):
    """
    Makes the explain_regex function update the regex_info variable in the create_regex_input function 
    so that the regex_info_field updates as a user types text into the regex_input text widget

    As a result, the regex_info_field displays a plain English explanation of the current regex.
    This function is called when the regex_input text changes.
    """

    global regex_input

    regex_text = regex_input.get("1.0", "end-1c")
    explanation = explain_regex(regex_text)
    regex_info_field.config(state="normal")
    regex_info_field.delete("1.0", "end")
    regex_info_field.insert("1.0", explanation)
    regex_info_field.config(state="disabled")'''


def update_regex_info_visibility():
    global regex_info_frame, regex_info_field

    if active_regex_explanations.get():
        regex_info_frame.grid(row=2, column=0, columnspan=2, sticky="we")
        regex_info_field.config(state="normal")
        regex_info_field.delete("1.0", "end")
        regex_info_field.insert("1.0", explain_regex(regex_input.get("1.0", "end-1c")))
        regex_info_field.config(state="disabled")
    else:
        regex_info_frame.grid_remove()


# /Regular Expression Parser (Explanations) ------------------------------------


# Add this global variable near other globals (e.g., after treeview_visible):
last_treeview_data_id = None

if __name__ == "__main__":
    # Run the application
    create_window()




