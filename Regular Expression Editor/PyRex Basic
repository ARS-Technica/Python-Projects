# Moving Nested Dictionary containing Regular Expressions to a json
# Adding Delete Category Button to Saved Expressions
# Returning focus not just to Category Treeview, but also to KeyValue after deletion.


# Next Issue: If a Regex is selected for deletion, the category is automatically selected.
# Next Issue: Use REGEX_FILE_PATH and SAVED_FILE_PATH for JSON paths

import tkinter as tk
from tkinter import ttk
import re

import tkinter.filedialog as filedialog # To export search results as an .rtf
from tkinter import simpledialog
from tkinter import messagebox

import json # For loading regular_expressions.json and saved_expressions.json
import winsound # For Save/Delete Regex Confirmations

# Table of Contents:
    # User Interface
    # Matching Functions
    # Treeview Functions
    # Functions for Styling Widgets


# Load External Data-----------------------------------------------------------


# Constants for file paths
REGEX_FILE_PATH = "C:/Python/Python38-32/Programs/Tkinter/Regular Expression Editor/regular_expressions.json"
SAVED_FILE_PATH = "C:/Python/Python38-32/Programs/Tkinter/Regular Expression Editor/saved_expressions.json"


# Default data in case JSON files are missing or invalid
DEFAULT_REGULAR_EXPRESSIONS = {
    # Add minimal default data here to keep the program functional
}

DEFAULT_SAVED_EXPRESSIONS = {
    # Add minimal default data here to keep the program functional
}


# Load Regular Expressions
def load_regular_expressions():
    try:
        with open(REGEX_FILE_PATH, "r") as file:                  
            return json.load(file)
    except FileNotFoundError:
        print(f"File not found AT {REGEX_FILE_PATH}. Loading default regular expressions.")
        print("Error: 'regular_expressions.json' not found. Loading default data.")
        return DEFAULT_REGULAR_EXPRESSIONS
    except json.JSONDecodeError:
        print(f"Invalid JSON format in file: {REGEX_FILE_PATH}. Loading default regular expressions.")
        return DEFAULT_REGULAR_EXPRESSIONS

# Load Saved Expressions
def load_saved_expressions():
    try:
        with open(SAVED_FILE_PATH, "r") as file:
            return json.load(file)
    except FileNotFoundError:
        print(f"File not found AT {SAVED_FILE_PATH}. Loading default regular expressions.")
        print("Error: 'saved_expressions.json' not found. Loading default data.")
        return DEFAULT_SAVED_EXPRESSIONS
    except json.JSONDecodeError:
        print(f"Invalid JSON format in file: {SAVED_FILE_PATH}. Loading default regular expressions.")
        return DEFAULT_SAVED_EXPRESSIONS


# Load the data
regular_expressions = load_regular_expressions()
saved_expressions = load_saved_expressions()


# Global variable to track toggle state
treeview_visible = False
current_data = regular_expressions  # Default to "Regular Expressions" for Treeview widget


#/Load External Data-----------------------------------------------------------



# User Interface --------------------------------------------------------------

def create_window():
    """Creates the main window for the application with dynamic initial height."""
    global root, treeview_frame

    root = tk.Tk()
    root.title("PyRex Regular Expression Editor")
    root.geometry("900x1")  # Temporary small height to calculate actual needed height

    # Create menu, toolbar, and main widgets
    create_menu(root)
    create_toolbar(root)
    create_widgets(root)

    # Update the window to compute widget sizes
    root.update_idletasks()

    # Dynamically adjust the initial window size based on the widgets' required size
    initial_height = root.winfo_reqheight()  # Required height after widgets are placed
    root.geometry(f"900x{initial_height}")  # Set the correct initial height

    # Start the main event loop
    root.mainloop()


def create_menu(window):
    """Creates the main menu."""
    menu_bar = tk.Menu(window)

    # File menu
    file_menu = tk.Menu(menu_bar, tearoff=0)
    #file_menu.add_command(label="Export to File", command=export_results)
    file_menu.add_command(label="Save Expression", command=open_save_expression_popup)
    file_menu.add_command(label="Delete Expression", command=delete_expression)
    file_menu.add_separator()
    file_menu.add_command(label="Exit", command=window.destroy)

    # Search menu
    search_menu = tk.Menu(menu_bar, tearoff=0)

    # Toggle between Match Results being returned as Instances or Sentences
    global match_mode_var
    # Create variable for Match Results checkbutton
    # Global variable to track the match mode
    match_mode_var = tk.IntVar(value=0)  # 0 = "Instance", 1 = "Sentence"

    # Add mutually exclusive checkbuttons with toggle logic
    search_menu.add_checkbutton(
        label="Match Instances",
        variable=match_mode_var,
        onvalue=0,
        offvalue=1,
        command=lambda: toggle_search_mode(0)
    )
    search_menu.add_checkbutton(
        label="Match Sentences",
        variable=match_mode_var,
        onvalue=1,
        offvalue=0,
        command=lambda: toggle_search_mode(1)
    )

    # View menu
    view_menu = tk.Menu(menu_bar, tearoff=0)

    # Toggle between the Treeview Panel with one of two datasets
    view_menu.add_command(
        label="Regular Expression Cheatsheet",
        command=lambda: toggle_treeview_with_data(current_data)
    )
    view_menu.add_command(
        label="Saved Expressions",
        command=lambda: toggle_treeview_with_data(saved_expressions)
    )   

    # Add menus to the menu bar
    menu_bar.add_cascade(label="File", menu=file_menu)
    menu_bar.add_cascade(label="Search", menu=search_menu)
    menu_bar.add_cascade(label="View", menu=view_menu)

    window.config(menu=menu_bar)


def create_widgets(window):
    """Creates the main UI components by delegating to helper functions."""
    global main_frame, treeview_frame

    # Configures the grid layout of the main window.
    #configure_window_grid(window)
    window.columnconfigure(0, weight=1)  	# Single column
    window.rowconfigure(1, weight=1)    	# Main frame (static widgets)
    window.rowconfigure(2, weight=0)    	# Treeview frame (toggling widget)

    # Create Toolbar
    create_toolbar(window)

    # Main Frame (Fixed Widgets)
    main_frame = create_main_frame(window)

    # Add Widgets to Main Frame
    create_regex_input(main_frame)    
    create_test_string_field(main_frame)
    create_match_results_field(main_frame)
    create_buttons(main_frame)

    # Create Collapsible Treeview Panel
    treeview_frame = create_treeview_panel(window)


def create_toolbar(window):
    """Creates a toolbar at the top of the window (for Treeview toggle buttons)"""
    toolbar = ttk.Frame(window, padding="5")
    toolbar.grid(row=0, column=0, sticky="ew")

    # Button to toggle RegEx CheatSheet
    ttk.Button(
        toolbar,
        text="RegEx CheatSheet",
        command=lambda: toggle_treeview_with_data(current_data)
    ).pack(side="left", padx=5)

    # Button to toggle Saved Expressions
    ttk.Button(
        toolbar,
        text="Saved Expressions",
        command=lambda: toggle_treeview_with_data(saved_expressions)
    ).pack(side="left", padx=5)


def create_main_frame(window):
    """Creates the main frame and configures its layout."""
    main_frame = ttk.Frame(window, padding="5")  # Add padding to the main frame
    main_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=10, pady=0)  # Add padding to the grid

    # Configure main_frame grid
    main_frame.columnconfigure(0, weight=1)
    main_frame.columnconfigure(1, weight=1)
    main_frame.rowconfigure(0, weight=0)  # Regular Expression label (fixed)
    main_frame.rowconfigure(1, weight=0)  # Regular Expression input (fixed)
    main_frame.rowconfigure(2, weight=0)  # Test String/Match Results labels (fixed)
    main_frame.rowconfigure(3, weight=0)  # Test String/Match Results widgets (expandable)
    main_frame.rowconfigure(4, weight=0)  # Buttons row (fixed)

    return main_frame


def create_regex_input(parent):
    """Adds a regular expression input field to the given parent frame."""
    global regex_input

    ttk.Label(parent, text="Regular Expression:").grid(row=0, column=0, columnspan=2, sticky=tk.W, pady=(5, 2))
    regex_input = tk.Text(parent, height=3, wrap="word")
    regex_input.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(2, 5))
    
    # regex_input.insert("end", "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}") # Find Email Addresses
    # regex_input.insert("end", "https?://[^\s]+") # Find URLs
    # regex_input.insert("end", "[A|B][a-z]+")  # Find Words Starting with 'A' or 'B'
    regex_input.insert("end", "[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}")  # Find Domains


def create_test_string_field(parent):
    """Adds test string text field to the left column of the given parent frame."""
    global test_string_input

    # Test String
    ttk.Label(parent, text="Test String:").grid(row=2, column=0, sticky=tk.W, pady=(5, 2))
    test_string_input = tk.Text(parent, height=10, wrap="word")
    test_string_input.grid(row=3, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 5))

    test_string_input.insert("end",     
    """Alice's email is alice@example.com, and Bob's email is bob@example.org. Contact us at support@company.com or visit our website: https://www.example.com."""
    )


def create_match_results_field(parent):
    """Adds match results text field to the right column of the given parent frame."""
    global match_result

    # Match Results
    ttk.Label(parent, text="Match Results:").grid(row=2, column=1, sticky=tk.W, pady=(5, 2))
    match_result = tk.Text(parent, height=10, wrap="word", state="disabled")
    match_result.grid(row=3, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(5, 0))


def create_buttons(parent):
    """Adds buttons to the given parent frame."""
    button_frame = ttk.Frame(parent)
    button_frame.grid(row=4, column=0, columnspan=2, sticky=tk.EW)
    button_frame.columnconfigure(0, weight=1)
    button_frame.columnconfigure(1, weight=1)

    ttk.Button(button_frame, text="Clear Fields", command=clear_fields).grid(row=0, column=0, pady=5, sticky=tk.W)
    ttk.Button(button_frame, text="Match", command=perform_match).grid(row=0, column=1, pady=5, sticky=tk.E)


def create_treeview_panel(window):
    """Creates the collapsible Treeview Panel with sample text and result fields spanning the entire window width."""
    global treeview_frame, sample_text_widget, sample_results_widget

    treeview_frame = ttk.Frame(window, padding="5")
    treeview_frame.grid(row=2, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=10, pady=0)
    treeview_frame.columnconfigure(0, weight=1)  # Spanning the entire width

    # Create Treeview Widgets
    create_treeview_section(treeview_frame, 0)

    # Sample Text Row (Label and Entry on the same line)
    sample_text_label = ttk.Label(treeview_frame, text="Sample Text:")
    sample_text_label.grid(row=1, column=0, sticky=tk.W, pady=(5, 2))  # Left-aligned label
    sample_text_widget = tk.Entry(treeview_frame)
    sample_text_widget.grid(
        row=1, column=0, sticky=(tk.W, tk.E), padx=(100, 5), pady=(5, 2), columnspan=3
    )  # Add padding to separate widget from label

    # Sample Results Row (Label and Entry on the same line)
    sample_results_label = ttk.Label(treeview_frame, text="RegEx Result:")
    sample_results_label.grid(row=2, column=0, sticky=tk.W, pady=(5, 5))  # Left-aligned label
    sample_results_widget = tk.Entry(treeview_frame)
    sample_results_widget.grid(
        row=2, column=0, sticky=(tk.W, tk.E), padx=(100, 5), pady=(5, 5), columnspan=3
    )  # Add padding to separate widget from label

    # Adjust row weights
    treeview_frame.rowconfigure(0, weight=1)  # Treeview row expandable
    treeview_frame.rowconfigure(1, weight=0)  # Fixed height for Sample Text row
    treeview_frame.rowconfigure(2, weight=0)  # Fixed height for Sample Results row

    treeview_frame.grid_remove()  # Start hidden
    return treeview_frame


# /User Interface -------------------------------------------------------------


# Save RegEx Pop-Up Interface ------------------------------------------------


def open_save_expression_popup():
    """
    Opens a popup window for saving a regular expression.
    """
    popup = tk.Toplevel(root)
    popup.title("Save Regular Expression")
    popup.geometry("500x275")
    popup.resizable(False, False)  # Prevent resizing
    popup.transient(root)  # Set the popup as a child of the main window

    # Frames for layout
    category_frame = ttk.Frame(popup, padding="10")
    category_frame.grid(row=0, column=0, sticky="nsew")
    regex_frame = ttk.Frame(popup, padding="10")
    regex_frame.grid(row=1, column=0, sticky="nsew")
    description_frame = ttk.Frame(popup, padding="10")
    description_frame.grid(row=2, column=0, sticky="nsew")
    button_frame = ttk.Frame(popup, padding="10")
    button_frame.grid(row=3, column=0, sticky="ew")

    # Configure column weights for proper layout
    popup.columnconfigure(0, weight=1)
    category_frame.columnconfigure(1, weight=1)
    regex_frame.columnconfigure(0, weight=1)
    description_frame.columnconfigure(0, weight=1)
    button_frame.columnconfigure(0, weight=1)
    button_frame.columnconfigure(1, weight=1)

    # Category Section
    ttk.Label(category_frame, text="Category:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    
    
    # Retrieve and sort the saved categories to show first category by default
    categories = sorted(saved_expressions.keys())
    category_combobox = ttk.Combobox(category_frame, state="readonly", width=30)
    category_combobox["values"] = categories

    # Set the default value to the first category in the sorted list
    if categories:  # Ensure there are categories available
        category_combobox.set(categories[0])  # Set the default value to the first category

    
    #category_combobox = ttk.Combobox(category_frame, values=list(saved_expressions.keys()), state="readonly", width=30)
    category_combobox.grid(row=0, column=1, sticky=tk.W, padx=(5, 0))
    add_category_button = ttk.Button(category_frame, text="Add Category", command=lambda: add_new_category(category_combobox))
    add_category_button.grid(row=0, column=2, padx=(5, 0))

    # Regular Expression Display
    ttk.Label(regex_frame, text="Regular Expression:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    regex_display = tk.Text(regex_frame, height=3, wrap="word", width=60, state="disabled")
    regex_display.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), padx=(0, 0))

    # Populate the Regular Expression field
    regex_content = regex_input.get("1.0", tk.END).strip()
    if regex_content:  # Ensure regex_input has content
        regex_display.configure(state="normal")  # Temporarily make it editable
        regex_display.insert("1.0", regex_content)  # Insert the regex
        regex_display.configure(state="disabled")  # Disable editing again

    # Description Field
    ttk.Label(description_frame, text="Description:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    description_field = tk.Text(description_frame, height=3, wrap="word", width=60)
    description_field.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), padx=(0, 0))

    # Save and Cancel Buttons
    save_button = ttk.Button(
        button_frame,
        text="Save",
        command=lambda: save_expression(category_combobox, regex_display, description_field, popup)
    )
    save_button.grid(row=0, column=0, sticky=tk.E, padx=5)

    cancel_button = ttk.Button(button_frame, text="Cancel", command=popup.destroy)
    cancel_button.grid(row=0, column=1, sticky=tk.W, padx=5)


def add_new_category(category_combobox):
    """
    Adds a new category to saved_expressions, updates the category_combobox, 
    and ensures categories are displayed alphabetically.
    """
    # Prompt the user for the new category name
    new_category = simpledialog.askstring("Add New Category", "Enter a new category name:")
    if not new_category:
        return  # User canceled or entered nothing

    # Trim whitespace and validate the input
    new_category = new_category.strip()
    if not new_category:
        messagebox.showerror("Invalid Input", "Category name cannot be empty.")
        return

    if new_category in saved_expressions:
        messagebox.showerror("Duplicate Category", f"The category '{new_category}' already exists.")
        return

    # Add the new category to saved_expressions
    saved_expressions[new_category] = {}

    # Save the updated saved_expressions to the JSON file
    try:
        with open("C:/Python/Python38-32/Programs/Tkinter/Regular Expression Editor/saved_expressions.json", "w") as file:
            json.dump(saved_expressions, file, indent=4)
    except Exception as e:
        messagebox.showerror("Error", f"Failed to save the new category: {e}")
        return

    # Update and sort the category_combobox values
    sorted_categories = sorted(saved_expressions.keys(), key=str.lower)
    category_combobox['values'] = sorted_categories
    category_combobox.set(new_category)  # Set the new category as the selected value

    # Update the category_tree if the Treeview Panel is displaying saved_expressions
    if treeview_visible and toggle_treeview_with_data._last_data_id == id(saved_expressions):
        # Insert the new category into the category_tree
        category_tree.insert("", "end", text=new_category)

        # Re-sort the category_tree alphabetically
        sort_category_tree()
                
    # Confirm category was created
    #messagebox.showinfo("Success", f"Category '{new_category}' added successfully.")
    root.bell() # Windows bell sound


def sort_category_tree():
    """
    Sorts the categories in the category_tree alphabetically.
    """
    # Get all current categories in the Treeview
    categories = [(category_tree.item(child, "text"), child) for child in category_tree.get_children()]

    # Sort categories by name
    categories.sort(key=lambda item: item[0].lower())

    # Re-insert categories in sorted order
    for index, (category_name, category_id) in enumerate(categories):
        category_tree.move(category_id, "", index)


def save_expression(category_combobox, regex_display, description_field, popup):
    """
    Saves the current regular expression and description to the selected category
    in the `saved_expressions` nested dictionary.
    """

    # Get the selected category
    category = category_combobox.get().strip()
    if not category:
        messagebox.showerror("Error", "Category cannot be empty.")
        return

    # Get the regex from regex_display
    regex = regex_display.get("1.0", tk.END).strip()
    if not regex:
        messagebox.showerror("Error", "Regular Expression cannot be empty.")
        return

    # Get the description
    description = description_field.get("1.0", tk.END).strip()
    if not description:
        messagebox.showerror("Error", "Description cannot be empty.")
        return

    # Add the expression to the saved_expressions dictionary
    is_new_category = False

    # Add new category if it doesn't exist
    if category not in saved_expressions:
        saved_expressions[category] = {}
        is_new_category = True

    # Add or overwrite the regular expression in the category
    saved_expressions[category][regex] = {
        "description": description,
        "sample_text": "",
        "sample_result": ""
    }

    # Sort the category dictionary by the description field
    saved_expressions[category] = dict(
        sorted(
            saved_expressions[category].items(),
            key=lambda item: item[1]["description"].lower()
        )
    )

    # Write changes back to the JSON file
    try:
        with open("C:/Python/Python38-32/Programs/Tkinter/Regular Expression Editor/saved_expressions.json", "w") as file:
            json.dump(saved_expressions, file, indent=4)
    except Exception as e:
        print(f"Error saving to file: {e}")

    # Notify the user
    messagebox.showinfo("Success", f"Expression saved to category '{category}'.")

    # Highlight the saved expression and category if Treeview Panel is open
    if treeview_visible and toggle_treeview_with_data._last_data_id == id(saved_expressions):
        if is_new_category:
            # Refresh the entire Treeview for new category
            populate_treeview(saved_expressions)
        else:
            # Update only the right-side Treeview for the current category
            if category in saved_expressions:
                display_key_value_pairs(saved_expressions[category], key_value_tree)

        # Highlight the category in category_tree
        for child in category_tree.get_children():
            item_text = category_tree.item(child, "text")
            if item_text == category:  # Match the saved category
                category_tree.selection_set(child)  # Highlight the saved category
                category_tree.focus(child)  # Set focus to the saved category
                category_tree.see(child)  # Scroll to the saved category
                break

        # Refresh the key_value_tree for this category
        display_key_value_pairs(saved_expressions[category], key_value_tree)

        # Highlight the newly saved expression in key_value_tree
        regex_highlighted = False
        for child in key_value_tree.get_children():
            item = key_value_tree.item(child)
            if item["values"] and item["values"][0] == regex:  # Match the saved regex
                key_value_tree.selection_set(child)  # Highlight the saved expression
                key_value_tree.focus(child)  # Set focus to the saved expression
                key_value_tree.see(child)  # Scroll to the saved expression
                regex_highlighted = True
                break

        # Force highlight if not applied correctly
        if not regex_highlighted:
            key_value_tree.selection_clear()
            key_value_tree.selection_set(key_value_tree.get_children()[0])  # Highlight the first item as a fallback
            key_value_tree.focus(key_value_tree.get_children()[0])
            key_value_tree.update_idletasks()

    # Close the popup
    popup.destroy()

def delete_expression():
    """
    Deletes the regular expression highlighted in the key_value_tree treeview 
    widget from the saved_expressions JSON. If deleting an entry from the 
    treeview widget leaves zero regular expressions in a category, the user is 
    prompted if they wish to delete the category altogether.
    """
    global saved_expressions

    # Get the selected category from the category_tree
    selected_category = category_tree.selection()
    if not selected_category:
        messagebox.showerror("Error", "Please select a category first.")
        return

    category_name = category_tree.item(selected_category, "text")

    # Get the selected regular expression from the key_value_tree
    selected_item = key_value_tree.selection()
    if not selected_item:
        # No regex selected: prompt for category deletion
        confirm_category = messagebox.askyesno(
            "Confirm Deletion",
            f"Would you like to delete the entire '{category_name}' category?"
        )
        if confirm_category:
            double_confirm = messagebox.askyesno(
                "Confirm Deletion",
                f"Are you CERTAIN you want to delete the entire '{category_name}' category?\n"
                f"Deleting '{category_name}' will also delete all regular expressions in this category."
            )
            # Proceed to delete entire category
            if double_confirm:
                # Delete the category
                del saved_expressions[category_name]
                category_tree.delete(selected_category)  # Remove from category_tree
                key_value_tree.delete(*key_value_tree.get_children())  # Clear right-side Treeview

                # Save updated data to JSON
                try:
                    with open("C:/Python/Python38-32/Programs/Tkinter/Regular Expression Editor/saved_expressions.json", "w") as file:
                        json.dump(saved_expressions, file, indent=4)
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to update saved_expressions.json: {e}")
                    return

                # Refresh the category_tree
                populate_treeview(saved_expressions)
                # Confirm category was created
                #messagebox.showinfo("Success", f"The category '{category_name}' was successfully deleted.")
                root.bell() # Windows bell sound
                
                return  # Exit since the category deletion is complete
            
            # Prompt user to select a Regular Express if he doesn't want the ENTIRE catgory deleted.
            else:
                messagebox.showerror("Error", "Please select a regular expression to delete.")                   
                # Focus on the first entry in the key_value_tree
                if key_value_tree.get_children():
                    first_item = key_value_tree.get_children()[0]  # Get the first item
                    key_value_tree.selection_set(first_item)  # Highlight/select the first item
                    key_value_tree.focus(first_item)  # Set focus on the first item
                    key_value_tree.see(first_item)  # Scroll to make the item visible
                
                return
            
        # Prompt user to select a Regular Express if he doesn't want the ENTIRE catgory deleted.
        else:
            messagebox.showerror("Error", "Please select a regular expression to delete.")
            # Focus on the first entry in the key_value_tree
            if key_value_tree.get_children():
                first_item = key_value_tree.get_children()[0]  # Get the first item
                key_value_tree.selection_set(first_item)  # Highlight/select the first item
                key_value_tree.focus(first_item)  # Set focus on the first item
                key_value_tree.see(first_item)  # Scroll to make the item visible
        
            return

    # Deleting a regular expression
    regex = key_value_tree.item(selected_item, "values")[0]
    confirm = messagebox.askyesno(
        "Confirm Deletion",
        f"Are you sure you want to delete the regular expression:\n\n{regex}\n\nfrom category '{category_name}'?"
    )
    if not confirm:
        return

    # Check if the user-selected category exists in saved_expressions
    if category_name in saved_expressions:
        category_data = saved_expressions[category_name]
        if regex in category_data:
            # Delete the regular expression
            del category_data[regex]

            # If the category is now empty, prompt for category deletion
            if not category_data:
                delete_category = messagebox.askyesno(
                    "Delete Category",
                    f"The category '{category_name}' is now empty.\n\n"
                    "Do you want to delete the category heading as well?"
                )
                if delete_category:
                    del saved_expressions[category_name]
                    category_tree.delete(selected_category)  # Remove the category from the category_tree
                    key_value_tree.delete(*key_value_tree.get_children())  # Clear right-side Treeview
            else:
                # Update the key_value_tree for the updated category immediately
                display_key_value_pairs(category_data, key_value_tree)

            # Save updated data to saved_expressions JSON
            try:
                with open("C:/Python/Python38-32/Programs/Tkinter/Regular Expression Editor/saved_expressions.json", "w") as file:
                    json.dump(saved_expressions, file, indent=4)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to update saved_expressions.json: {e}")
                return

            # Refresh the category_tree to reflect updates
            populate_treeview(saved_expressions)

            # If the category still exists, ensure key_value_tree is refreshed
            if category_name in saved_expressions and saved_expressions[category_name]:
                display_key_value_pairs(saved_expressions[category_name], key_value_tree)
            # The line above prevents the key_value_tree from going blank when a regex is deleted.

            # Confirm the regular expression was deleted
            #messagebox.showinfo("Success", f"The regular expression '{regex}' was successfully deleted.")
            root.bell() # Windows bell sound
        else:
            messagebox.showerror("Error", f"Regular expression '{regex}' not found in category '{category_name}'.")
    else:
        messagebox.showerror("Error", f"Category '{category_name}' not found in saved_expressions.")


# /Save RegEx Pop-Up Interface ------------------------------------------------


# Matching Functions ----------------------------------------------------------

def perform_match(*args):
    """Determines match mode dynamically and performs the appropriate matching."""
    global match_results_as_instances

    # Prevent Regex execution on empty input
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    if not regex:
        messagebox.showwarning("Input Error", "Regular Expression field cannot be empty.")
        return

    if not test_string:
        messagebox.showwarning("Input Error", "Test String field cannot be empty.")
        return

    # Check the current match mode directly from match_mode_var
    # match_mode (0 = Instances, 1 = Sentences)
    if match_mode_var.get() == 0:
        match_instances(*args)  # Perform instance-level matching
    else:
        match_sentences(*args)  # Perform sentence-level matching


def match_instances(*args):
    """Displays instances of matching search term in Match Result Window"""
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights
    test_string_input.tag_remove("highlight", "1.0", tk.END)

    try:
        # Step 1: Find sentences containing matches
        matches = re.finditer(regex, test_string)
        result = ""

        for match in matches:
            # Step 2: Highlight matches in Test String widget
            start_idx = f"1.0 + {match.start()} chars"
            end_idx = f"1.0 + {match.end()} chars"
            # Highlight the match
            test_string_input.tag_add("highlight", start_idx, end_idx)

            # Add match details to result
            result += f"{match.group()}\n\n"  # Add a blank line after each result

        if not result:
            result = "No matches found."

        # Apply highlighting style
        test_string_input.tag_config("highlight", background="yellow", foreground="black")

        # Update the Match Results widget
        update_match_result(result)

    except re.error as e:
        # Handle regex errors
        update_match_result(f"Invalid regular expression: {str(e)}")

        
def match_sentences(*args):
    """Displays sentences containing instances of matching search term in Match Result Window"""
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights in both widgets
    test_string_input.tag_remove("highlight", "1.0", tk.END)
    match_result.tag_remove("highlight", "1.0", tk.END)

    try:
        # Step 1: Find sentences containing matches
        matches = list(re.finditer(regex, test_string))
        sentences = re.split(r'(?<=[.!?])\s+', test_string)  # Split into sentences

        result_sentences = []  # To store unique sentences with matches
        for match in matches:
            for sentence in sentences:
                if match.group() in sentence and sentence not in result_sentences:
                    result_sentences.append(sentence)
                    break

        # Step 2: Display sentences in match_result
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)

        if result_sentences:
            # Display results
            for sentence in result_sentences:
                match_result.insert(tk.END, sentence + "\n\n")  # Add a blank line after each sentence

            # Highlight matches in match_result
            match_result_text = match_result.get("1.0", tk.END)
            for match in re.finditer(regex, match_result_text):
                start_idx = f"1.0 + {match.start()} chars"
                end_idx = f"1.0 + {match.end()} chars"
                match_result.tag_add("highlight", start_idx, end_idx)

            match_result.tag_config("highlight", background="yellow", foreground="black")
        else:
            result = "No matches found."

        match_result.config(state="disabled")

    except re.error as e:
        # Handle regex errors
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)
        match_result.insert(tk.END, f"Invalid regular expression: {str(e)}")

        match_result.config(state="disabled")


def clear_fields():
    #regex_input.delete("1.0", tk.END)
    test_string_input.delete("1.0", tk.END)
    match_result.config(state="normal")
    match_result.delete("1.0", tk.END)
    match_result.config(state="disabled")


def export_results():
    # TODO: Add f-string with name of current open document to header
    # Add a dialog to get header text
    header = simpledialog.askstring(
        "Export Header", "Enter header for exported file:", initialvalue="Search Results:\n")
    if not header:
        header = "Search Results:\n"
    
    header = "\\b " + header + "\\b0"
        

    # Ensure match_result is not empty
    match_result_text = match_result.get("1.0", tk.END).strip()
    if not match_result_text:
        print("No results to export.")
        return

    # Prompt user to save the file
    file_path = filedialog.asksaveasfilename(
        defaultextension=".rtf",
        filetypes=[("Rich Text Format", "*.rtf"), ("All Files", "*.*")]
    )
    if not file_path:
        return  # User cancelled the save dialog

    try:
        # Begin writing the RTF content
        with open(file_path, "w") as file:
            # RTF header with color table for highlighting
            file.write("{\\rtf1\\ansi\\deff0\n")
            file.write("{\\colortbl;\\red255\\green255\\blue0;}\n")  # Define yellow color

            # Add header text with a blank line
            #file.write("Search results from file test.doc:\\line \\line \n")
            #file.write("\\b Search results from file test.doc:\\b0\\line \\line \n")
            file.write(header + "\\line \\line \n")

            # Retrieve text and highlighted regions
            full_text = match_result.get("1.0", tk.END)  # Get the full text
            highlight_ranges = match_result.tag_ranges("highlight")  # Get highlight ranges

            # Initialize absolute position tracker
            current_pos = 0

            for i in range(0, len(highlight_ranges), 2):
                # Get start and end indices of the highlight in absolute positions
                start = match_result.index(highlight_ranges[i])
                end = match_result.index(highlight_ranges[i + 1])

                start_line, start_char = map(int, start.split("."))
                end_line, end_char = map(int, end.split("."))

                # Calculate absolute indices in the text
                start_idx = sum(len(match_result.get(f"{line}.0", f"{line}.end")) + 1 for line in range(1, start_line)) + start_char
                end_idx = sum(len(match_result.get(f"{line}.0", f"{line}.end")) + 1 for line in range(1, end_line)) + end_char

                # Write normal text before the highlight
                if current_pos < start_idx:
                    normal_text = full_text[current_pos:start_idx]
                    file.write(normal_text.replace("\n", "\\line ") + "\n")

                # Write highlighted text
                highlighted_text = full_text[start_idx:end_idx]
                file.write("{\\highlight1 " + highlighted_text.replace("\n", "\\line ") + "}\n")

                # Update the current position
                current_pos = end_idx

            # Write any remaining text after the last highlight
            if current_pos < len(full_text):
                remaining_text = full_text[current_pos:]
                file.write(remaining_text.replace("\n", "\\line ") + "\n")

            # End the RTF content
            file.write("}")
            
        # Notify user of successful export
        print(f"Results exported to {file_path}")
        messagebox.showinfo("Export Successful", f"Results saved to {file_path}")

    except Exception as e:
        print(f"Error exporting results: {e}")
        messagebox.showerror("Export Error", f"Failed to save file: {str(e)}")


def toggle_search_mode(new_mode):
    """Toggles between match modes and re-runs the search if results are present."""
    # Update the match_mode_var to reflect the new mode
    match_mode_var.set(new_mode)

    def is_match_result_empty():
        """Checks if the match_result text widget is empty."""
        content = match_result.get("1.0", tk.END).strip()  # Get all text and remove surrounding whitespace
        return len(content) == 0  # True if empty, False otherwise

    # Check if match_result has content
    if not is_match_result_empty():
        # Re-run the search in the new mode
        perform_match()
    else:
        print(f"Search mode set to: {'Instances' if new_mode == 0 else 'Sentences'}")


def update_match_result(text):
    match_result.config(state='normal')
    match_result.delete("1.0", tk.END)
    match_result.insert(tk.END, text)
    match_result.config(state='disabled')

# /Matching Functions ---------------------------------------------------------


# Treeview Functions ---------------------------------------------------------


def create_treeview_section(parent, row):
    """
    Creates the Treeview section with two widgets: category_tree and key_value_tree.
    """

    global category_tree, key_value_tree

    # Removed code for creating "Tree" that causes Treeview to span two columns

    # Adjust column weights to control widths of the Treeview widgets
    parent.columnconfigure(0, weight=1)  # Left column: Narrower
    parent.columnconfigure(1, weight=4)  # Right column: Wider
    # These two lines of code can be set to weights of 2/2, 1/3, 1/4 or deleted altogether

    # Category Treeview (Left)
    category_tree = create_category_treeview(parent, row)
    category_tree.grid(row=row, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 5))

    # Key-Value Treeview (Right)
    key_value_tree = create_key_value_treeview(parent)
    key_value_tree.grid(row=row, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(5, 0))

    # No need to bind <<TreeviewSelect>> here; populate_treeview handles this dynamically

    # Add some space beneath the Treeview widgets
    parent.grid_rowconfigure(1, weight=1, pad=10)  # Add 10px padding
    
    return parent # If not creating a new "tree" Treeview, return parent


def create_category_treeview(parent, row):
    """Creates the Category Treeview with styles."""
    configure_treeview_style()

    tree = ttk.Treeview(parent, show="tree", selectmode="browse", style="Custom.Treeview") 
    # style="Custom.Treeview" ensures that the Treeview's alternate row styling is visible

    scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
    scrollbar.grid(row=0, column=1, sticky="ns")
    tree.configure(yscrollcommand=scrollbar.set)

    # Populate with the top-level keys of the current_data json (Previously categories)
    for category in current_data.keys():
        tree.insert("", "end", text=category)

    return tree


def create_key_value_treeview(parent):
    """Creates the Key-Value Treeview with styles and alternating row colors."""
    tree = ttk.Treeview(parent, columns=("Key", "Value"), show="headings", style="Custom.Treeview")
    # !Remember: Excluding style="Custom.Treeview" from line above removes alternating row style!    
    
    tree.heading("Key", text="Key")
    tree.heading("Value", text="Value")
    tree.column("Key", width=50, anchor="w")
    tree.column("Value", width=300, anchor="w")

    scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
    scrollbar.grid(row=0, column=2, sticky="ns")
    tree.configure(yscrollcommand=scrollbar.set)

    apply_row_styles(tree)
    configure_hover_effect(tree)

    # Bind double-click to append the key to the regex_input
    tree.bind("<Double-Button-1>", lambda event: on_key_double_click(event, tree))

    return tree



def display_key_value_pairs(category_data, key_value_tree):
    """
    Populates the key_value_tree with the key-value pairs of the selected category.
    Applies alternating row styling after populating.
    Always sorts entries by the description field.
    """
    # Clear existing data    
    key_value_tree.delete(*key_value_tree.get_children())

    # Sort the data by description before displaying it
    sorted_items = sorted(
        category_data.items(),
        key=lambda item: item[1]["description"].lower()
    )

    # Populate the Treeview with key-value pairs
    for regex, details in sorted_items:
        description = details.get("description", "")
        key_value_tree.insert("", "end", values=(regex, description))

    # Apply alternating row styles
    apply_row_styles(key_value_tree)

     
def on_key_double_click(event, tree):
    """Handles double-clicks on the Key-Value Treeview by appending the key to the regex_input field."""
    # Get the selected item
    selected_item = tree.focus()
    if not selected_item:
        return  # No item selected

    # Retrieve the key from the selected row
    selected_values = tree.item(selected_item, "values")
    if selected_values:
        key = selected_values[0]  # The key is in the first column

        # Append the key to the regex_input
        current_text = regex_input.get("1.0", tk.END).strip()  # Get current content
        new_text = current_text + key  # Append the key
        regex_input.delete("1.0", tk.END)  # Clear the current content
        regex_input.insert("1.0", new_text)  # Insert the updated content


def populate_treeview(data):
    """
    Populates the category_tree with the given data.
    Clears the key_value_tree to start fresh.
    """
    # Clear the left and right Treeview widgets
    category_tree.delete(*category_tree.get_children())
    key_value_tree.delete(*key_value_tree.get_children())

    # Alphabetize categories
    # Sort categories (top-level keys) alphabetically
    sorted_categories = sorted(data.keys(), key=str.lower)

    # Populate the left Treeview with sorted categories
    for category in sorted_categories:
        category_tree.insert("", "end", text=category)
    
    # Set up selection binding for the left Treeview
    def on_select(event):
        selected_item = category_tree.focus()
        if selected_item:
            category = category_tree.item(selected_item, "text")
            display_key_value_pairs(data.get(category, {}), key_value_tree)

    category_tree.bind("<<TreeviewSelect>>", on_select)

    # Bind selection for the right-side Treeview
    def on_key_select(event):
        selected_item = key_value_tree.focus()
        if selected_item:
            item_data = key_value_tree.item(selected_item, "values")
            if item_data:
                regex = item_data[0]
                for key, inner_data in data.items():
                    if regex in inner_data:
                        sample_text_widget.delete(0, tk.END)
                        sample_text_widget.insert(0, inner_data[regex].get("sample_text", ""))
                        sample_results_widget.delete(0, tk.END)
                        sample_results_widget.insert(0, inner_data[regex].get("sample_result", ""))
                        break

    key_value_tree.bind("<<TreeviewSelect>>", on_key_select)


def toggle_treeview_with_data(data):
    """
    Toggles the Treeview Panel on/off or repopulates it if the data changes.
    Efficiently checks if the requested data is the same as the current dataset.
    """
    if not hasattr(toggle_treeview_with_data, "_last_data_id"):
        toggle_treeview_with_data._last_data_id = None

    global treeview_visible, treeview_frame

    # Compare the id of the current dataset with the requested dataset
    if treeview_visible and toggle_treeview_with_data._last_data_id == id(data):
        # If the panel is already displaying the requested data, toggle it off
        treeview_frame.grid_remove()
        treeview_visible = False
    else:
        # Show the Treeview Panel and populate with new data
        treeview_frame.grid(row=2, column=0, sticky="nsew")
        populate_treeview(data)
        toggle_treeview_with_data._last_data_id = id(data)
        treeview_visible = True

    # Adjust window size dynamically
    root.update_idletasks()
    new_height = root.winfo_reqheight()
    root.geometry(f"{root.winfo_width()}x{new_height}")


# /Treeview Functions ---------------------------------------------------------


# Treeview Styling Functions -----------------------------------------------

def apply_row_styles(tree):
    """Applies alternating row styles to the Treeview."""
    for i, child in enumerate(tree.get_children()):
        if i % 2 == 0:
            tree.tag_configure("evenrow", background="white")
            tree.item(child, tags=("evenrow",))
        else:
            tree.tag_configure("oddrow", background="#f2f2f2")
            tree.item(child, tags=("oddrow",))


def configure_hover_effect(tree):
    """Configures the hover effect for the Treeview rows."""
    def on_mouse_over(event):
        item_id = tree.identify_row(event.y)
        for child in tree.get_children():
            tree.tag_configure("hover", background="#d9d9d9")
            apply_row_styles(tree)
        if item_id:
            tree.item(item_id, tags=("hover",))

    def on_mouse_leave(event):
        apply_row_styles(tree)

    tree.bind("<Motion>", on_mouse_over)
    tree.bind("<Leave>", on_mouse_leave)


def configure_treeview_style():
    """Configures the Treeview widget style."""
    style = ttk.Style()
    style.configure("Custom.Treeview", rowheight=25)
    style.map(
        "Custom.Treeview",
        background=[("selected", "#cce5ff")],
        foreground=[("selected", "black")],
    )


def on_double_click(event):
    """Handles the double-click event on a Treeview row."""
    item_id = event.widget.focus()
    item = event.widget.item(item_id)
    item_text = item["text"]  # Get the text from the first column ("Item")
    if item_text:
        regex_input.delete(0, tk.END)  # Clear the current text
        regex_input.insert(0, item_text)  # Insert the "Item" text

# /Treeview Styling Functions -----------------------------------------------


if __name__ == "__main__":
    # Run the application
    create_window()

