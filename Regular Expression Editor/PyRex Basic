"""
The goal of this project is to better familarize myself
with both Python's Tkinter and Regular Expression libraries.

Once finished, this project will allow users to text regular
expressions on a test bed of sample text while simultaneously
offering a cheatsheet of common regex expressions and 
storage for a rolodex of their the most useful regex snippets.
"""

# Moved export option to Menu Bar 

# TODO: Create export options
# TODO: Create "View" Menu with laout options
# TODO: Place Regex String beneath text windows    
# TODO: Cheetsheet in extenable panel below interface
# TODO: Make search Apply to larger text widget for integration into Text Editor


import tkinter as tk
from tkinter import ttk
import re

import tkinter.filedialog as filedialog # To export search results as an .rtf


def create_menu(root):
    # Create a menu bar
    menu_bar = tk.Menu(root)

    # Create a "File" menu
    file_menu = tk.Menu(menu_bar, tearoff=0)
    file_menu.add_command(label="Export to File", command=export_results)  # Bind the export_results function
    file_menu.add_separator()
    file_menu.add_command(label="Exit", command=root.quit)  # Add an "Exit" option

    # Add the "File" menu to the menu bar
    menu_bar.add_cascade(label="File", menu=file_menu)

    # Display the menu bar
    root.config(menu=menu_bar)


def create_widgets(root):
    # Configure root to make the application responsive
    root.columnconfigure(0, weight=1)
    root.rowconfigure(0, weight=1)

    # Create main frame
    main_frame = ttk.Frame(root, padding="5")  # Reduce padding
    main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

    # Configure main frame to allow expansion
    main_frame.columnconfigure(0, weight=1)  # Test String widget
    main_frame.columnconfigure(1, weight=1)  # Match Result widget
    main_frame.rowconfigure(3, weight=1)  # Both widgets share the same row

    # Create and place widgets
    create_regex_input(main_frame)
    create_test_string_input(main_frame)
    create_match_result(main_frame)
    create_buttons(main_frame)


def create_regex_input(parent):
    global regex_input
    ttk.Label(parent, text="Regular Expression:").grid(row=0, column=0, sticky=tk.W)
    regex_input = tk.Text(parent, height=3, wrap='word')
    regex_input.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
    # regex_input.insert("end", "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}") # Find Email Addresses
    # regex_input.insert("end", "https?://[^\s]+") # Find URLs
    # regex_input.insert("end", "[A|B][a-z]+")  # Find Words Starting with 'A' or 'B'
    regex_input.insert("end", "[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}")  # Find Domains


def create_test_string_input(parent):
    global test_string_input

    ttk.Label(parent, text="Test String:").grid(row=2, column=0, sticky=tk.W, pady=(5, 0))
    
    # Create frame to hold the text widget and scrollbar
    test_frame = ttk.Frame(parent)
    test_frame.grid(row=3, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 5))

    # Configure frame to expand
    test_frame.columnconfigure(0, weight=1)
    test_frame.rowconfigure(0, weight=1)

    # Create Text widget
    test_string_input = tk.Text(test_frame, height=10, wrap='word')
    test_string_input.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

    # Add vertical scrollbar
    test_scrollbar = tk.Scrollbar(test_frame, orient=tk.VERTICAL, command=test_string_input.yview)
    test_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))

    # Link scrollbar to Text widget
    test_string_input.config(yscrollcommand=test_scrollbar.set)

    # Add initial content to Test String
    test_string_input.insert("end", """Alice's email is alice@example.com, and Bob's email is bob@example.org. Contact us at support@company.com or visit our website: https://www.example.com.""")


def create_match_result(parent):
    global match_result, match_result_label

    match_result_label = ttk.Label(parent, text="Match Results:")
    match_result_label.grid(row=2, column=1, sticky=tk.W, pady=(5, 0))
    
    # Create frame to hold the text widget and scrollbar
    result_frame = ttk.Frame(parent)
    result_frame.grid(row=3, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(5, 0))

    # Configure frame to expand
    result_frame.columnconfigure(0, weight=1)
    result_frame.rowconfigure(0, weight=1)

    # Create Text widget
    match_result = tk.Text(result_frame, height=10, wrap='word', state='disabled')
    match_result.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

    # Add vertical scrollbar
    result_scrollbar = tk.Scrollbar(result_frame, orient=tk.VERTICAL, command=match_result.yview)
    result_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))

    # Link scrollbar to Text widget
    match_result.config(yscrollcommand=result_scrollbar.set)


def create_buttons(parent):
    ttk.Button(parent, text="Match", command=perform_match).grid(row=6, column=0, pady=10) # pady=5, sticky=tk.E)
    ttk.Button(parent, text="Clear Fields", command=clear_fields).grid(row=6, column=1, pady=10) #  pady=5, sticky=tk.W)


def adjust_window_size():
    root.update_idletasks()  # Ensure all layout changes are applied
    width = root.winfo_reqwidth()
    height = root.winfo_reqheight()
    root.geometry(f"{width}x{height}")
    print(f"Window size: {root.winfo_width()}x{root.winfo_height()}")


def export_results():
    # Ensure match_result is not empty
    match_result_text = match_result.get("1.0", tk.END).strip()
    if not match_result_text:
        print("No results to export.")
        return

    # Prompt user to save the file
    file_path = filedialog.asksaveasfilename(
        defaultextension=".rtf",
        filetypes=[("Rich Text Format", "*.rtf"), ("All Files", "*.*")]
    )
    if not file_path:
        return  # User cancelled the save dialog

    try:
        # Begin writing the RTF content
        with open(file_path, "w") as file:
            # RTF header with color table for highlighting
            file.write("{\\rtf1\\ansi\\deff0\n")
            file.write("{\\colortbl;\\red255\\green255\\blue0;}\n")  # Define yellow color

            # Add header text with a blank line
            #file.write("Search results from file test.doc:\\line \\line \n")
            file.write("\\b Search results from file test.doc:\\b0\\line \\line \n")

            # Retrieve text and highlighted regions
            full_text = match_result.get("1.0", tk.END)  # Get the full text
            highlight_ranges = match_result.tag_ranges("highlight")  # Get highlight ranges

            # Initialize absolute position tracker
            current_pos = 0

            for i in range(0, len(highlight_ranges), 2):
                # Get start and end indices of the highlight in absolute positions
                start = match_result.index(highlight_ranges[i])
                end = match_result.index(highlight_ranges[i + 1])

                start_line, start_char = map(int, start.split("."))
                end_line, end_char = map(int, end.split("."))

                # Calculate absolute indices in the text
                start_idx = sum(len(match_result.get(f"{line}.0", f"{line}.end")) + 1 for line in range(1, start_line)) + start_char
                end_idx = sum(len(match_result.get(f"{line}.0", f"{line}.end")) + 1 for line in range(1, end_line)) + end_char

                # Write normal text before the highlight
                if current_pos < start_idx:
                    normal_text = full_text[current_pos:start_idx]
                    file.write(normal_text.replace("\n", "\\line ") + "\n")

                # Write highlighted text
                highlighted_text = full_text[start_idx:end_idx]
                file.write("{\\highlight1 " + highlighted_text.replace("\n", "\\line ") + "}\n")

                # Update the current position
                current_pos = end_idx

            # Write any remaining text after the last highlight
            if current_pos < len(full_text):
                remaining_text = full_text[current_pos:]
                file.write(remaining_text.replace("\n", "\\line ") + "\n")

            # End the RTF content
            file.write("}")
        print(f"Results exported to {file_path}")
    except Exception as e:
        print(f"Error exporting results: {e}")


def perform_match(*args):
    """Displays matching search term and their indexes in Match Result Window"""
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights
    test_string_input.tag_remove("highlight", "1.0", tk.END)

    try:
        # Step 1: Find sentences containing matches
        matches = re.finditer(regex, test_string)
        result = ""

        for match in matches:
            # Step 2: Highlight matches in Test String widget
            start_idx = f"1.0 + {match.start()} chars"
            end_idx = f"1.0 + {match.end()} chars"
            # Highlight the match
            test_string_input.tag_add("highlight", start_idx, end_idx)

            # Add match details to result
            result += f"{match.group()}\n\n"  # Add a blank line after each result

        if not result:
            result = "No matches found."

        # Apply highlighting style
        test_string_input.tag_config("highlight", background="yellow", foreground="black")

        # Update the Match Results widget
        update_match_result(result)
        
        # Dynamically adjust the window size
        # adjust_window_size()

    except re.error as e:
        # Handle regex errors
        update_match_result(f"Invalid regular expression: {str(e)}")


def update_match_result(text):
    match_result.config(state='normal')
    match_result.delete("1.0", tk.END)
    match_result.insert(tk.END, text)
    match_result.config(state='disabled')


def clear_fields():
    # Clear the content of the input fields
    regex_input.delete("1.0", tk.END)
    test_string_input.delete("1.0", tk.END)

    # Clear the Match Results widget
    update_match_result("")


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Tkinter RegEx Editor")
    root.geometry("650x300")

    # Create menu and widgets
    create_menu(root)
    create_widgets(root)

    root.mainloop()

    
