e# -*- coding: utf-8 -*-
# Implimenting Error Checking
# Automatically detect invalid regex patterns and show clear error messages (catch bad parentheses, missing brackets, etc.).

# Creating validate_regex Function


# ToDo: 
# Regex Syntax Highlighting	Highlight regex patterns in the regex_input widget with colors for groups (), character classes [], quantifiers *, etc. (advanced, but powerful)

# Explain Regular Expression	Use a library like regex or simple parsing to explain what the regex does in plain English next to it.
 
# Advanced Sample Generator	Automatically generate "example matching text" for a regex pattern if no sample is provided. (There's a trick using "reverse regex" libraries for this.)


import tkinter as tk
from tkinter import ttk
import re

import tkinter.filedialog as filedialog # To export search results as an .rtf
from tkinter import simpledialog
from tkinter import messagebox

import json # For loading regular_expressions.json and saved_expressions.json
import winsound # For Save/Delete Regex Confirmations

# Table of Contents:
    # User Interface
    # Matching Functions
    # Treeview Functions
    # Functions for Styling Widgets


# Load External Data-----------------------------------------------------------

# Constants for file paths
REGEX_FILE_PATH = "C:/Python/Python38-32/Programs/Tkinter/Regular Expression Editor/regular_expressions.json"
SAVED_FILE_PATH = "C:/Python/Python38-32/Programs/Tkinter/Regular Expression Editor/saved_expressions.json"


# Default data in case JSON files are missing or invalid
DEFAULT_REGULAR_EXPRESSIONS = {
    # Add minimal default data here to keep the program functional
}

DEFAULT_SAVED_EXPRESSIONS = {
    # Add minimal default data here to keep the program functional
}


# Load Regular Expressions
def load_regular_expressions():
    try:
        # Explicitly specify the correct encoding when opening the json file
        with open(REGEX_FILE_PATH, 'r', encoding='utf-8') as file:
            return json.load(file)
    except FileNotFoundError:
        print(f"File not found AT {REGEX_FILE_PATH}. Loading default regular expressions.")
        print("Error: 'regular_expressions.json' not found. Loading default data.")
        return DEFAULT_REGULAR_EXPRESSIONS
    except json.JSONDecodeError:
        print(f"Invalid JSON format in file: {REGEX_FILE_PATH}. Loading default regular expressions.")
        return DEFAULT_REGULAR_EXPRESSIONS


# Load Saved Expressions
def load_saved_expressions():
    try:
        # Explicitly specify the correct encoding when opening the json file
        with open(SAVED_FILE_PATH, 'r', encoding='utf-8') as file:
            return json.load(file)
    except FileNotFoundError:
        print(f"File not found AT {SAVED_FILE_PATH}. Loading default regular expressions.")
        print("Error: 'saved_expressions.json' not found. Loading default data.")
        return DEFAULT_SAVED_EXPRESSIONS
    except json.JSONDecodeError:
        print(f"Invalid JSON format in file: {SAVED_FILE_PATH}. Loading default regular expressions.")
        return DEFAULT_SAVED_EXPRESSIONS


# Load the data
regular_expressions = load_regular_expressions()
saved_expressions = load_saved_expressions()


# Global variable to track toggle state
treeview_visible = False
current_data = regular_expressions  # Default to "Regular Expressions" for Treeview widget


#/Load External Data-----------------------------------------------------------



# User Interface --------------------------------------------------------------

def create_window():
    """Creates the main window for the application with dynamic initial height."""
    
    global root, treeview_frame

    root = tk.Tk()
    root.title("PyRex Regular Expression Editor")
    root.geometry("900x1")  # Temporary small height to calculate actual needed height

    # Create menu, toolbar, and main widgets
    create_menu(root)
    create_toolbar(root)
    create_widgets(root)
    
    # Load keyboard bindings (redo/undo)
    # load_bindings()

    # Update the window to compute widget sizes
    root.update_idletasks()

    # Dynamically adjust the initial window size based on the widgets' required size
    initial_height = root.winfo_reqheight()  # Required height after widgets are placed
    root.geometry(f"900x{initial_height}")  # Set the correct initial height

    # Start the main event loop
    root.mainloop()


def create_menu(window):
    """Creates the main menu."""
    
    menu_bar = tk.Menu(window)

    # File menu
    file_menu = tk.Menu(menu_bar, tearoff=0)
    #file_menu.add_command(label="Export to File", command=export_results)
    file_menu.add_command(label="Save Expression", command=open_save_expression_popup)
    file_menu.add_command(label="Move Expression", command=move_expression_popup)
    file_menu.add_command(label="Delete Expression", command=delete_expression)
    file_menu.add_separator()
    file_menu.add_command(label="Exit", command=window.destroy)

    # Edit menu
    edit_menu = tk.Menu(menu_bar, tearoff=0)
    edit_menu.add_command(label="Undo", command=undo_action, accelerator="Ctrl+Z")
    edit_menu.add_command(label="Redo", command=redo_action, accelerator="Ctrl+Y")

    # Search menu
    search_menu = tk.Menu(menu_bar, tearoff=0)

    # Toggle between Match Results being returned as Instances or Sentences
    global match_mode_var
    # Create variable for Match Results checkbutton
    # Global variable to track the match mode
    match_mode_var = tk.IntVar(value=0)  # 0 = "Instance", 1 = "Sentence"

    # Add mutually exclusive checkbuttons with toggle logic
    search_menu.add_checkbutton(
        label="Match Instances",
        variable=match_mode_var,
        onvalue=0,
        offvalue=1,
        command=lambda: toggle_search_mode(0)
    )
    search_menu.add_checkbutton(
        label="Match Sentences",
        variable=match_mode_var,
        onvalue=1,
        offvalue=0,
        command=lambda: toggle_search_mode(1)
    )

    # View menu
    view_menu = tk.Menu(menu_bar, tearoff=0)

    # Toggle between the Treeview Panel with one of two datasets
    view_menu.add_command(
        label="Regular Expression Cheatsheet",
        command=lambda: toggle_treeview_with_data(current_data)
    )
    view_menu.add_command(
        label="Saved Expressions",
        command=lambda: toggle_treeview_with_data(saved_expressions)
    )   

    # Add menus to the menu bar
    menu_bar.add_cascade(label="File", menu=file_menu)
    menu_bar.add_cascade(label="Edit", menu=edit_menu)
    menu_bar.add_cascade(label="Search", menu=search_menu)
    menu_bar.add_cascade(label="View", menu=view_menu)

    window.config(menu=menu_bar)


def create_widgets(window):
    """Creates the main UI components by delegating to helper functions."""
    
    global main_frame, treeview_frame

    # Configures the grid layout of the main window.
    #configure_window_grid(window)
    window.columnconfigure(0, weight=1)  	# Single column
    window.rowconfigure(1, weight=1)    	# Main frame (static widgets)
    window.rowconfigure(2, weight=0)    	# Treeview frame (toggling widget)

    # Create Toolbar
    create_toolbar(window)

    # Main Frame (Fixed Widgets)
    main_frame = create_main_frame(window)

    # Add Widgets to Main Frame
    create_regex_input(main_frame)    
    create_test_string_field(main_frame)
    create_match_results_field(main_frame)
    create_buttons(main_frame)

    # Create Collapsible Treeview Panel
    treeview_frame = create_treeview_panel(window)


def create_toolbar(window):
    """Creates a toolbar at the top of the window (for Treeview toggle buttons)"""
    
    toolbar = ttk.Frame(window, padding="5")
    toolbar.grid(row=0, column=0, sticky="ew")

    # Button to toggle RegEx CheatSheet
    ttk.Button(
        toolbar,
        text="RegEx CheatSheet",
        command=lambda: toggle_treeview_with_data(current_data)
    ).pack(side="left", padx=5)

    # Button to toggle Saved Expressions
    ttk.Button(
        toolbar,
        text="Saved Expressions",
        command=lambda: toggle_treeview_with_data(saved_expressions)
    ).pack(side="left", padx=5)


def create_main_frame(window):
    """Creates the main frame and configures its layout."""
    
    main_frame = ttk.Frame(window, padding="5")  # Add padding to the main frame
    main_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=10, pady=0)  # Add padding to the grid

    # Configure main_frame grid
    main_frame.columnconfigure(0, weight=1)
    main_frame.columnconfigure(1, weight=1)
    main_frame.rowconfigure(0, weight=0)  # Regular Expression label (fixed)
    main_frame.rowconfigure(1, weight=0)  # Regular Expression input (fixed)
    main_frame.rowconfigure(2, weight=0)  # Test String/Match Results labels (fixed)
    main_frame.rowconfigure(3, weight=0)  # Test String/Match Results widgets (expandable)
    main_frame.rowconfigure(4, weight=0)  # Buttons row (fixed)

    return main_frame


def create_regex_input(parent):
    """Adds a regular expression input field to the given parent frame."""
    
    global regex_input

    ttk.Label(parent, text="Regular Expression:").grid(row=0, column=0, columnspan=2, sticky=tk.W, pady=(5, 2))

    regex_input = tk.Text(parent, height=3, wrap="word", undo=True, maxundo=-1)  
    regex_input.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(2, 5))

    # Insert an initial placeholder (if needed), then clear the undo history
    regex_input.insert("1.0", "")  
    regex_input.edit_reset()  # Clears the undo stack, preventing first undo from wiping text

    # Bind Undo (Ctrl+Z) and Redo (Ctrl+Y) to regex_input
    regex_input.bind("<Control-z>", lambda event: undo_action())
    regex_input.bind("<Control-y>", lambda event: redo_action())

    return regex_input


def undo_action():
    """Performs an undo action in the regex_input field."""
    
    regex_input.focus_set()  # Ensure focus is on regex_input
    try:
        if regex_input.edit_modified():  # Only undo if there are user edits
            regex_input.edit_undo()
    except tk.TclError:
        pass  # Prevents error when no undo actions remain

def redo_action():
    """Performs a redo action in the regex_input field."""
    
    regex_input.focus_set()  # Ensure focus is on regex_input
    try:
        regex_input.edit_redo()
    except tk.TclError:
        pass  # Prevents error when no redo actions remain


def create_test_string_field(parent):
    """Adds test string text field to the left column of the given parent frame."""
    
    global test_string_input

    # Test String
    ttk.Label(parent, text="Test String:").grid(row=2, column=0, sticky=tk.W, pady=(5, 2))
    test_string_input = tk.Text(parent, height=10, wrap="word")
    test_string_input.grid(row=3, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 5))

    test_string_input.insert("end",     
    """Alice's email is alice@example.com, and Bob's email is bob@example.org. Contact us at support@company.com or visit our website: https://www.example.com."""
    )


def create_match_results_field(parent):
    """Adds match results text field to the right column of the given parent frame."""
    
    global match_result

    # Match Results
    ttk.Label(parent, text="Match Results:").grid(row=2, column=1, sticky=tk.W, pady=(5, 2))
    match_result = tk.Text(parent, height=10, wrap="word", state="disabled")
    match_result.grid(row=3, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(5, 0))


def create_buttons(parent):
    """Adds buttons to the given parent frame."""
    
    button_frame = ttk.Frame(parent)
    button_frame.grid(row=4, column=0, columnspan=2, sticky=tk.EW)
    button_frame.columnconfigure(0, weight=1)
    button_frame.columnconfigure(1, weight=1)

    ttk.Button(button_frame, text="Clear Fields", command=clear_fields).grid(row=0, column=0, pady=5, sticky=tk.W)
    ttk.Button(button_frame, text="Match", command=perform_match).grid(row=0, column=1, pady=5, sticky=tk.E)


def create_treeview_panel(window):
    """
    Creates the collapsible Treeview Panel with sample expression and result fields 
    spanning the entire window width.
    """
    
    global treeview_frame, sample_expression_widget, sample_results_widget

    treeview_frame = ttk.Frame(window, padding="5")
    treeview_frame.grid(row=2, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=10, pady=0)
    treeview_frame.columnconfigure(0, weight=1)  # Spanning the entire width

    # Create Treeview Widgets
    create_treeview_section(treeview_frame, 0)
    
    # Bind selection event to automatically highlight first expression
    category_tree.bind("<<TreeviewSelect>>", on_category_select)    

    # Sample Expression Row (Label and Entry on the same line)
    sample_expression_label = ttk.Label(treeview_frame, text="Sample RegEx:")
    sample_expression_label.grid(row=1, column=0, sticky=tk.W, pady=(5, 2))  # Left-aligned label
    #sample_expression_widget = tk.Entry(treeview_frame)
    sample_expression_widget = tk.Text(treeview_frame, height=3, wrap="word", state="disabled")
    sample_expression_widget.grid(
        row=1, column=0, sticky=(tk.W, tk.E), padx=(100, 5), pady=(5, 2), columnspan=3
    )  # Add padding to separate widget from label

    # Sample Results Row (Label and Entry on the same line)
    sample_results_label = ttk.Label(treeview_frame, text="RegEx Result:")
    sample_results_label.grid(row=2, column=0, sticky=tk.W, pady=(5, 5))  # Left-aligned label
    #sample_results_widget = tk.Entry(treeview_frame)
    sample_results_widget = tk.Text(treeview_frame, height=3, wrap="word", state="disabled")
    sample_results_widget.grid(
        row=2, column=0, sticky=(tk.W, tk.E), padx=(100, 5), pady=(5, 5), columnspan=3
    )  # Add padding to separate widget from label

    # Adjust row weights
    treeview_frame.rowconfigure(0, weight=1)  # Treeview row expandable
    treeview_frame.rowconfigure(1, weight=0)  # Fixed height for Sample Expression row
    treeview_frame.rowconfigure(2, weight=0)  # Fixed height for Sample Results row

    treeview_frame.grid_remove()  # Start hidden
    return treeview_frame


# /User Interface -------------------------------------------------------------


# Save RegEx Pop-Up Interface ------------------------------------------------

def open_save_expression_popup():
    """
    Opens a popup window for saving a regular expression.
    """
    
    popup = tk.Toplevel(root)
    popup.title("Save Regular Expression")
    popup.geometry("500x275")
    popup.resizable(False, False)  # Prevent resizing
    popup.transient(root)  # Set the popup as a child of the main window

    # Frames for layout
    category_frame = ttk.Frame(popup, padding="10")
    category_frame.grid(row=0, column=0, sticky="nsew")
    regex_frame = ttk.Frame(popup, padding="10")
    regex_frame.grid(row=1, column=0, sticky="nsew")
    description_frame = ttk.Frame(popup, padding="10")
    description_frame.grid(row=2, column=0, sticky="nsew")
    button_frame = ttk.Frame(popup, padding="10")
    button_frame.grid(row=3, column=0, sticky="ew")

    # Configure column weights for proper layout
    popup.columnconfigure(0, weight=1)
    category_frame.columnconfigure(1, weight=1)
    regex_frame.columnconfigure(0, weight=1)
    description_frame.columnconfigure(0, weight=1)
    button_frame.columnconfigure(0, weight=1)
    button_frame.columnconfigure(1, weight=1)

    # Category Section
    ttk.Label(category_frame, text="Category:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    
    
    # Retrieve and sort the saved categories to show first category by default
    categories = sorted(saved_expressions.keys())
    category_combobox = ttk.Combobox(category_frame, state="readonly", width=30)
    category_combobox["values"] = categories

    # Set the default value to the first category in the sorted list
    if categories:  # Ensure there are categories available
        category_combobox.set(categories[0])  # Set the default value to the first category

    
    #category_combobox = ttk.Combobox(category_frame, values=list(saved_expressions.keys()), state="readonly", width=30)
    category_combobox.grid(row=0, column=1, sticky=tk.W, padx=(5, 0))
    add_category_button = ttk.Button(category_frame, text="Add Category", command=lambda: add_new_category(category_combobox))
    add_category_button.grid(row=0, column=2, padx=(5, 0))

    # Regular Expression Display
    ttk.Label(regex_frame, text="Regular Expression:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    regex_display = tk.Text(regex_frame, height=3, wrap="word", width=60, state="disabled")
    regex_display.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), padx=(0, 0))

    # Populate the Regular Expression field
    regex_content = regex_input.get("1.0", tk.END).strip()
    if regex_content:  # Ensure regex_input has content
        regex_display.configure(state="normal")  # Temporarily make it editable
        regex_display.insert("1.0", regex_content)  # Insert the regex
        regex_display.configure(state="disabled")  # Disable editing again

    # Description Field
    ttk.Label(description_frame, text="Description:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
    description_field = tk.Text(description_frame, height=3, wrap="word", width=60)
    description_field.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), padx=(0, 0))

    # Save and Cancel Buttons
    save_button = ttk.Button(
        button_frame,
        text="Save",
        command=lambda: save_expression(category_combobox, regex_display, description_field, popup)
    )
    save_button.grid(row=0, column=0, sticky=tk.E, padx=5)

    cancel_button = ttk.Button(button_frame, text="Cancel", command=popup.destroy)
    cancel_button.grid(row=0, column=1, sticky=tk.W, padx=5)


def add_new_category(category_combobox):
    """
    Adds a new category to saved_expressions, updates the category_combobox, 
    and ensures categories are displayed alphabetically.
    """
    
    # Prompt the user for the new category name
    new_category = simpledialog.askstring("Add New Category", "Enter a new category name:")
    if not new_category:
        return  # User canceled or entered nothing

    # Trim whitespace and validate the input
    new_category = new_category.strip()
    if not new_category:
        messagebox.showerror("Invalid Input", "Category name cannot be empty.")
        return

    if new_category in saved_expressions:
        messagebox.showerror("Duplicate Category", f"The category '{new_category}' already exists.")
        return

    # Add the new category to saved_expressions
    saved_expressions[new_category] = {}

    # Save the updated saved_expressions to the JSON file
    try:
        with open(SAVED_FILE_PATH, "w") as file:
            json.dump(saved_expressions, file, indent=4)
    except Exception as e:
        messagebox.showerror("Error", f"Failed to save the new category: {e}")
        return

    # Update and sort the category_combobox values
    sorted_categories = sorted(saved_expressions.keys(), key=str.lower)
    category_combobox['values'] = sorted_categories
    category_combobox.set(new_category)  # Set the new category as the selected value

    # Update the category_tree if the Treeview Panel is displaying saved_expressions
    if treeview_visible and toggle_treeview_with_data._last_data_id == id(saved_expressions):
        # Insert the new category into the category_tree
        category_tree.insert("", "end", text=new_category)

        # Re-sort the category_tree alphabetically
        sort_category_tree()
                
    # Confirm category was created
    #messagebox.showinfo("Success", f"Category '{new_category}' added successfully.")
    root.bell() # Windows bell sound


def sort_category_tree():
    """
    Sorts the categories in the category_tree alphabetically.
    """
    
    # Get all current categories in the Treeview
    categories = [(category_tree.item(child, "text"), child) for child in category_tree.get_children()]

    # Sort categories by name
    categories.sort(key=lambda item: item[0].lower())

    # Re-insert categories in sorted order
    for index, (category_name, category_id) in enumerate(categories):
        category_tree.move(category_id, "", index)


def save_expression(category_combobox, regex_display, description_field, popup):
    """
    Saves the current regular expression and description to the selected category
    in the `saved_expressions` nested dictionary.
    """
    
    # Get user input
    category = category_combobox.get().strip()
    regex = regex_display.get("1.0", tk.END).strip()
    description = description_field.get("1.0", tk.END).strip()

    if not category or not regex or not description:
        messagebox.showerror("Error", "All fields (Category, Regular Expression, and Description) are required.")
        return

    # Determine if this is a new category
    is_new_category = category not in saved_expressions
    if is_new_category:
        saved_expressions[category] = {}

    # Add/update regular expression, sorting by description
    saved_expressions[category][regex] = {
        "description": description,
        "sample_expression": "",
        "sample_result": ""
    }
    saved_expressions[category] = dict(sorted(saved_expressions[category].items(), key=lambda item: item[1]["description"].lower()))

    # Save changes to JSON
    try:
        with open(SAVED_FILE_PATH, "w") as file:
            json.dump(saved_expressions, file, indent=4)
    except Exception as e:
        messagebox.showerror("Error", f"Failed to update saved_expressions.json: {e}")
        return

    # Notify user
    # messagebox.showinfo("Success", f"Expression saved to category '{category}'.")
    root.bell() # Windows bell sound

    # Update UI if Treeview is visible
    if treeview_visible and toggle_treeview_with_data._last_data_id == id(saved_expressions):
        if is_new_category:
            populate_treeview(saved_expressions)  # Refresh the entire category list
        else:
            display_key_value_pairs(saved_expressions[category], key_value_tree)  # Update only the right-side Treeview

        # Ensure category is highlighted
        for child in category_tree.get_children():
            if category_tree.item(child, "text") == category:
                category_tree.selection_set(child)
                category_tree.focus(child)
                category_tree.see(child)
                break

        # Delay highlighting to ensure UI updates first
        root.after(100, highlight_saved_expression, regex)
        # Avoids unnecessary calls to root.update_idletasks()

    # Close the popup
    popup.destroy()


def highlight_saved_expression(regex):
    """ Highlights the newly saved regular expression after a delay """
    
    for child in key_value_tree.get_children():
        item = key_value_tree.item(child)
        if item["values"] and item["values"][0] == regex:
            key_value_tree.selection_remove(*key_value_tree.get_children())  # Clear previous selections
            key_value_tree.selection_set(child)  # Highlight new regex
            key_value_tree.focus(child)  # Set focus to it
            key_value_tree.see(child)  # Scroll to it
            key_value_tree.event_generate("<<TreeviewSelect>>")  # Ensure UI updates
            break


def delete_expression():
    """
    Deletes one or more selected regular expressions from the `saved_expressions` JSON file.
    If an entire category is emptied, prompts the user for confirmation before deleting it.
    After deletion, highlights the first category and its first regular expression.
	If no category is selected but a regular expression is, the correct category is auto-selected.
    """

    global saved_expressions

    # Get the selected category
    selected_category = category_tree.selection()
    if not selected_category:
        messagebox.showerror("Error", "Please select a category first.")
        return

    category_name = category_tree.item(selected_category, "text")

    # Get multiple selected regular expressions
    selected_items = key_value_tree.selection()
    if not selected_items:
        messagebox.showerror("Error", "Please select at least one regular expression to delete.")
        return

    # Extract the regex expressions from the selection
	# This line allows multiple expressions to be selected simultaneously.
    selected_regexes = [key_value_tree.item(item, "values")[0] for item in selected_items]

    # Confirm deletion of selected regexes
    confirm = messagebox.askyesno(
        "Confirm Deletion",
        f"Are you sure you want to delete the following regular expressions from '{category_name}'?\n\n"
        + "\n".join(selected_regexes)
    )
    if not confirm:
        return

    # Delete selected regexes from saved_expressions
    if category_name in saved_expressions:
        category_data = saved_expressions[category_name]
        for regex in selected_regexes:
            if regex in category_data:
                del category_data[regex]  # Remove from dictionary

        # If category is now empty, ask to delete the category
        if not category_data:
            delete_category = messagebox.askyesno(
                "Delete Category",
                f"The category '{category_name}' is now empty.\n\n"
                "Do you want to delete this category as well?"
            )
            if delete_category:
                del saved_expressions[category_name]  # Delete category
                category_tree.delete(selected_category)  # Remove from category_tree

                # Save the updated JSON
                try:
                    with open(SAVED_FILE_PATH, "w") as file:
                        json.dump(saved_expressions, file, indent=4)
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to update saved_expressions.json: {e}")
                    return

                # Refresh category_tree
                populate_treeview(saved_expressions)

                # Select the first category in category_tree
                category_items = category_tree.get_children()
                if category_items:
                    first_category = category_items[0]  # Get first category
                    category_tree.selection_set(first_category)
                    category_tree.focus(first_category)
                    category_tree.see(first_category)

                    # Display the first category’s expressions in key_value_tree
                    first_category_name = category_tree.item(first_category, "text")
                    display_key_value_pairs(saved_expressions.get(first_category_name, {}), key_value_tree)

                    # Highlight the first regular expression in key_value_tree
                    root.after(100, highlight_first_available_expression)

                return  # Stop execution after category deletion

    # Save updated JSON file
    try:
        with open(SAVED_FILE_PATH, "w") as file:
            json.dump(saved_expressions, file, indent=4)
    except Exception as e:
        messagebox.showerror("Error", f"Failed to update saved_expressions.json: {e}")
        return

    # Refresh key_value_tree after deletion
    display_key_value_pairs(saved_expressions.get(category_name, {}), key_value_tree)

    # Highlight the first remaining regex in the category
    root.after(100, highlight_first_available_expression)

    messagebox.showinfo("Success", "Selected expressions were successfully deleted.")


def highlight_first_available_expression():
    """
    Highlights the first available regular expression in key_value_tree.
    If no expressions remain, the key_value_tree stays empty.
    Used after deletion or when switching between categories.
    """

    key_items = key_value_tree.get_children()
    if key_items:
        first_key = key_items[0]  # Select first available regular expression
        key_value_tree.selection_set(first_key)
        key_value_tree.focus(first_key)
        key_value_tree.see(first_key)
        key_value_tree.event_generate("<<TreeviewSelect>>")


def move_expression_popup():
    """
    Opens a popup window allowing the user to move a selected regular expression
    from one category to another using a listbox instead of a combobox.
    """

    global saved_expressions

    # Get selected expression and category
    selected_category_item = category_tree.selection()
    selected_expression_item = key_value_tree.selection()

    if not selected_category_item or not selected_expression_item:
        messagebox.showerror("Error", "Please select a regular expression to move.")
        return

    current_category = category_tree.item(selected_category_item, "text")
    selected_expression = key_value_tree.item(selected_expression_item, "values")[0]  # Get regex pattern
    selected_expression_key = key_value_tree.item(selected_expression_item, "values")[0]  # Get regex key
    selected_expression_desc = saved_expressions[current_category].get(selected_expression_key, {}).get("description", "Unknown Description")


    if current_category not in saved_expressions or selected_expression not in saved_expressions[current_category]:
        messagebox.showerror("Error", "Invalid selection. Expression not found.")
        return

    # Open Move Expression Popup
    popup = tk.Toplevel(root)
    popup.title("Move Expression")
    popup.geometry("400x300")
    popup.resizable(False, False)
    popup.transient(root)

    #ttk.Label(popup, text=f"Move '{selected_expression}' to:").pack(pady=(10, 5))
    #ttk.Label(popup, text=f"Move the regular expression\n '{selected_expression_desc}' ''\n from the '{current_category}' category to:").pack(pady=(10, 5))
    ttk.Label(
        popup, 
        text=f"Move the regular expression\n'{selected_expression_desc}'\n"
             f"'{selected_expression_key}'\n"
             f"from the '{current_category}' category to:",
        anchor="center",
        justify="center"
    ).pack(pady=(10, 5), padx=10)

    # Create category list (excluding current category)
    available_categories = [cat for cat in saved_expressions.keys() if cat != current_category]

    if not available_categories:
        messagebox.showerror("Error", "No other categories available.")
        popup.destroy()
        return

    # Create a Frame for the Listbox + Scrollbar
    listbox_frame = ttk.Frame(popup)
    listbox_frame.pack(pady=5, fill="both", expand=True)

    # Listbox for category selection
    category_listbox = tk.Listbox(listbox_frame, height=8, exportselection=False)
    category_listbox.pack(side="left", fill="both", expand=True, padx=5, pady=5)

    # Scrollbar for the listbox
    scrollbar = ttk.Scrollbar(listbox_frame, orient="vertical", command=category_listbox.yview)
    scrollbar.pack(side="right", fill="y")
    category_listbox.config(yscrollcommand=scrollbar.set)

    # Populate listbox with categories
    for category in sorted(available_categories):
        category_listbox.insert("end", category)

    # Select first category by default
    category_listbox.select_set(0)

    # Buttons to confirm or cancel
    button_frame = ttk.Frame(popup)
    button_frame.pack(pady=10)

    ttk.Button(
        button_frame, text="OK",
        command=lambda: move_expression(category_listbox, current_category, selected_expression, popup)
    ).pack(side="left", padx=10)

    ttk.Button(button_frame, text="Cancel", command=popup.destroy).pack(side="right", padx=10)


def move_expression(category_listbox, old_category, regex, popup):
    """
    Moves the selected regular expression from old_category to the new category.
    Updates JSON file and refreshes Treeview widgets.
    """

    global saved_expressions

    # Get selected category from listbox
    selected_index = category_listbox.curselection()
    if not selected_index:
        messagebox.showerror("Error", "Please select a category.")
        return

    new_category = category_listbox.get(selected_index[0])

    if new_category not in saved_expressions:
        saved_expressions[new_category] = {}

    # Move the expression
    saved_expressions[new_category][regex] = saved_expressions[old_category][regex]
    del saved_expressions[old_category][regex]

    # If the old category is now empty, prompt for deletion
    if not saved_expressions[old_category]:
        delete_category = messagebox.askyesno(
            "Delete Empty Category",
            f"The category '{old_category}' is now empty.\n\nDo you want to delete this category?"
        )
        if delete_category:
            del saved_expressions[old_category]

    # Sort new category alphabetically by description
    saved_expressions[new_category] = dict(
        sorted(
            saved_expressions[new_category].items(),
            key=lambda item: item[1]["description"].lower()
        )
    )

    # Save changes to JSON file
    try:
        with open(SAVED_FILE_PATH, "w") as file:
            json.dump(saved_expressions, file, indent=4)
    except Exception as e:
        messagebox.showerror("Error", f"Failed to update saved_expressions.json: {e}")
        return

    # Refresh Treeview to reflect changes
    populate_treeview(saved_expressions)

    # Highlight the new category in category_tree
    for child in category_tree.get_children():
        item_text = category_tree.item(child, "text")
        if item_text == new_category:
            category_tree.selection_set(child)
            category_tree.focus(child)
            category_tree.see(child)
            break

    # Highlight the moved expression in key_value_tree
    root.after(100, lambda: highlight_saved_expression(regex))

    # Close the popup
    popup.destroy()

    #messagebox.showinfo("Success", f"Expression moved to '{new_category}' successfully!")
    root.bell() # Windows bell sound


def highlight_saved_expression(regex):
    """Highlights the moved regular expression in key_value_tree after move."""
    
    for child in key_value_tree.get_children():
        item = key_value_tree.item(child)
        if item["values"] and item["values"][0] == regex:  # Match the moved regex
            key_value_tree.selection_remove(*key_value_tree.get_children())  # Clear previous selections
            key_value_tree.selection_set(child)  # Select the item
            key_value_tree.focus(child)  # Set focus to the specific item
            key_value_tree.see(child)  # Ensure it's visible
            key_value_tree.event_generate("<<TreeviewSelect>>")  # Simulate click
            break


# /Save RegEx Pop-Up Interface ------------------------------------------------


# Matching Functions ----------------------------------------------------------

def perform_match(*args):
    """Determines match mode dynamically and performs the appropriate matching."""
    
    global match_results_as_instances

    # Prevent Regex execution on empty input
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    if not regex:
        messagebox.showwarning("Input Error", "Regular Expression field cannot be empty.")
        return

    if not test_string:
        messagebox.showwarning("Input Error", "Test String field cannot be empty.")
        return

    # Check the current match mode directly from match_mode_var
    # match_mode (0 = Instances, 1 = Sentences)
    if match_mode_var.get() == 0:
        match_instances(*args)  # Perform instance-level matching
    else:
        match_sentences(*args)  # Perform sentence-level matching


def match_instances(*args):
    """Displays instances of matching search term in Match Result Window"""
    
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights
    test_string_input.tag_remove("highlight", "1.0", tk.END)

    try:
        # Step 1: Find sentences containing matches
        matches = re.finditer(regex, test_string)
        result = ""

        for match in matches:
            # Step 2: Highlight matches in Test String widget
            start_idx = f"1.0 + {match.start()} chars"
            end_idx = f"1.0 + {match.end()} chars"
            # Highlight the match
            test_string_input.tag_add("highlight", start_idx, end_idx)

            # Add match details to result
            result += f"{match.group()}\n\n"  # Add a blank line after each result

        if not result:
            result = "No matches found."

        # Apply highlighting style
        test_string_input.tag_config("highlight", background="yellow", foreground="black")

        # Update the Match Results widget
        update_match_result(result)

    except re.error as e:
        # Handle regex errors
        update_match_result(f"Invalid regular expression: {str(e)}")

        
def match_sentences(*args):
    """Displays sentences containing instances of matching search term in Match Result Window"""
    
    regex = regex_input.get("1.0", tk.END).strip()
    test_string = test_string_input.get("1.0", tk.END).strip()

    # Clear previous highlights in both widgets
    test_string_input.tag_remove("highlight", "1.0", tk.END)
    match_result.tag_remove("highlight", "1.0", tk.END)

    try:
        # Step 1: Find sentences containing matches
        matches = list(re.finditer(regex, test_string))
        sentences = re.split(r'(?<=[.!?])\s+', test_string)  # Split into sentences

        result_sentences = []  # To store unique sentences with matches
        for match in matches:
            for sentence in sentences:
                if match.group() in sentence and sentence not in result_sentences:
                    result_sentences.append(sentence)
                    break

        # Step 2: Display sentences in match_result
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)

        if result_sentences:
            # Display results
            for sentence in result_sentences:
                match_result.insert(tk.END, sentence + "\n\n")  # Add a blank line after each sentence

            # Highlight matches in match_result
            match_result_text = match_result.get("1.0", tk.END)
            for match in re.finditer(regex, match_result_text):
                start_idx = f"1.0 + {match.start()} chars"
                end_idx = f"1.0 + {match.end()} chars"
                match_result.tag_add("highlight", start_idx, end_idx)

            match_result.tag_config("highlight", background="yellow", foreground="black")
        else:
            result = "No matches found."

        match_result.config(state="disabled")

    except re.error as e:
        # Handle regex errors
        match_result.config(state="normal")
        match_result.delete("1.0", tk.END)
        match_result.insert(tk.END, f"Invalid regular expression: {str(e)}")

        match_result.config(state="disabled")


def clear_fields():
    #regex_input.delete("1.0", tk.END)
    test_string_input.delete("1.0", tk.END)
    match_result.config(state="normal")
    match_result.delete("1.0", tk.END)
    match_result.config(state="disabled")


def export_results():
    # TODO: Add f-string with name of current open document to header
    # Add a dialog to get header text
    header = simpledialog.askstring(
        "Export Header", "Enter header for exported file:", initialvalue="Search Results:\n")
    if not header:
        header = "Search Results:\n"
    
    header = "\\b " + header + "\\b0"
        

    # Ensure match_result is not empty
    match_result_text = match_result.get("1.0", tk.END).strip()
    if not match_result_text:
        print("No results to export.")
        return

    # Prompt user to save the file
    file_path = filedialog.asksaveasfilename(
        defaultextension=".rtf",
        filetypes=[("Rich Text Format", "*.rtf"), ("All Files", "*.*")]
    )
    if not file_path:
        return  # User cancelled the save dialog

    try:
        # Begin writing the RTF content
        with open(file_path, "w") as file:
            # RTF header with color table for highlighting
            file.write("{\\rtf1\\ansi\\deff0\n")
            file.write("{\\colortbl;\\red255\\green255\\blue0;}\n")  # Define yellow color

            # Add header text with a blank line
            #file.write("Search results from file test.doc:\\line \\line \n")
            #file.write("\\b Search results from file test.doc:\\b0\\line \\line \n")
            file.write(header + "\\line \\line \n")

            # Retrieve text and highlighted regions
            full_text = match_result.get("1.0", tk.END)  # Get the full text
            highlight_ranges = match_result.tag_ranges("highlight")  # Get highlight ranges

            # Initialize absolute position tracker
            current_pos = 0

            for i in range(0, len(highlight_ranges), 2):
                # Get start and end indices of the highlight in absolute positions
                start = match_result.index(highlight_ranges[i])
                end = match_result.index(highlight_ranges[i + 1])

                start_line, start_char = map(int, start.split("."))
                end_line, end_char = map(int, end.split("."))

                # Calculate absolute indices in the text
                start_idx = sum(len(match_result.get(f"{line}.0", f"{line}.end")) + 1 for line in range(1, start_line)) + start_char
                end_idx = sum(len(match_result.get(f"{line}.0", f"{line}.end")) + 1 for line in range(1, end_line)) + end_char

                # Write normal text before the highlight
                if current_pos < start_idx:
                    normal_text = full_text[current_pos:start_idx]
                    file.write(normal_text.replace("\n", "\\line ") + "\n")

                # Write highlighted text
                highlighted_text = full_text[start_idx:end_idx]
                file.write("{\\highlight1 " + highlighted_text.replace("\n", "\\line ") + "}\n")

                # Update the current position
                current_pos = end_idx

            # Write any remaining text after the last highlight
            if current_pos < len(full_text):
                remaining_text = full_text[current_pos:]
                file.write(remaining_text.replace("\n", "\\line ") + "\n")

            # End the RTF content
            file.write("}")
            
        # Notify user of successful export
        print(f"Results exported to {file_path}")
        messagebox.showinfo("Export Successful", f"Results saved to {file_path}")

    except Exception as e:
        print(f"Error exporting results: {e}")
        messagebox.showerror("Export Error", f"Failed to save file: {str(e)}")


def toggle_search_mode(new_mode):
    """Toggles between match modes and re-runs the search if results are present."""
    
    # Update the match_mode_var to reflect the new mode
    match_mode_var.set(new_mode)

    def is_match_result_empty():
        """Checks if the match_result text widget is empty."""
        
        content = match_result.get("1.0", tk.END).strip()  # Get all text and remove surrounding whitespace
        return len(content) == 0  # True if empty, False otherwise

    # Check if match_result has content
    if not is_match_result_empty():
        # Re-run the search in the new mode
        perform_match()
    else:
        print(f"Search mode set to: {'Instances' if new_mode == 0 else 'Sentences'}")


def update_match_result(text):
    match_result.config(state='normal')
    match_result.delete("1.0", tk.END)
    match_result.insert(tk.END, text)
    match_result.config(state='disabled')


def validate_regex(pattern):
    """
    Validates a regex pattern. Returns True / False.
    """

    try:
        re.compile(pattern)
        return True     # Valid pattern
    except re.error as e:
        return False    # Invalid pattern

def validate_and_update_display():
    """
    Checks the validity of regular expressions entered into regex_input
    then updates the text canvas color to red or green to indicate the
    validity to the user.
    """

    expression = regex_input.get

    if regex_input.get("1.0", END)=="\n":
        regex_input.tag_config(background="white", foreground="black")
    else:
	    while validate_regex(expression):
	        regex_input.tag_config(background="red", foreground="black")
	    else:
	        regex_input.tag_config(background="green", foreground="black")

# Keybinding for validating regex patterns
regex_input.bind("<KeyRelease>", lambda event: validate_and_update_display())

    

# /Matching Functions ---------------------------------------------------------


# Treeview Functions ---------------------------------------------------------


def create_treeview_section(parent, row):
    """
    Creates the Treeview section with two widgets: category_tree and key_value_tree.
    """

    global category_tree, key_value_tree

    # Removed code for creating "Tree" that causes Treeview to span two columns

    # Adjust column weights to control widths of the Treeview widgets
    parent.columnconfigure(0, weight=1)  # Left column: Narrower
    parent.columnconfigure(1, weight=4)  # Right column: Wider
    # These two lines of code can be set to weights of 2/2, 1/3, 1/4 or deleted altogether

    # Category Treeview (Left)
    category_tree = create_category_treeview(parent, row)
    category_tree.grid(row=row, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 5))
  
    # Key-Value Treeview (Right)
    key_value_tree = create_key_value_treeview(parent)
    key_value_tree.grid(row=row, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(5, 0))

    # No need to bind <<TreeviewSelect>> here; populate_treeview handles this dynamically

    # Add some space beneath the Treeview widgets
    parent.grid_rowconfigure(1, weight=1, pad=10)  # Add 10px padding
    
    return parent # If not creating a new "tree" Treeview, return parent


def create_category_treeview(parent, row):
    """Creates the Category Treeview with styles."""
    
    configure_treeview_style()

    tree = ttk.Treeview(parent, show="tree", selectmode="browse", style="Custom.Treeview") 
    # style="Custom.Treeview" ensures that the Treeview's alternate row styling is visible

    tree.column("#0", width=150, anchor="w", stretch=True)  # Set the width of the left tree

    scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
    scrollbar.grid(row=0, column=1, sticky="ns")
    tree.configure(yscrollcommand=scrollbar.set)

    # Populate with the top-level keys of the current_data json (Previously categories)
    for category in current_data.keys():
        tree.insert("", "end", text=category)

    return tree


def create_key_value_treeview(parent):
    """
	Creates the Key-Value Treeview with sortable columns, styles, and alternating row colors.
	Initially sorted by the Key column in ascending order.
	"""

    treeview_widget = ttk.Treeview(parent, columns=("Key", "Value"), show="headings", style="Custom.Treeview")
    # !Remember: Excluding style="Custom.Treeview" from line above removes alternating row style!   
 
    # Configure column headers and widths
    treeview_widget.heading("Key", text="Key")
    treeview_widget.heading("Value", text="Value")

    treeview_widget.column("Key", width=100, anchor="w")
    treeview_widget.column("Value", width=350, anchor="w")

    # Add scrollbars
    vertical_scrollbar = ttk.Scrollbar(parent, orient="vertical", command=treeview_widget.yview)
    horizontal_scrollbar = ttk.Scrollbar(parent, orient="horizontal", command=treeview_widget.xview)
    vertical_scrollbar.grid(row=0, column=2, sticky="ns")
    horizontal_scrollbar.grid(row=1, column=1, sticky="ew")
    treeview_widget.configure(yscrollcommand=vertical_scrollbar.set, xscrollcommand=horizontal_scrollbar.set)

    apply_row_styles(treeview_widget)
    configure_hover_effect(treeview_widget)

    # Double-click to insert regex
    treeview_widget.bind("<Double-Button-1>", lambda event: on_key_double_click(event, treeview_widget))

    # Sorting logic
    sort_state = {}

    def sort_by(col):
        """
		Sort headers with toggle arrows without using globals
		"""
	
        reverse = sort_state.get(col, False)
        data = [(treeview_widget.set(child, col).lower(), child) for child in treeview_widget.get_children('')]
        data.sort(reverse=reverse)

        for index, (_, item) in enumerate(data):
            treeview_widget.move(item, '', index)

        # Reset all column headers
        for column in treeview_widget["columns"]:
            treeview_widget.heading(column, text=column)

        # Apply arrow to current column
        arrow = ' ▼' if reverse else ' ▲'
        treeview_widget.heading(col, text=col + arrow)

        # Update state
        sort_state[col] = not reverse
        
        # Restore alternating row styling after sorting
        apply_row_styles(treeview_widget)

    for col in treeview_widget["columns"]:
        treeview_widget.heading(col, command=lambda c=col: sort_by(c))

    # Initial sort by "Key" ascending
    treeview_widget.after(10, lambda: sort_by("Key"))

    # Return the Treeview
    return treeview_widget


def display_key_value_pairs(category_data, key_value_tree):
    """
    Populates the key_value_tree with the key-value pairs of the selected category.
    Applies alternating row styling after populating.
    Always sorts entries by the description field.
    Updates sample expression widget
    """
    
    # Clear existing data   
    key_value_tree.delete(*key_value_tree.get_children())  # Clear previous entries

	# Sort entries by the regex string (key)key_value_tree
    sorted_items = sorted(category_data.items(), key=lambda item: item[0])
	# Sort entries by description before inserting them into key_value_tree:
	#item[1]["description"].lower())

    for key, value in sorted_items:
													
        key_value_tree.insert("", "end", values=(key, value["description"]))

    # Apply alternating row styling
    apply_row_styles(key_value_tree)

    # Bind selection event to update Sample Expression fields
    key_value_tree.bind("<<TreeviewSelect>>", lambda event: update_sample_expression(category_data))


def on_category_select(event):
    """
    Handles selection in the category_tree and updates key_value_tree.
    Automatically highlights the first regular expression.
    """
    
    selected_item = category_tree.selection()
    if selected_item:
        category_name = category_tree.item(selected_item, "text")

        # Display key-value pairs in key_value_tree
        if category_name in saved_expressions:
            display_key_value_pairs(saved_expressions[category_name], key_value_tree)

            # Highlight the first regular expression after UI updates
            root.after(100, highlight_first_expression)

     
def on_key_double_click(event, tree):
    """
    Handles double-clicks on the Key-Value Treeview by appending the key to 
    the regex_input field.
    """
    
    # Get the selected item
    selected_item = tree.focus()
    if not selected_item:
        return  # No item selected

    # Retrieve the key from the selected row
    selected_values = tree.item(selected_item, "values")
    if selected_values:
        key = selected_values[0]  # The key is in the first column

        # Append the key to the regex_input
        current_text = regex_input.get("1.0", tk.END).strip()  # Get current content
        new_text = current_text + key  # Append the key
        regex_input.delete("1.0", tk.END)  # Clear the current content
        regex_input.insert("1.0", new_text)  # Insert the updated content


def populate_treeview(data):
    """
    Populates the category_tree with the given data.
    Clears the key_value_tree to start fresh.
    """
    
    # Clear the left and right Treeview widgets
    category_tree.delete(*category_tree.get_children())
    key_value_tree.delete(*key_value_tree.get_children())

    # Alphabetize categories
    # Sort categories (top-level keys) alphabetically
    sorted_categories = sorted(data.keys(), key=str.lower)

    # Populate the left Treeview with sorted categories
    for category in sorted_categories:
        category_tree.insert("", "end", text=category)
    
    # Set up selection binding for the left Treeview
    def on_select(event):
        selected_item = category_tree.focus()
        if selected_item:
            category = category_tree.item(selected_item, "text")
            display_key_value_pairs(data.get(category, {}), key_value_tree)

    category_tree.bind("<<TreeviewSelect>>", on_select)

    # Bind selection for the right-side Treeview
    def on_key_select(event):
        selected_item = key_value_tree.focus()
        if selected_item:
            item_data = key_value_tree.item(selected_item, "values")
            if item_data:
                regex = item_data[0]
                for key, inner_data in data.items():
                    if regex in inner_data:
                        sample_expression_widget.delete(0, tk.END)
                        sample_expression_widget.insert(0, inner_data[regex].get("sample_expression", ""))
                        sample_results_widget.delete(0, tk.END)
                        sample_results_widget.insert(0, inner_data[regex].get("sample_result", ""))
                        break

    key_value_tree.bind("<<TreeviewSelect>>", on_key_select)


def toggle_treeview_with_data(data):
    """
    Toggles the Treeview Panel on/off or repopulates it if the data changes.
    Ensures the first category and first regular expression are highlighted.
    """
    
    global treeview_visible, treeview_frame

    if not hasattr(toggle_treeview_with_data, "_last_data_id"):
        toggle_treeview_with_data._last_data_id = None

    # If the panel is already open and showing the same data, toggle it off
    if treeview_visible and toggle_treeview_with_data._last_data_id == id(data):
        treeview_frame.grid_remove()
        treeview_visible = False
        toggle_treeview_with_data._last_data_id = None  # Reset stored dataset ID

        # Explicitly Resize the Window After Hiding the Treeview 🔽
        root.update_idletasks()  # Ensure UI updates
        new_height = root.winfo_reqheight()  # Get required height
        root.geometry(f"{root.winfo_width()}x{new_height}")  # Resize window
        return  # Exit function after closing

    # Otherwise, show the Treeview Panel and populate it with new data
    treeview_frame.grid(row=2, column=0, sticky="nsew")
    populate_treeview(data)
    toggle_treeview_with_data._last_data_id = id(data)
    treeview_visible = True

    # Adjust window size dynamically
    root.update_idletasks()
    new_height = root.winfo_reqheight()
    root.geometry(f"{root.winfo_width()}x{new_height}")

    # Ensure categories exist before selecting one
    category_items = category_tree.get_children()
    if category_items:
        first_category = category_items[0]  # Get first category ID

        # Highlight & scroll to the first category
        category_tree.selection_set(first_category)
        category_tree.focus(first_category)
        category_tree.see(first_category)

        # Get the category name
        category_name = category_tree.item(first_category, "text")

        # Ensure the first category’s expressions are displayed in key_value_tree
        if category_name in data:
            display_key_value_pairs(data[category_name], key_value_tree)

            # Delay selecting the first expression to allow UI update
            root.after(100, highlight_first_expression)


def highlight_first_expression():
    """ 
    Highlights the first available regular expression in key_value_tree. 
    Used when switching categories.
    """
    
    key_items = key_value_tree.get_children()
    if key_items:
        first_key = key_items[0]
        key_value_tree.selection_set(first_key)
        key_value_tree.focus(first_key)
        key_value_tree.see(first_key)
        key_value_tree.event_generate("<<TreeviewSelect>>")  # Simulate user selection


def update_sample_expression(category_data):
    """ 
    Updates the Sample Expression without highlighting and applies highlighting only 
    to the sample results. 
    """
    
    selected_item = key_value_tree.focus()
    if not selected_item:
        return
    
    regex_key = key_value_tree.item(selected_item, "values")[0]

    if regex_key in category_data:
        sample_expression = category_data[regex_key].get("sample_expression", "")
        sample_result = category_data[regex_key].get("sample_result", "")

        # Clear previous text
        sample_expression_widget.config(state="normal")
        sample_expression_widget.delete("1.0", tk.END)
        sample_results_widget.config(state="normal")
        sample_results_widget.delete("1.0", tk.END)

        # Remove brackets from Sample Expression but do NOT apply highlighting
        clean_text, _ = extract_highlight_ranges(sample_expression)  # Extract text only, discard highlight info
        sample_expression_widget.insert("1.0", clean_text)

        # Process sample results with highlighting
        clean_result, highlight_ranges = extract_highlight_ranges(sample_result)
        sample_results_widget.insert("1.0", clean_result)
        apply_highlighting(sample_results_widget, highlight_ranges)

        # Disable editing
        sample_expression_widget.config(state="disabled")
        sample_results_widget.config(state="disabled")


def extract_highlight_ranges(text):
    """
    Extracts clean text without brackets and calculates highlight ranges 
    as Tkinter Text widget indices (line.column).
    Supports multi-line highlighting.
    """
    
    clean_text_lines = []
    highlight_ranges = []
    current_line = ""
    inside_brackets = False
    highlight_start_index = None

    line_num = 1
    col_num = 0

    for char in text:
        if char == "[":
            inside_brackets = True
            highlight_start_index = f"{line_num}.{col_num}"
        elif char == "]":
            inside_brackets = False
            highlight_end_index = f"{line_num}.{col_num}"
            if highlight_start_index:
                highlight_ranges.append((highlight_start_index, highlight_end_index))
                highlight_start_index = None
        elif char == "\n":
            current_line += "\n"
            clean_text_lines.append(current_line)
            current_line = ""
            line_num += 1
            col_num = 0
        else:
            current_line += char
            col_num += 1

    if current_line:
        clean_text_lines.append(current_line)

    clean_text = "".join(clean_text_lines)
    return clean_text, highlight_ranges


def apply_highlighting(widget, highlight_ranges):
    """ Highlights text in sample_results_widget based on extracted highlight ranges. """
    
    widget.tag_configure("highlight", background="yellow", foreground="black", font=("Arial", 10, "bold"))

    for start, end in highlight_ranges:
        #widget.tag_add("highlight", f"1.{start}", f"1.{end}")
        # Handles Tkinter-compliant full text indices
        widget.tag_add("highlight", start, end)
        

# /Treeview Functions ---------------------------------------------------------


# Treeview Styling Functions -----------------------------------------------

    
def apply_row_styles(tree):
    """
    Applies alternating row colors to the given Treeview widget.
    """
    
    for index, child in enumerate(tree.get_children()):
        if index % 2 == 0:
            tree.tag_configure("evenrow", background="white")
            tree.item(child, tags=("evenrow",))
        else:
            tree.tag_configure("oddrow", background="#f2f2f2")
            tree.item(child, tags=("oddrow",))


def configure_hover_effect(tree):
    """Configures the hover effect for the Treeview rows."""
    
    def on_mouse_over(event):
        item_id = tree.identify_row(event.y)
        for child in tree.get_children():
            tree.tag_configure("hover", background="#d9d9d9")
            apply_row_styles(tree)
        if item_id:
            tree.item(item_id, tags=("hover",))

    def on_mouse_leave(event):
        apply_row_styles(tree)

    tree.bind("<Motion>", on_mouse_over)
    tree.bind("<Leave>", on_mouse_leave)


def configure_treeview_style():
    """Configures the Treeview widget style."""
    
    style = ttk.Style()
    style.configure("Custom.Treeview", rowheight=25)
    style.map(
        "Custom.Treeview",
        background=[("selected", "#cce5ff")],
        foreground=[("selected", "black")],
    )


def on_double_click(event):
    """Handles the double-click event on a Treeview row."""
    
    item_id = event.widget.focus()
    item = event.widget.item(item_id)
    item_text = item["text"]  # Get the text from the first column ("Item")
    if item_text:
        regex_input.delete(0, tk.END)  # Clear the current text
        regex_input.insert(0, item_text)  # Insert the "Item" text

# /Treeview Styling Functions -----------------------------------------------


if __name__ == "__main__":
    # Run the application
    create_window()

