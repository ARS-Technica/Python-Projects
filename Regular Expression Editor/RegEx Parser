# A Python function for parsing regular expression with a library like regex or simple parsing to explain what a user's regex input does in plain English next to it?


import re
import sre_parse
from sre_parse import SubPattern


CATEGORY_MAP = {
    "category_digit": "a digit (0-9)",
    "category_not_digit": "a non-digit character",
    "category_space": "a whitespace character (space, tab, or newline)",
    "category_not_space": "a non-whitespace character",
    "category_word": "a word character (letter, digit, or underscore)",
    "category_not_word": "a non-word character",
}


def explain_regex(pattern):
    try:
        parsed = sre_parse.parse(pattern)
    except re.error as e:
        return f"Invalid regex: {e}"

    def _explain(parsed_pattern):
        # If it's a SubPattern object, turn it into list of tokens
        if isinstance(parsed_pattern, SubPattern):
            parsed_pattern = list(parsed_pattern)

        parts = []
        for t_type, t_value in parsed_pattern:
            t_name = str(t_type)

            if t_name == "LITERAL":
                parts.append(f"the character '{chr(t_value)}'")

            elif t_name == "ANY":
                parts.append("any character")

            elif t_name == "IN":  # Character set
                chars = []
                for st_type, st_value in t_value:
                    st_name = str(st_type)
                    if st_name == "LITERAL":
                        chars.append(chr(st_value))
                    elif st_name == "RANGE":
                        start, end = st_value
                        chars.append(f"{chr(start)}-{chr(end)}")
                    elif st_name == "CATEGORY":
                        chars.append(CATEGORY_MAP.get(st_value.lower(), st_value))
                parts.append(f"one of [{', '.join(chars)}]")

            elif t_name == "MAX_REPEAT":
                min_rep, max_rep, subpattern = t_value
                rep_desc = _explain(subpattern)  # Recurse here
                if min_rep == max_rep:
                    parts.append(f"{rep_desc} repeated exactly {min_rep} times")
                elif max_rep == sre_parse.MAXREPEAT:
                    parts.append(f"{rep_desc} repeated at least {min_rep} times")
                else:
                    parts.append(f"{rep_desc} repeated {min_rep} to {max_rep} times")

            elif t_name == "SUBPATTERN":
                _, _, _, subpattern = t_value
                parts.append(f"( { _explain(subpattern) } )")
            if t_name == "LITERAL":

            elif t_name == "ANY":

            elif t_name == "IN":  # Character set

            elif t_name == "MAX_REPEAT":

            elif t_name == "SUBPATTERN":

            elif t_name == "BRANCH":  # Alternation (|)
                _, branches = t_value
                branch_desc = ["( " + _explain(branch) + " )" for branch in branches]
                parts.append(" or ".join(branch_desc))

            elif t_name == "CATEGORY":
                parts.append(CATEGORY_MAP.get(t_value.lower(), t_value))

            elif t_name == "AT":

            else:
                # If itâ€™s a SubPattern again, recurse



# Example
print(explain_regex(r"^\d{3}-[A-Z]{2}$"))

# Matches the start of the string, a digit (0-9) exactly 3 times, the character '-', A-Z exactly 2 times, the end of the string
