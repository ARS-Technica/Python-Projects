"""
Regular Expression Example Generator

This module provides functions for generating example strings from
user-supplied regular expressions. It is designed as a standalone
utility, but it will eventually be incorporated into the larger
Regular Expression Editor project,first as a set of functions,
and later refactored into a class.

This generator will attempt to produce a representative example
of a string that would match the regular expression provided by
the user.

The goal isn't to exhaustively enumerate matches, only to provide
a plausible example for user feedback.

Inputs:
    pattern (str): A regular expression.

Outputs:
    str: A generated example string matching the pattern.
"""


import re
import rstr

import sys
sys.stdout.reconfigure(encoding='utf-8')


def normalize_regex(bre_pattern: str) -> str:
    """
    Normalize a BRE-style regex into ERE/PCRE-style syntax
    that rstr.xeger can handle.
    """

    # --- Convert BRE quantifiers like \{2,5\} → {2,5}
    bre_pattern = re.sub(r'\\\{(\d+)(,(\d+)?)?\\\}', r'{\1\2}', bre_pattern)

    # --- Convert escaped special chars (\+, \?, \., \^, \$)
    bre_pattern = bre_pattern.replace(r'\+', '+')
    bre_pattern = bre_pattern.replace(r'\?', '?')
    bre_pattern = bre_pattern.replace(r'\.', '.')
    bre_pattern = bre_pattern.replace(r'\^', '^')
    bre_pattern = bre_pattern.replace(r'\$', '$')

    # --- Convert POSIX classes [[:digit:]] → [0-9], etc.
    posix_classes = {
        "[:digit:]": "0-9",
        "[:alpha:]": "A-Za-z",
        "[:alnum:]": "A-Za-z0-9",
        "[:space:]": " \t\r\n\f\v",
        "[:word:]": "A-Za-z0-9_",
        "[:lower:]": "a-z",
        "[:upper:]": "A-Z",
    }
    for cls, repl in posix_classes.items():
        bre_pattern = bre_pattern.replace(f"[{cls}]", f"[{repl}]")

    # --- Clamp unbounded quantifiers
    def clamp(match):
        lo = int(match.group(1))
        hi = match.group(2)
        if hi:
            hi = int(hi)
            hi = min(hi, 10)  # cap upper bound
        else:
            hi = lo + 5        # open-ended {n,} → {n, n+5}
        return f"{{{lo},{hi}}}"

    bre_pattern = re.sub(r"\{(\d+),(\d+)\}", 
                         lambda m: clamp(m), bre_pattern)
    bre_pattern = re.sub(r"\{(\d+),\}", 
                         lambda m: clamp(m), bre_pattern)

    # --- Clamp * and + and ? 
    bre_pattern = re.sub(r"\*", r"{0,10}", bre_pattern)
    bre_pattern = re.sub(r"\+", r"{1,10}", bre_pattern)
    # leave ? alone (optional)

    # --- Fix character classes
    # Convert \s inside [] to space set
    bre_pattern = re.sub(r"\[([^]]*?)\\s([^]]*?)\]", 
                         lambda m: f"[{m.group(1)} \t\r\n\f\v{m.group(2)}]", 
                         bre_pattern)

    # Escape literal '-' when ambiguous
    bre_pattern = re.sub(r"\[([^\]]*?)-([^\]]*?)\]", 
                         lambda m: f"[{m.group(1)}\\-{m.group(2)}]", 
                         bre_pattern)

    return bre_pattern


def generate_sample_from_regex(bre_pattern: str) -> str:
    """
    Generate a sample string from a BRE-style regex pattern
    using rstr.xeger after normalizing.
    """
    try:
        ere_pattern = normalize_regex(bre_pattern)
        return rstr.xeger(ere_pattern)
    except Exception as e:
        return f"[error: {e}]"


if __name__ == "__main__":
    '''tests = [
        r"\$[0-9]*\.[0-9][0-9]",                 # price
        r"[0-9]\{3\}-[0-9]\{2\}-[0-9]\{4\}",     # SSN
        r"[0-9]\{5\}(-[0-9]\{4\})?",             # ZIP code
        r"(^\+[0-9]{2}|^\+[0-9]{2}\(0\)|^\(\+[0-9]{2}\)\(0\)|^00[0-9]{2}|^0)([0-9]{9}$|[0-9\-\s]{10}$)", # phone
        r"(?:\+?[0-9]{2}|00[0-9]{2}|0)(?:[0-9]{9}|[0-9\- ]{10})", # phone with optional country code
    ]'''

    tests = [r"\$[0-9]*\.[0-9][0-9]",       # Money format
        r"[A-Z]\{2,5\}",                    # Escaped quantifier
        r"\d{3}-\d{2}-\d{4}",               # SSN-style
        r"hello\+world",                    # Escaped +
        r"[[:digit:]]{5}",                  # POSIX digit class
        r".*\s\w+",                         # dot/whitespace/word
        r"[0-9]\\{5\\}(-[0-9]\\{4\\})?",    # Zip Code 
        r"^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6011[0-9]{12}|622((12[6-9]|1[3-9][0-9])|([2-8][0-9][0-9])|(9(([0-1][0-9])|(2[0-5]))))[0-9]{10}|64[4-9][0-9]{13}|65[0-9]{14}|3(?:0[0-5]|[68][0-9])[0-9]{11}|3[47][0-9]{13})*$",                # Credit Cards 
        r"[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}",                      #  Date (2003-08-06)
        r"^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{2}|(19|20)\\d{2})$",          # Date (DD/MM/YYYY or MM/DD/YY)  
        r"[A-Z][a-z][a-z] [0-9][0-9]*, [0-9]\\{4\\}",                   # Date (Jan 3, 2003) 
        r"\\$[0-9]*\\.[0-9][0-9]",                                      # Dollar amounts with a $ symbol 
        r"^[\\w\\-]+(\\.[\\w\\-]+)*@([A-Za-z0-9-]+\\.)+[A-Za-z]{2,4}$", # E-mail address  
        r"^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$",                #  IP Address
        r"^-?[0-9]{0,2}(\\.[0-9]{1,2})?$|^-?(100)(\\.[0]{1,2})?$",      # Percentage (2 decimal places) 
        r"(^\\+[0-9]{2}|^\\+[0-9]{2}\\(0\\)|^\\(\\+[0-9]{2}\\)\\(0\\)|^00[0-9]{2}|^0)([0-9]{9}$|[0-9\\-\\s]{10}$)",                #  Phone Numbers
        r"[0-9]\\{3\\}-[0-9]\\{2\\}-[0-9]\\{4\\}",                       #  Social Security
        r"^http(s)?://((\\d+\\.\\d+\\.\\d+\\.\\d+)|(([\\w-]+\\.)+([a-z,A-Z][\\w-]*)))(:[1-9][0-9]*)?(\\/([\\w\\/:%+@&=]+[\\w\\/?:%+@&=]*)?)?(#(.*))?$",                #  URL
        r"[0-9]\\{5\\}(-[0-9]\\{4\\})?"                                  #  Zip Code
    ]

    for pat in tests:
        # print(f"{pat} → {generate_sample_from_regex(pat)}")
        print(f"{generate_sample_from_regex(pat)}")
