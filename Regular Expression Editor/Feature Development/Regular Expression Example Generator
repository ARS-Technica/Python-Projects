"""
Regular Expression Example Generator

This module provides functions for generating example strings from
user-supplied regular expressions. It is designed as a standalone
utility, but it will eventually be incorporated into the larger
Regular Expression Editor project,first as a set of functions,
and later refactored into a class.

This generator will attempt to produce a representative example
of a string that would match the regular expression provided by
the user.

The goal isn't to exhaustively enumerate matches, only to provide
a plausible example for user feedback.

Inputs:
    pattern (str): A regular expression.

Outputs:
    str: A generated example string matching the pattern.
"""


import re
import rstr

import sys
sys.stdout.reconfigure(encoding='utf-8')


def is_supported_by_rstr(pattern: str) -> bool:
    """
    Check if a regex is likely to be too advanced for rstr.xeger.
    Returns False if the pattern uses unsupported constructs.
    """
    unsupported_tokens = [
        r"\^",         # anchors inside groups
        r"\$",         # end anchors inside groups
        r"\(\?=",      # positive lookahead
        r"\(\?!",      # negative lookahead
        r"\(\?<=",     # positive lookbehind
        r"\(\?<!",     # negative lookbehind
        r"\(\?P<",     # named groups
        r"\(\?#",      # comments
    ]
    for token in unsupported_tokens:
        if re.search(token, pattern):
            return False
    return True


def normalize_regex(pattern: str) -> str:
    """
    Normalize a regex pattern with BRE-style quirks into syntax that rstr.xeger understands.
    Silently converts what it can; leaves the rest untouched.
    """

    # Convert BRE-style quantifiers \{m,n\} → {m,n}
    pattern = re.sub(r"\\\{(\d+)(,(\d+)?)?\\\}", r"{\1\2}", pattern)

    # Convert escaped operators \+ → +, \? → ?, \. → .
    pattern = pattern.replace(r"\+", "+")
    pattern = pattern.replace(r"\?", "?")
    pattern = pattern.replace(r"\.", ".")

    # Convert escaped anchors \^ → ^, \$ → $
    pattern = pattern.replace(r"\^", "^")
    pattern = pattern.replace(r"\$", "$")

    # Clamp open-ended quantifiers {n,} → {n,10}
    pattern = re.sub(r"\{(\d+),\}", r"{\1,10}", pattern)

    # POSIX Character Class Expansions (full set)
    posix_classes = {
        r"\[\[:digit:\]\]": r"\d",                      # digits
        r"\[\[:alpha:\]\]": r"[A-Za-z]",                # letters
        r"\[\[:alnum:\]\]": r"[A-Za-z0-9]",             # alphanumeric
        r"\[\[:lower:\]\]": r"[a-z]",                   # lowercase
        r"\[\[:upper:\]\]": r"[A-Z]",                   # uppercase
        r"\[\[:space:\]\]": r"\s",                      # whitespace
        r"\[\[:blank:\]\]": r"[ \t]",                   # space + tab
        r"\[\[:punct:\]\]": r"[!\"#$%&'()*+,\-./:;<=>?@\[\]^_`{|}~]",  # punctuation
        r"\[\[:xdigit:\]\]": r"[0-9A-Fa-f]",            # hex digits
        r"\[\[:word:\]\]": r"\w",                       # word characters
        r"\[\[:graph:\]\]": r"[!-~]",                   # visible (non-space)
        r"\[\[:print:\]\]": r"[ -~]",                   # printable (includes space)
        r"\[\[:cntrl:\]\]": r"[\x00-\x1F\x7F]",         # control chars
    }

    # Use lambda so backslashes are preserved literally
    for posix, replacement in posix_classes.items():
        pattern = re.sub(posix, lambda m, rep=replacement: rep, pattern)

    return pattern


def generate_sample_from_regex(pattern: str) -> str:
    """
    Generate a sample string from a BRE-style regex pattern
    using rstr.xeger after normalizing.
    """

    norm = normalize_regex(pattern)

    if not is_supported_by_rstr(norm):
        return f"[error: regex too advanced for rstr.xeger → {pattern}]"

    try:
        return rstr.xeger(norm)
    except Exception as e:
        return f"[error: {e}]"


if __name__ == "__main__":
    '''tests = [
        r"\$[0-9]*\.[0-9][0-9]",                 # price
        r"[0-9]\{3\}-[0-9]\{2\}-[0-9]\{4\}",     # SSN
        r"[0-9]\{5\}(-[0-9]\{4\})?",             # ZIP code
        r"(^\+[0-9]{2}|^\+[0-9]{2}\(0\)|^\(\+[0-9]{2}\)\(0\)|^00[0-9]{2}|^0)([0-9]{9}$|[0-9\-\s]{10}$)", # phone
    ]'''
	
    tests = [
        r"\$[0-9]*\.[0-9][0-9]",       # Money format
        r"[A-Z]\{2,5\}",               # Escaped quantifier
        r"\d{3}-\d{2}-\d{4}",          # SSN-style
        r"hello\+world",               # Escaped +
        r"[[:digit:]]{5}",             # POSIX digit class
        r"[[:alpha:]]{3}",             # POSIX alpha
        r"[[:alnum:]]{4}",             # POSIX alnum
        r"[[:punct:]]{2}",             # POSIX punctuation
        #r"[[:xdigit:]]{6}",            # POSIX hex digits
        #r".*\s\w+",                    # dot/whitespace/word
        #r"[0-9]\{5\}(-[0-9]\{4\})?",   # Zip Code																														   
        #r"[0-9]\{3\}-[0-9]\{2\}-[0-9]\{4\}",  # Social Security																			 																		
    ]

    for pat in tests:
        print(f"{pat} → {generate_sample_from_regex(pat)}")



    """    
    for t in tests:
        print(f"BRE:        {t}")
        print(f"Normalized: {normalize_regex(t)}")
        print(f"Sample:     {generate_sample_from_regex(t)}")
        print()
	"""
				   
								 
												  
															 
			   
