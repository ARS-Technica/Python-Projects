"""
Regular Expression Example Generator

This module provides functions for generating example strings from
user-supplied regular expressions. It is designed as a standalone
utility, but it will eventually be incorporated into the larger
Regular Expression Editor project,first as a set of functions,
and later refactored into a class.

This generator will attempt to produce a representative example
of a string that would match the regular expression provided by
the user.

The goal isn't to exhaustively enumerate matches, only to provide
a plausible example for user feedback.

Inputs:
    pattern (str): A regular expression.

Outputs:
    str: A generated example string matching the pattern.
"""


import re
import rstr

def normalize_regex(bre_pattern: str, max_repeat: int = 10) -> str:
    """
    Normalize a BRE-style regex into something rstr.xeger can handle,
    converting escaped BRE quirks and clamping unbounded quantifiers.
    """
    pattern = bre_pattern

    # --- BRE → ERE translations ---

    # Escaped quantifiers: \{n,m\} → {n,m}, \{n\} → {n}
    pattern = re.sub(r'\\\{(\d+),(\d+)\\\}', r'{\1,\2}', pattern)   # {n,m}
    pattern = re.sub(r'\\\{(\d+)\\\}', r'{\1}', pattern)            # {n}

    # Escaped +, ?, | 
    pattern = pattern.replace(r'\+', '+')
    pattern = pattern.replace(r'\?', '?')
    pattern = pattern.replace(r'\|', '|')

    # Escaped anchors
    pattern = pattern.replace(r'\^', '^')
    pattern = pattern.replace(r'\$', '$')   # <-- fixed

    # Escaped dot
    pattern = pattern.replace(r'\.', '.')

    # Escaped shorthand character classes
    pattern = pattern.replace(r'\d', '[0-9]')
    pattern = pattern.replace(r'\w', '[A-Za-z0-9_]')
    pattern = pattern.replace(r'\s', '[ \t\r\n\f\v]')

    # POSIX character classes
    pattern = pattern.replace('[[:digit:]]', '[0-9]')
    pattern = pattern.replace('[[:alnum:]]', '[A-Za-z0-9]')
    pattern = pattern.replace('[[:alpha:]]', '[A-Za-z]')
    pattern = pattern.replace('[[:space:]]', '[ \t\r\n\f\v]')
    pattern = pattern.replace('[[:word:]]', '[A-Za-z0-9_]')

    # --- Clamp unbounded quantifiers ---
    pattern = re.sub(r'\*', f'{{0,{max_repeat}}}', pattern)              # *
    pattern = re.sub(r'\+', f'{{1,{max_repeat}}}', pattern)              # +
    pattern = re.sub(r'\{(\d+),\}', rf'{{\1,{max_repeat}}}', pattern)    # {n,}

    return pattern

def generate_sample_from_regex(bre_pattern: str, max_repeat: int = 10) -> str:
    """
    Generate a sample string from a BRE-style regex pattern,
    normalized and clamped to ASCII-safe output.
    """
    try:
        normalized = normalize_regex(bre_pattern, max_repeat=max_repeat)
        example = rstr.xeger(normalized)

        # Force ASCII-safe and strip leading/trailing whitespace
        ascii_example = example.encode("ascii", "ignore").decode("ascii").strip()

        return ascii_example if ascii_example else "[no ascii output]"
    except Exception as e:
        return f"[error: {e}]"

# --- Example usage ---
if __name__ == "__main__":
    tests = [r"\$[0-9]*\.[0-9][0-9]",       # Money format
        r"[A-Z]\{2,5\}",                    # Escaped quantifier
        r"\d{3}-\d{2}-\d{4}",               # SSN-style
        r"hello\+world",                    # Escaped +
        r"[[:digit:]]{5}",                  # POSIX digit class
        r".*\s\w+",                         # dot/whitespace/word
        r"[0-9]\\{5\\}(-[0-9]\\{4\\})?",    # Zip Code 
        r"^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6011[0-9]{12}|622((12[6-9]|1[3-9][0-9])|([2-8][0-9][0-9])|(9(([0-1][0-9])|(2[0-5]))))[0-9]{10}|64[4-9][0-9]{13}|65[0-9]{14}|3(?:0[0-5]|[68][0-9])[0-9]{11}|3[47][0-9]{13})*$",                # Credit Cards 
        r"[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}",                      #  Date (2003-08-06)
        r"^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{2}|(19|20)\\d{2})$",          # Date (DD/MM/YYYY or MM/DD/YY)  
        r"[A-Z][a-z][a-z] [0-9][0-9]*, [0-9]\\{4\\}",                   # Date (Jan 3, 2003) 
        r"\\$[0-9]*\\.[0-9][0-9]",                                      # Dollar amounts with a $ symbol 
        r"^[\\w\\-]+(\\.[\\w\\-]+)*@([A-Za-z0-9-]+\\.)+[A-Za-z]{2,4}$", # E-mail address  
        r"^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$",                #  IP Address
        r"^-?[0-9]{0,2}(\\.[0-9]{1,2})?$|^-?(100)(\\.[0]{1,2})?$",      # Percentage (2 decimal places) 
        r"(^\\+[0-9]{2}|^\\+[0-9]{2}\\(0\\)|^\\(\\+[0-9]{2}\\)\\(0\\)|^00[0-9]{2}|^0)([0-9]{9}$|[0-9\\-\\s]{10}$)",                #  Phone Numbers
        r"[0-9]\\{3\\}-[0-9]\\{2\\}-[0-9]\\{4\\}",                       #  Social Security
        r"^http(s)?://((\\d+\\.\\d+\\.\\d+\\.\\d+)|(([\\w-]+\\.)+([a-z,A-Z][\\w-]*)))(:[1-9][0-9]*)?(\\/([\\w\\/:%+@&=]+[\\w\\/?:%+@&=]*)?)?(#(.*))?$",                #  URL
        r"[0-9]\\{5\\}(-[0-9]\\{4\\})?"                                  #  Zip Code
    ]

    for t in tests:
        print(f"BRE:        {t}")
        print(f"Normalized: {normalize_regex(t)}")
        print(f"Sample:     {generate_sample_from_regex(t)}")
        print()
