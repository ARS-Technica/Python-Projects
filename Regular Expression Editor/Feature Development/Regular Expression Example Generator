"""
Regular Expression Example Generator

This module provides functions for generating example strings from
user-supplied regular expressions. It is designed as a standalone
utility, but it will eventually be incorporated into the larger
Regular Expression Editor project,first as a set of functions,
and later refactored into a class.

This generator will attempt to produce a representative example
of a string that would match the regular expression provided by
the user.

The goal isn't to exhaustively enumerate matches, only to provide
a plausible example for user feedback.

Inputs:
    pattern (str): A regular expression.

Outputs:
    str: A generated example string matching the pattern.
"""


# Extended the normalize_regex function to auto-clamp .*, simplify \s, and tame \w+ so examples look more human-readable

import re
import rstr
import exrex
import random
import string
import sys

# Ensure UTF-8 output on Windows
sys.stdout.reconfigure(encoding='utf-8')


def is_supported_by_rstr(pattern: str) -> bool:
    """
    Check if a regex is likely to be too advanced for rstr.xeger.
    Returns False if the pattern uses unsupported constructs.
    """
    unsupported_tokens = [
        r"\^",         # anchors inside groups
        r"\$",         # end anchors inside groups
        r"\(\?=",      # positive lookahead
        r"\(\?!",      # negative lookahead
        r"\(\?<=",     # positive lookbehind
        r"\(\?<!",     # negative lookbehind
        r"\(\?P<",     # named groups
        r"\(\?#",      # comments
    ]
    for token in unsupported_tokens:
        if re.search(token, pattern):
            return False
    return True


def normalize_regex(pattern: str) -> str:
    """
    Normalize a regex pattern with BRE-style quirks into syntax that rstr.xeger understands.
    Silently converts what it can; leaves the rest untouched.
    """

    # Convert BRE-style quantifiers \{m,n\} → {m,n}
    pattern = re.sub(r"\\\{(\d+)(,(\d+)?)?\\\}", r"{\1\2}", pattern)

    # Convert escaped operators \+ → +, \? → ?, \. → .
    pattern = pattern.replace(r"\+", "+")
    pattern = pattern.replace(r"\?", "?")
    pattern = pattern.replace(r"\.", ".")

    # Convert escaped anchors \^ → ^, \$ → $
    pattern = pattern.replace(r"\^", "^")
    pattern = pattern.replace(r"\$", "$")

    # Clamp open-ended quantifiers {n,} → {n,10}
    pattern = re.sub(r"\{(\d+),\}", r"{\1,10}", pattern)

    # === POSIX Character Class Expansions ===
    posix_classes = {
        r"\[\[:digit:\]\]": r"\\d",            # digits 0–9
        r"\[\[:alpha:\]\]": r"[A-Za-z]",       # letters
        r"\[\[:alnum:\]\]": r"[A-Za-z0-9]",    # alphanumeric
        r"\[\[:lower:\]\]": r"[a-z]",          # lowercase
        r"\[\[:upper:\]\]": r"[A-Z]",          # uppercase
        r"\[\[:space:\]\]": r"\\s",            # whitespace
        r"\[\[:blank:\]\]": r"[ \t]",          # space + tab
        r"\[\[:punct:\]\]": r"[!\"#$%&'()*+,\-./:;<=>?@\[\]^_`{|}~]",  # punctuation
        r"\[\[:xdigit:\]\]": r"[0-9A-Fa-f]",   # hex digits
        r"\[\[:word:\]\]": r"\\w"              # word characters
    }
    for posix, replacement in posix_classes.items():
        pattern = re.sub(posix, replacement, pattern)

    # === Human-readable tweaks ===
    # Clamp greedy wildcard .* → .{0,10}
    pattern = re.sub(r"\.\*", ".{0,10}", pattern)

    # Simplify whitespace: \s → space only
    pattern = pattern.replace(r"\s", " ")

    # Tame word class: \w+ → [A-Za-z]{1,10}
    pattern = re.sub(r"\\w\+", r"[A-Za-z]{1,10}", pattern)

    return pattern


def brute_force_fallback(pattern: str, max_attempts: int = 5000) -> str:
    """
    Try random candidate generation + re.fullmatch as last resort.
    """
    regex = re.compile(pattern)
    alphabet = string.printable
    for _ in range(max_attempts):
        candidate = "".join(random.choice(alphabet) for _ in range(20))
        if regex.fullmatch(candidate):
            return candidate
    return f"[error: could not brute-force match '{pattern}']"


def generate_sample_from_regex(pattern: str) -> str:
    """
    Generate a sample string from a regex pattern with a 3-step fallback:
    1. Try rstr.xeger
    2. Try exrex
    3. Try brute-force candidate generation
    """

    norm = normalize_regex(pattern)

    # Step 1: Try rstr.xeger
    try:
        if is_supported_by_rstr(norm):
            return rstr.xeger(norm)
        raise ValueError("Unsupported regex for rstr.xeger")
    except Exception:
        pass

    # Step 2: Try exrex
    try:
        return next(exrex.generate(norm))
    except Exception:
        pass

    # Step 3: Brute-force fallback
    try:
        return brute_force_fallback(norm)
    except Exception as e:
        return f"[error: {e}]"


if __name__ == "__main__":

    tests = [
        r"\$[0-9]*\.[0-9][0-9]",       # Money format
        r"[A-Z]\{2,5\}",               # Escaped quantifier
        r"\d{3}-\d{2}-\d{4}",          # SSN-style
        r"hello\+world",               # Escaped +
        r"[[:digit:]]{5}",             # POSIX digit class
        r"[[:alpha:]]{3}",             # POSIX alpha
        r"[[:alnum:]]{4}",             # POSIX alnum
        r"[[:punct:]]{2}",             # POSIX punctuation
        r"[[:xdigit:]]{6}",            # POSIX hex digits
        r".*\s\w+",                    # dot/whitespace/word
        r"[0-9]\{5\}(-[0-9]\{4\})?",   # Zip Code																														   
        r"[0-9]\{3\}-[0-9]\{2\}-[0-9]\{4\}",  # Social Security																			 																		
    ]

    for pat in tests:
        print(f"{pat} → {generate_sample_from_regex(pat)}")
