"""
Regular Expression Example Generator

This module provides functions for generating example strings from
user-supplied regular expressions. It is designed as a standalone
utility, but it will eventually be incorporated into the larger
Regular Expression Editor project,first as a set of functions,
and later refactored into a class.

This generator will attempt to produce a representative example
of a string that would match the regular expression provided by
the user.

The goal isn't to exhaustively enumerate matches, only to provide
a plausible example for user feedback.

Inputs:
    pattern (str): A regular expression.

Outputs:
    str: A generated example string matching the pattern.
"""

# Put time limits around brute-force searching to prevent lock up

# Extended the normalize_regex function to auto-clamp .*, simplify \s, and tame \w+ so examples look more human-readable

import concurrent.futures   # Used in brute_force_with_timeout with a ThreadPoolExecutor to run the brute-force fallback in a separate thread. 
import re
import rstr
import exrex
import random
import string
import sys


sys.stdout.reconfigure(encoding='utf-8')    # Ensure UTF-8 output on Windows


def brute_force_fallback(pattern: str, max_attempts: int = 5000) -> str:
    """
    Try random candidate generation + re.fullmatch as last resort.
    """
    regex = re.compile(pattern)
    alphabet = string.printable
    for _ in range(max_attempts):
        candidate = "".join(random.choice(alphabet) for _ in range(20))
        if regex.fullmatch(candidate):
            return candidate
    return f"[error: could not brute-force match '{pattern}']"


def brute_force_sample(pattern, charset="abcdefghijklmnopqrstuvwxyz0123456789", max_len=12, tries=1000):
    """Brute-force fallback: randomly generate strings and return the first that matches.
    """
    for _ in range(tries):
        candidate = "".join(random.choice(charset) for _ in range(random.randint(1, max_len)))
        if re.fullmatch(pattern, candidate):
            return candidate
    return None


def brute_force_with_timeout(pattern, timeout=2.0):
    """Run brute-force with a timeout to avoid hangs on pathological regexes.
    Uses concurrent.futures with a ThreadPoolExecutor to run the brute-force fallback in a separate thread. 
    If it takes longer than, say, 2 seconds, we kill it and return a clear error message instead of hanging."""
    with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:
        future = executor.submit(brute_force_sample, pattern)
        try:
            return future.result(timeout=timeout)
        except concurrent.futures.TimeoutError:
            return f"[error: brute-force timeout after {timeout}s]"


def generate_sample_from_regex(pattern: str) -> str:
    """
    Generate a sample string from a BRE-style regex pattern.
    Attempts three fallbacks in order:
    1. rstr.xeger
    2. exrex
    3. brute-force (with timeout)
    """

    norm = normalize_regex(pattern)

    # If unsupported features are detected, skip early
    if not is_supported_by_rstr(norm):
        return f"[error: regex too advanced for rstr.xeger → {pattern}]"

    # Stage 1: Try rstr
    try:
        return rstr.xeger(norm)
    except Exception:
        pass

    # Stage 2: Try exrex
    try:
        import exrex
        return next(exrex.generate(norm, limit=1000))
    except Exception:
        pass

    # Stage 3: Try brute-force with timeout
    sample = brute_force_with_timeout(norm, timeout=2.0)
    if sample:
        return sample
    else:
        return "[error: no valid example found]"


def is_supported_by_rstr(pattern: str) -> bool:
    """
    Check if a regex is likely to be too advanced for rstr.xeger.
    Returns False if the pattern uses unsupported constructs.
    """
    unsupported_tokens = [
        r"\^",         # anchors inside groups
        r"\$",         # end anchors inside groups
        r"\(\?=",      # positive lookahead
        r"\(\?!",      # negative lookahead
        r"\(\?<=",     # positive lookbehind
        r"\(\?<!",     # negative lookbehind
        r"\(\?P<",     # named groups
        r"\(\?#",      # comments
    ]
    for token in unsupported_tokens:
        if re.search(token, pattern):
            return False
    return True


def normalize_regex(pattern: str) -> str:
    """
    Normalize a regex pattern with BRE-style quirks into syntax that rstr.xeger understands.
    Silently converts what it can; leaves the rest untouched.
    """

    # Convert BRE-style quantifiers \{m,n\} → {m,n}
    pattern = re.sub(r"\\\{(\d+)(,(\d+)?)?\\\}", r"{\1\2}", pattern)

    # Convert escaped operators \+ → +, \? → ?, \. → .
    pattern = pattern.replace(r"\+", "+")
    pattern = pattern.replace(r"\?", "?")
    pattern = pattern.replace(r"\.", ".")

    # Convert escaped anchors \^ → ^, \$ → $
    pattern = pattern.replace(r"\^", "^")
    pattern = pattern.replace(r"\$", "$")

    # Clamp open-ended quantifiers {n,} → {n,10}
    pattern = re.sub(r"\{(\d+),\}", r"{\1,10}", pattern)

    # === POSIX Character Class Expansions ===
    posix_classes = {
        r"\[\[:digit:\]\]": r"\\d",            # digits 0–9
        r"\[\[:alpha:\]\]": r"[A-Za-z]",       # letters
        r"\[\[:alnum:\]\]": r"[A-Za-z0-9]",    # alphanumeric
        r"\[\[:lower:\]\]": r"[a-z]",          # lowercase
        r"\[\[:upper:\]\]": r"[A-Z]",          # uppercase
        r"\[\[:space:\]\]": r"\\s",            # whitespace
        r"\[\[:blank:\]\]": r"[ \t]",          # space + tab
        r"\[\[:punct:\]\]": r"[!\"#$%&'()*+,\-./:;<=>?@\[\]^_`{|}~]",  # punctuation
        r"\[\[:xdigit:\]\]": r"[0-9A-Fa-f]",   # hex digits
        r"\[\[:word:\]\]": r"\\w"              # word characters
    }
    for posix, replacement in posix_classes.items():
        pattern = re.sub(posix, replacement, pattern)

    # === Human-readable tweaks ===
    # Clamp greedy wildcard .* → .{0,10}
    pattern = re.sub(r"\.\*", ".{0,10}", pattern)

    # Simplify whitespace: \s → space only
    pattern = pattern.replace(r"\s", " ")

    # Tame word class: \w+ → [A-Za-z]{1,10}
    pattern = re.sub(r"\\w\+", r"[A-Za-z]{1,10}", pattern)

    return pattern


if __name__ == "__main__":

    tests = [
        r"\$[0-9]*\.[0-9][0-9]",       # Money format
        r"[A-Z]\{2,5\}",               # Escaped quantifier
        r"\d{3}-\d{2}-\d{4}",          # SSN-style
        r"hello\+world",               # Escaped +
        r"[[:digit:]]{5}",             # POSIX digit class
        r"[[:alpha:]]{3}",             # POSIX alpha
        r"[[:alnum:]]{4}",             # POSIX alnum
        r"[[:punct:]]{2}",             # POSIX punctuation
        r"[[:xdigit:]]{6}",            # POSIX hex digits
        r".*\s\w+",                    # dot/whitespace/word
        r"[0-9]\{5\}(-[0-9]\{4\})?",   # Zip Code																														   
        r"[0-9]\{3\}-[0-9]\{2\}-[0-9]\{4\}",  # Social Security																			 																		
    ]

    for pat in tests:
        print(f"{pat} → {generate_sample_from_regex(pat)}")
